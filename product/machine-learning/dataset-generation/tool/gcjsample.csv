,file,flines,full_path,round,solution,task,username,year
0,0000000000214847,"#include <algorithm>
#include <bitset>
#include <cassert>
#include <chrono>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <vector>

using namespace std;

// BEGIN NO SAD
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef vector<int> vi;
// END NO SAD

typedef long long ll;
typedef pair<int, int> pii;
typedef vector<vector<ll>> matrix;
typedef pair<ll, ll> pll;

// remember you may need to reset state

int taken[100];

bool dfs(vector<int>& v, int szneed, int totleft) {
  if(totleft < szneed - sz(v)) return false;
  if(totleft > (szneed - sz(v)) * szneed) return false;
  if(sz(v) == szneed) {
    for(int a = 1; a <= szneed; a++) if(taken[a] == szneed-1) return false;
    return true;
  }
  for(int i = 1; i <= szneed; i++) {
    taken[i]++;
    v.push_back(i);
    if(dfs(v, szneed, totleft - i)) return true;
    v.pop_back();
    taken[i]--;
  }
  return false;
}

typedef vector<int> VI;
typedef vector<VI> VVI;

bool FindMatch(int i, const VVI &w, VI &mr, VI &mc, VI &seen) {
  for (int j = 0; j < w[i].size(); j++) {
    if (w[i][j] && !seen[j]) {
      seen[j] = true;
      if (mc[j] < 0 || FindMatch(mc[j], w, mr, mc, seen)) {
        mr[i] = j;
        mc[j] = i;
        return true;
      }
    }
  }
  return false;
}

int BipartiteMatching(const VVI &w, VI &mr, VI &mc) {
  mr = VI(w.size(), -1);
  mc = VI(w[0].size(), -1);

  int ct = 0;
  for (int i = 0; i < w.size(); i++) {
    VI seen(w[0].size());
    if (FindMatch(i, w, mr, mc, seen)) ct++;
  }
  return ct;
}

int ret[55][55];

void rsolve() {
  int n, k;
  cin >> n >> k;
  vector<int> choices;
  memset(taken, 0, sizeof(taken));
  if(!dfs(choices, n, k)) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }
  set<int> present;
  for(int out: choices) present.insert(out);
  assert(sz(choices) == n);
  memset(ret, -1, sizeof(ret));
  for(int i = 0; i < n; i++) {
    ret[i][i] = choices[i];
  }
  for(int a = 1; a <= n; a++) {
    if(!present.count(a)) continue;
    vector<vector<int>> m;
    for(int i = 0; i < n; i++) {
      vector<int> can(n, 0);
      int found = -1;
      for(int j = 0; j < n; j++) {
        if(ret[i][j] == a) found = j;
      }
      if(found >= 0) {
        can[found] = 1;
      }
      else {
        for(int j = 0; j < n; j++) {
          if(ret[i][j] < 0) can[j] = 1;
        }
      }
      m.push_back(can);
    }
    vector<int> lhs, rhs;
    assert(BipartiteMatching(m, lhs, rhs) == n);
    for(int i = 0; i < n; i++) {
      ret[i][lhs[i]] = a;
    }
  }
  for(int a = 1; a <= n; a++) {
    vector<vector<int>> m;
    for(int i = 0; i < n; i++) {
      vector<int> can(n, 0);
      int found = -1;
      for(int j = 0; j < n; j++) {
        if(ret[i][j] == a) found = j;
      }
      if(found >= 0) {
        can[found] = 1;
      }
      else {
        for(int j = 0; j < n; j++) {
          if(ret[i][j] < 0) can[j] = 1;
        }
      }
      m.push_back(can);
    }
    vector<int> lhs, rhs;
    assert(BipartiteMatching(m, lhs, rhs) == n);
    for(int i = 0; i < n; i++) {
      ret[i][lhs[i]] = a;
    }
  }
  cout << ""POSSIBLE\n"";
  for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
      if(j) cout << "" "";
      cout << ret[i][j];
    }
    cout << ""\n"";
  }
}

void solve() {
  int t;
  cin >> t;
  for(int casenum = 1; casenum <= t; casenum++) {
    cout << ""Case #"" << casenum << "": "";
    rsolve();
  }
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL); cout.tie(NULL);
  solve();
}
",0000000000214847.CPP,000000000019fd27,0000000000214847,0000000000209aa0,xiaowuc1,2020
1,000000000021301e,"#include <algorithm>
#include <bitset>
#include <cassert>
#include <chrono>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <vector>

using namespace std;

// BEGIN NO SAD
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef vector<int> vi;
// END NO SAD

typedef long long ll;
typedef pair<int, int> pii;
typedef vector<vector<ll>> matrix;
typedef pair<ll, ll> pll;

// remember you may need to reset state
int numb;

int ret[200];
int numq;

int qry(int idx) {
  numq++;
  assert(idx >= 1 && idx <= numb);
  cout << idx << endl;
  int ans;
  cin >> ans;
  return ans;
}

void refresh(int amt) {
  int equal = -1;
  int different = -1;
  for(int a = 1; a <= amt; a++) {
    if(ret[a] == ret[numb+1-a]) {
      equal = a;
    }
    else {
      different = a;
    }
  }
  if(equal != -1) {
    int ans = qry(equal);
    if(ans != ret[equal]) {
      // flip everything
      for(int a = 1; a <= amt; a++) {
        ret[a] ^= 1;
        ret[numb+1-a] ^= 1;
      }
    }
    if(different != -1) {
      ans = qry(different);
      if(ans != ret[different]) {
        assert(ans == ret[numb+1-different]);
        for(int a = 1; a <= amt; a++) swap(ret[a], ret[numb+1-a]);
      }
    }
    else {
      qry(equal); // just to force it to not mess us up
    }
  }
  else {
    assert(equal == -1);
    assert(different != -1);
    int ans = qry(different);
    if(ans != ret[different]) {
      assert(ans == ret[numb+1-different]);
      for(int a = 1; a <= amt; a++) swap(ret[a], ret[numb+1-a]);
    }
    // then reversal is ""equivalent"", so we just query one bit
    qry(different); // just to avoid getting wrecked
  }
}

void rsolve() {
  cerr << numb << endl;
  numq = 0;
  memset(ret, -1, sizeof(ret));
  for(int i = 1; i <= numb/2; i++) {
    assert(numq%2 == 0);
    if(numq && numq % 10 == 0) {
      // we need to know if there was a reversal
      refresh(i-1);
    }
    ret[i] = qry(i);
    ret[numb+1-i] = qry(numb+1-i);
  }
  for(int i = 1; i <= numb; i++) {
    cout << ret[i];
  } cout << endl;
  string s;
  cin >> s;
  assert(s == ""Y"");
}

void solve() {
  int t;
  cin >> t >> numb;
  for(int casenum = 1; casenum <= t; casenum++) {
    // cout << ""Case #"" << casenum << "": "";
    rsolve();
  }
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL); cout.tie(NULL);
  solve();
}
",000000000021301e.CPP,000000000019fd27,000000000021301e,0000000000209a9e,xiaowuc1,2020
2,0000000000211171,"#include <algorithm>
#include <bitset>
#include <cassert>
#include <chrono>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <vector>

using namespace std;

// BEGIN NO SAD
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef vector<int> vi;
// END NO SAD

typedef long long ll;
typedef pair<int, int> pii;
typedef vector<vector<ll>> matrix;
typedef pair<ll, ll> pll;

// remember you may need to reset state
int lhs[1005];
int rhs[1005];
int dp[1005];
bool g[1005][1005];
void rsolve() {
  int n;
  cin >> n;
  for(int i = 0; i < n; i++) cin >> lhs[i] >> rhs[i];
  for(int i = 0; i < n; i++) {
    dp[i] = 0;
    for(int j = 0; j < n; j++) {
      if(i == j) continue;
      g[i][j] = false;
      if(lhs[j] >= rhs[i]) continue;
      if(lhs[i] >= rhs[j]) continue;
      g[i][j] = true;
    }
  }
  queue<int> q;
  string ret = """";
  for(int i = 0; sz(ret) == 0 && i < n; i++) {
    if(dp[i]) continue;
    dp[i] = 1;
    q.push(i);
    while(sz(ret) == 0 && sz(q)) {
      int curr = q.front(); q.pop();
      for(int a = 0; a < n; a++) {
        if(g[curr][a]) {
          if(dp[a] == dp[curr]) {
            ret = ""IMPOSSIBLE"";
            break;
          }
          if(dp[a] == 0) {
            dp[a] = -dp[curr];
            q.push(a);
          }
        }
      }
    }
  }
  if(sz(ret)) {
    cout << ret << ""\n"";
    return;
  }
  for(int i = 0; i < n; i++) {
    if(dp[i] == 1) cout << 'C';
    else cout << 'J';
  } cout << ""\n"";
}

void solve() {
  int t;
  cin >> t;
  for(int casenum = 1; casenum <= t; casenum++) {
    cout << ""Case #"" << casenum << "": "";
    rsolve();
  }
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL); cout.tie(NULL);
  solve();
}
",0000000000211171.CPP,000000000019fd27,0000000000211171,000000000020bdf9,xiaowuc1,2020
3,0000000000210dfc,"#include <algorithm>
#include <bitset>
#include <cassert>
#include <chrono>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <vector>

using namespace std;

// BEGIN NO SAD
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef vector<int> vi;
// END NO SAD

typedef long long ll;
typedef pair<int, int> pii;
typedef vector<vector<ll>> matrix;
typedef pair<ll, ll> pll;

// remember you may need to reset state
int g[105][105];
void rsolve() {
  string s;
  cin >> s;
  int currd = 0;
  int n = sz(s);
  for(int i = 0; i < n; i++) {
    int val = s[i] - '0';
    while(val > currd) {
      currd++;
      cout << '(';
    }
    while(val < currd) {
      currd--;
      cout << ')';
    }
    cout << s[i];
  }
  while(currd--) cout << ')';
  cout << ""\n"";
}

void solve() {
  int t;
  cin >> t;
  for(int casenum = 1; casenum <= t; casenum++) {
    cout << ""Case #"" << casenum << "": "";
    rsolve();
  }
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL); cout.tie(NULL);
  solve();
}
",0000000000210dfc.CPP,000000000019fd27,0000000000210dfc,0000000000209a9f,xiaowuc1,2020
4,0000000000210be4,"#include <algorithm>
#include <bitset>
#include <cassert>
#include <chrono>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <vector>

using namespace std;

// BEGIN NO SAD
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
typedef vector<int> vi;
// END NO SAD

typedef long long ll;
typedef pair<int, int> pii;
typedef vector<vector<ll>> matrix;
typedef pair<ll, ll> pll;

// remember you may need to reset state
int g[105][105];
void rsolve() {
  int n;
  cin >> n;
  for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
      cin >> g[i][j];
    }
  }
  int ret = 0;
  int rr = 0;
  int cc = 0;
  for(int i = 0; i < n; i++) {
    ret += g[i][i];
    bool rrr = false;
    bool ccc = false;
    for(int j = 0; j < n; j++) {
      for(int k = 0; k < j; k++) {
        rrr |= g[i][j] == g[i][k];
        ccc |= g[j][i] == g[k][i];
      }
    }
    rr += rrr;
    cc += ccc;
  }
  cout << ret << "" "" << rr << "" "" << cc << ""\n"";
}

void solve() {
  int t;
  cin >> t;
  for(int casenum = 1; casenum <= t; casenum++) {
    cout << ""Case #"" << casenum << "": "";
    rsolve();
  }
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL); cout.tie(NULL);
  solve();
}
",0000000000210be4.CPP,000000000019fd27,0000000000210be4,000000000020993c,xiaowuc1,2020
5,0000000000215114,"#include <bits/stdc++.h>
using namespace std;

#define Fi first
#define Se second
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define szz(x) (int)(x).size()
#define rep(i, n) for(int i=0;i<(n);i++)
typedef tuple<int, int, int> t3;

int B;

int Query(int x) {
	printf(""%d\n"", x);
	fflush(stdout);
	int a; scanf(""%d"", &a);
	return a;
}

void solve() {
	int ans[110] = {};
	memset(ans, -1, sizeof ans);
	auto Rev = [&]() { reverse(ans+1, ans+1+B); };
	auto Flip = [&]() { for(int i=1;i<=B;i++) if(ans[i] != -1) ans[i] = 1 - ans[i]; };
	for(int i=1;i<=5;i++) {
		ans[i] = Query(i);
		ans[B+1-i] = Query(B+1-i);
	}
	int s = 5;
	while(s * 2 < B) {
		int cq = 0;
		int f1 = -1, f2 = -1;
		for(int i=1;i<=s;i++) {
			if(ans[i] != ans[B+1-i]) f1 = i;
			else f2 = i;
		}
		if(f2 != -1) {
			int v1 = Query(f2); ++cq;
			if(v1 != ans[f2]) Flip();
		}
		if(f1 != -1) {
			int v1 = Query(f1); ++cq;
			if(v1 != ans[f1]) Rev();
		}
		int t = min((10 - cq) / 2, B - s / 2);
		for(int j=1;j<=t;j++) {
			ans[s + j] = Query(s + j);
			ans[B+1-s - j] = Query(B+1-s - j);
			cq += 2;
		}
		while(cq < 10) Query(1), cq++;
		s += t;
	}
	for(int i=1;i<=B;i++) printf(""%d"", ans[i]); puts("""");

	fflush(stdout);
	char ch[4];
	scanf(""%s"", ch);
	if(ch[0] == 'N') exit(0);
}

int main() {
	int T; scanf(""%d%d"", &T, &B);
	for(int t=1;t<=T;t++) {
		solve();
	}
	return 0;
}
",0000000000215114.CPP,000000000019fd27,0000000000215114,0000000000209a9e,cki86201,2020
6,0000000000214554,"#include <bits/stdc++.h>
using namespace std;

#define Fi first
#define Se second
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define szz(x) (int)(x).size()
#define rep(i, n) for(int i=0;i<(n);i++)
typedef tuple<int, int, int> t3;

int B;

int Query(int x) {
	printf(""%d\n"", x);
	fflush(stdout);
	int a; scanf(""%d"", &a);
	return a;
}

void solve() {
	int ans[110] = {};
	memset(ans, -1, sizeof ans);
	auto Rev = [&]() { reverse(ans+1, ans+1+B); };
	auto Flip = [&]() { for(int i=1;i<=B;i++) if(ans[i] != -1) ans[i] = 1 - ans[i]; };
	for(int i=1;i<=5;i++) {
		ans[i] = Query(i);
		ans[B+1-i] = Query(B+1-i);
	}
	int s = 5;
	while(s * 2 < B) {
		int cq = 0;
		int f1 = -1, f2 = -1;
		for(int i=1;i<=s;i++) {
			if(ans[i] != ans[B+1-i]) f1 = i;
			else f2 = i;
		}
		if(f2 != -1) {
			int v1 = Query(f2); ++cq;
			if(v1 != ans[f2]) Flip();
		}
		if(f1 != -1) {
			int v1 = Query(f1); ++cq;
			if(v1 != ans[f1]) Rev();
		}
		int t = min((10 - cq) / 2, B / 2 - s);
		for(int j=1;j<=t;j++) {
			ans[s + j] = Query(s + j);
			ans[B+1-s - j] = Query(B+1-s - j);
			cq += 2;
		}
		while(cq < 10) Query(1), cq++;
	}
	for(int i=1;i<=B;i++) printf(""%d"", ans[i]); puts("""");

	fflush(stdout);
	char ch[4];
	scanf(""%s"", ch);
	if(ch[0] == 'N') exit(0);
}

int main() {
	int T; scanf(""%d%d"", &T, &B);
	for(int t=1;t<=T;t++) {
		printf(""Case #%d: "", t);
		solve();
	}
	return 0;
}
",0000000000214554.CPP,000000000019fd27,0000000000214554,0000000000209a9e,cki86201,2020
7,0000000000213ed5,"#include <bits/stdc++.h>
using namespace std;

#define Fi first
#define Se second
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define szz(x) (int)(x).size()
#define rep(i, n) for(int i=0;i<(n);i++)
typedef tuple<int, int, int> t3;

int B;

int Query(int x) {
	printf(""%d\n"", x);
	fflush(stdout);
	int a; scanf(""%d"", &a);
	return a;
}

void solve() {
	int ans[110] = {};
	memset(ans, -1, sizeof ans);
	auto Rev = [&]() { reverse(ans+1, ans+1+B); };
	auto Flip = [&]() { for(int i=1;i<=B;i++) if(ans[i] != -1) ans[i] = 1 - ans[i]; };
	for(int i=1;i<=5;i++) {
		ans[i] = Query(i);
		ans[B+1-i] = Query(B+1-i);
	}
	int s = 5;
	while(s * 2 < B) {
		int cq = 0;
		int f1 = -1, f2 = -1;
		for(int i=1;i<=s;i++) {
			if(ans[i] != ans[B+1-i]) f1 = i;
			else f2 = i;
		}
		if(f2 != -1) {
			int v1 = Query(f2); ++cq;
			if(v1 != ans[f2]) Flip();
		}
		if(f1 != -1) {
			int v1 = Query(f1); ++cq;
			if(v1 != ans[f1]) Rev();
		}
		int t = min((10 - cq) / 2, B - s / 2);
		for(int j=1;j<=t;j++) {
			ans[s + j] = Query(s + j);
			ans[B+1-s - j] = Query(B+1-s - j);
			cq += 2;
		}
		while(cq < 10) Query(1), cq++;
	}
	for(int i=1;i<=B;i++) printf(""%d"", ans[i]); puts("""");

	fflush(stdout);
	char ch[4];
	scanf(""%s"", ch);
	if(ch[0] == 'N') exit(0);
}

int main() {
	int T; scanf(""%d%d"", &T, &B);
	for(int t=1;t<=T;t++) {
		printf(""Case #%d: "", t);
		solve();
	}
	return 0;
}
",0000000000213ed5.CPP,000000000019fd27,0000000000213ed5,0000000000209a9e,cki86201,2020
8,0000000000212170,"#include <bits/stdc++.h>
using namespace std;

#define Fi first
#define Se second
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define szz(x) (int)(x).size()
#define rep(i, n) for(int i=0;i<(n);i++)
typedef tuple<int, int, int> t3;

namespace Matching{
	//matching [1...n] <-> [1...m]
	const int MX = 120, MY = 120;
	vector <int> E[MX];
	int xy[MX], yx[MY];
	int n, m;

	void addE(int x, int y) { E[x].pb(y); }
	void setnm(int sn, int sm) { n = sn; m = sm; rep(i, MX) E[i].clear(); }

	int tdis[MX], que[MX], *dis = tdis + 1;
	int bfs() {
		int *fr = que, *re = que;
		for(int i=1;i<=n;i++) {
			if(xy[i] == -1) *fr++ = i, dis[i] = 0;
			else dis[i] = -1;
		}
		dis[-1] = -1;
		while(fr != re) {
			int t = *re++;
			if(t == -1) return 1;
			for(int e : E[t]) {
				if(dis[yx[e]] == -1) dis[yx[e]] = dis[t] + 1, *fr++ = yx[e];
			}
		}
		return 0;
	}

	int dfs(int x) {
		for(int e : E[x]) {
			if(yx[e] == -1 || (dis[yx[e]] == dis[x] + 1 && dfs(yx[e]))) {
				xy[x] = e;
				yx[e] = x;
				return 1;
			}
		}
		dis[x] = -1;
		return 0;
	}

	int Do() {
		memset(xy, -1, sizeof xy);
		memset(yx, -1, sizeof yx);

		int ans = 0;
		while(bfs()) {
			for(int i=1;i<=n;i++) if(xy[i] == -1 && dfs(i)) ++ans;
		}
		return ans;
	}
}

int N, K;

void solve() {
	scanf(""%d%d"", &N, &K);
	if(K == N+1 || K == N*N-1) puts(""IMPOSSIBLE"");
	else if(N == 3 && (K == 5 || K == 7)) puts(""IMPOSSIBLE"");
	else {
		int V[55] = {}, ans[55][55] = {};
		for(int i=1;i<=N;i++) V[i] = 1;
		int tk = K - N;
		for(int i=N;i;i--) {
			int v = min(tk, N-1);
			V[i] += v;
			tk -= v;
		}
		if(V[N] > 1 && V[N-1] == 1) {
			V[N-1]++; V[N]--;
		}
		else if(V[1] < N && V[2] == N) {
			V[1]++; V[2]--;
		}
		for(int i=1;i<=N;i++) ans[i][i] = V[i];
		int cnt[110] = {}, ord[110] = {};
		for(int i=1;i<=N;i++) cnt[V[i]]++, ord[i] = i;
		sort(ord+1, ord+1+N, [&](int x, int y) { return cnt[x] > cnt[y]; });
		for(int a=1;a<=N;a++) {
			int i = ord[a];
			Matching::setnm(N, N);
			for(int j=1;j<=N;j++) for(int k=1;k<=N;k++) if(!ans[j][k] && V[j] != i && V[k] != i) Matching::addE(j, k);
			Matching::Do();
			for(int j=1;j<=N;j++) if(Matching::xy[j] != -1) {
				int k = Matching::xy[j];
				ans[j][k] = i;
			}
		}
		puts(""POSSIBLE"");
		for(int i=1;i<=N;i++, puts("""")) for(int j=1;j<=N;j++) printf(""%d "", ans[i][j]);
	}
}

int main() {
	int T; scanf(""%d"", &T);
	for(int t=1;t<=T;t++) {
		printf(""Case #%d: "", t);
		solve();
	}
	return 0;
}
",0000000000212170.CPP,000000000019fd27,0000000000212170,0000000000209aa0,cki86201,2020
9,0000000000210efb,"#include <bits/stdc++.h>
using namespace std;

#define Fi first
#define Se second
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define szz(x) (int)(x).size()
#define rep(i, n) for(int i=0;i<(n);i++)
typedef tuple<int, int, int> t3;

pii A[1010];
int E[1010][1010], color[1010], n;

void dfs(int x, int c) {
	color[x] = c;
	for(int i=1;i<=n;i++) if(E[x][i] && color[i] == 0) dfs(i, 3 - c);
}

void solve() {
	scanf(""%d"", &n);
	for(int i=1;i<=n;i++) scanf(""%d%d"", &A[i].Fi, &A[i].Se);
	memset(E, 0, sizeof E);
	for(int i=1;i<=n;i++) for(int j=1;j<i;j++) {
		int lv = max(A[i].Fi, A[j].Fi);
		int rv = min(A[i].Se, A[j].Se);
		if(lv < rv) E[i][j] = E[j][i] = 1;
	}
	memset(color, 0, sizeof color);
	for(int i=1;i<=n;i++) if(color[i] == 0) dfs(i, 1);
	int ok = 1;
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(E[i][j] && color[i] == color[j]) ok = 0;
	if(!ok) puts(""IMPOSSIBLE"");
	else {
		for(int i=1;i<=n;i++) printf(""%c"", color[i] == 1 ? 'J' : 'C'); puts("""");
	}
}

int main() {
	int T; scanf(""%d"", &T);
	for(int t=1;t<=T;t++) {
		printf(""Case #%d: "", t);
		solve();
	}
	return 0;
}
",0000000000210efb.CPP,000000000019fd27,0000000000210efb,000000000020bdf9,cki86201,2020
10,0000000000210b57,"#include <bits/stdc++.h>
using namespace std;

#define Fi first
#define Se second
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define szz(x) (int)(x).size()
#define rep(i, n) for(int i=0;i<(n);i++)
typedef tuple<int, int, int> t3;

void solve() {
	char In[110];
	scanf(""%s"", In);
	int t = 0;
	for(int i=0;In[i];i++) {
		int c = In[i] - '0';
		while(t < c) printf(""(""), ++t;
		while(t > c) printf("")""), --t;
		printf(""%c"", In[i]);
	}
	while(t > 0) printf("")""), --t;
	puts("""");
}

int main() {
	int T; scanf(""%d"", &T);
	for(int t=1;t<=T;t++) {
		printf(""Case #%d: "", t);
		solve();
	}
	return 0;
}
",0000000000210b57.CPP,000000000019fd27,0000000000210b57,0000000000209a9f,cki86201,2020
11,0000000000210a72,"#include <bits/stdc++.h>
using namespace std;

#define Fi first
#define Se second
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define szz(x) (int)(x).size()
#define rep(i, n) for(int i=0;i<(n);i++)
typedef tuple<int, int, int> t3;

void solve() {
	int n, a[110][110];
	scanf(""%d"", &n);
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) scanf(""%d"", a[i] + j);
	int r = 0, c = 0, k = 0;
	for(int i=1;i<=n;i++) k += a[i][i];
	int chk[110][110] = {};
	for(int i=1;i<=n;i++) {
		int ok = 0;
		for(int j=1;j<=n;j++) {
			if(chk[i][a[i][j]]) ok = 1;
			chk[i][a[i][j]] = 1;
		}
		r += ok;
	}
	memset(chk, 0, sizeof chk);
	for(int i=1;i<=n;i++) {
		int ok = 0;
		for(int j=1;j<=n;j++) {
			if(chk[i][a[j][i]]) ok = 1;
			chk[i][a[j][i]] = 1;
		}
		c += ok;
	}
	printf(""%d %d %d\n"", k, r, c);
}

int main() {
	int T; scanf(""%d"", &T);
	for(int t=1;t<=T;t++) {
		printf(""Case #%d: "", t);
		solve();
	}
	return 0;
}
",0000000000210a72.CPP,000000000019fd27,0000000000210a72,000000000020993c,cki86201,2020
12,0000000000216a0b,"#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
typedef long double ld;
typedef double db; 
typedef string str; 

typedef pair<int,int> pi;
typedef pair<ll,ll> pl; 
typedef pair<db,db> pd; 

typedef vector<int> vi; 
typedef vector<ll> vl; 
typedef vector<db> vd; 
typedef vector<str> vs; 
typedef vector<pi> vpi;
typedef vector<pl> vpl; 
typedef vector<pd> vpd; 

#define mp make_pair
#define f first
#define s second
#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
#define rall(x) (x).rbegin(), (x).rend() 
#define rsz resize
#define ins insert 
#define ft front() 
#define bk back()
#define pf push_front 
#define pb push_back
#define eb emplace_back 
#define lb lower_bound 
#define ub upper_bound 

#define FOR(i,a,b) for (int i = (a); i < (b); ++i)
#define F0R(i,a) FOR(i,0,a)
#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)
#define R0F(i,a) ROF(i,0,a)
#define trav(a,x) for (auto& a: x)

const int MOD = 1e9+7; // 998244353;
const int MX = 2e5+5; 
const ll INF = 1e18; 
const ld PI = acos((ld)-1);
const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; 

template<class T> bool ckmin(T& a, const T& b) { 
	return b < a ? a = b, 1 : 0; }
template<class T> bool ckmax(T& a, const T& b) { 
	return a < b ? a = b, 1 : 0; } 
int pct(int x) { return __builtin_popcount(x); } 
int bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) 
int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 

// INPUT
template<class A> void re(complex<A>& c);
template<class A, class B> void re(pair<A,B>& p);
template<class A> void re(vector<A>& v);
template<class A, size_t SZ> void re(array<A,SZ>& a);

template<class T> void re(T& x) { cin >> x; }
void re(db& d) { str t; re(t); d = stod(t); }
void re(ld& d) { str t; re(t); d = stold(t); }
template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }

template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }
template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }
template<class A> void re(vector<A>& x) { trav(a,x) re(a); }
template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }

// TO_STRING
#define ts to_string
template<class A, class B> str ts(pair<A,B> p);
template<class A> str ts(complex<A> c) { return ts(mp(c.real(),c.imag())); }
str ts(bool b) { return b ? ""true"" : ""false""; }
str ts(char c) { str s = """"; s += c; return s; }
str ts(str s) { return s; }
str ts(const char* s) { return (str)s; }
str ts(vector<bool> v) { 
	bool fst = 1; str res = ""{"";
	F0R(i,sz(v)) {
		if (!fst) res += "", "";
		fst = 0; res += ts(v[i]);
	}
	res += ""}""; return res;
}
template<size_t SZ> str ts(bitset<SZ> b) {
	str res = """"; F0R(i,SZ) res += char('0'+b[i]);
	return res; }
template<class T> str ts(T v) {
	bool fst = 1; str res = ""{"";
	for (const auto& x: v) {
		if (!fst) res += "", "";
		fst = 0; res += ts(x);
	}
	res += ""}""; return res;
}
template<class A, class B> str ts(pair<A,B> p) {
	return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }

// OUTPUT
template<class A> void pr(A x) { cout << ts(x); }
template<class H, class... T> void pr(const H& h, const T&... t) { 
	pr(h); pr(t...); }
void ps() { pr(""\n""); } // print w/ spaces
template<class H, class... T> void ps(const H& h, const T&... t) { 
	pr(h); if (sizeof...(t)) pr("" ""); ps(t...); }

// DEBUG
void DBG() { cerr << ""]"" << endl; }
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h); if (sizeof...(t)) cerr << "", "";
	DBG(t...); }
#ifdef LOCAL // compile with -DLOCAL
#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

// FILE I/O
void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
void unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }
void setIO(string s = """") {
	unsyncIO();
	// cin.exceptions(cin.failbit); 
	// throws exception when do smth illegal
	// ex. try to read letter into int
	if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
}

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); 

/**
 * Description: Fast flow. After computing flow, edges ${u,v}$ such that 
	* $level[u] \neq -1,$ $level[v] = -1$ are part of min cut.
 * Time: $O(N^2M)$ flow, $O(M\sqrt N)$ bipartite matching
 * Source: GeeksForGeeks, Chilli
 * Verification: RMI 2017 Day 1 Fashion
	* https://pastebin.com/VJxTvEg1
 */

template<int SZ> struct Dinic {
	int N,s,t; // # verts, source, sink
	typedef ll F; // flow type
	struct Edge { int to, rev; F flow, cap; };
	vector<Edge> adj[SZ];
	void ae(int u, int v, F cap) {
		assert(cap >= 0); // don't try smth dumb
		Edge a{v,sz(adj[v]),0,cap}, b{u,sz(adj[u]),0,0};
		adj[u].pb(a), adj[v].pb(b);
	}
	int level[SZ]; typename vector<Edge>::iterator cur[SZ]; 
	bool bfs() { // level = shortest distance from source
		F0R(i,N) level[i] = -1, cur[i] = begin(adj[i]);
		queue<int> q({s}); level[s] = 0; 
		while (sz(q)) {
			int u = q.ft; q.pop();
			trav(e,adj[u]) if (level[e.to] < 0 && e.flow < e.cap) 
				q.push(e.to), level[e.to] = level[u]+1;
		}
		return level[t] >= 0;
	}
	F sendFlow(int v, F flow) {
		if (v == t) return flow;
		for (; cur[v] != end(adj[v]); cur[v]++) {
			Edge& e = *cur[v];
			if (level[e.to]!=level[v]+1||e.flow==e.cap) continue;
			auto df = sendFlow(e.to,min(flow,e.cap-e.flow));
			if (df) { // saturated at least one edge
				e.flow += df; adj[e.to][e.rev].flow -= df;
				return df;
			}
		}
		return 0;
	}
	F maxFlow(int _N, int _s, int _t) {
		N = _N, s = _s, t = _t; assert(s != t);
		F tot = 0; while (bfs()) while (F df = 
			sendFlow(s,numeric_limits<F>::max())) tot += df;
		return tot;
	}
};

// REINITIALIZE ARRAYS BETWEEN TCs

int N,K;

void inp(vi& v) { // common way to reduce amount of input
	v.rsz(1); ll A,B,C; re(v,A,B,C);
	while (sz(v) < N) v.pb((A*v.back()+B)%C+1);
}

void chk(vector<vi> v) {
	F0R(i,N) F0R(j,N) if (!(1 <= v[i][j] && v[i][j] <= N)) exit(5);
	F0R(i,N) {
		set<int> s(all(v[i]));
		if (sz(s) < N) exit(5);
	}
	F0R(i,N) FOR(j,i+1,N) swap(v[i][j],v[j][i]);
	F0R(i,N) {
		set<int> s(all(v[i]));
		if (sz(s) < N) exit(5);
	}
	int sum = 0;
	F0R(i,N) sum += v[i][i];
	assert(sum == K);
}

void fill(vector<vi>& v) {
	//dbg(""FILL"");
	FOR(i,1,N+1) {
		bool found = 0;
		F0R(j,N) if (v[0][j] == i) found = 1;
		//dbg(""FOUND"",i,found);
		if (found) continue;
		// ps(""FILL"");
		Dinic<105> D;
		F0R(a,N) {
			D.ae(0,1+a,1);
			D.ae(N+1+a,2*N+1,1);
		}
		F0R(a,N) F0R(b,N) if (!v[a][b]) {
			//dbg(""??"",1+a,N+1+b);
			D.ae(1+a,N+1+b,1);
		}
		//dbg(""START"",v);
		assert(D.maxFlow(2*N+2,0,2*N+1) == N);
		//dbg(""WUT"");
		FOR(a,1,N+1) trav(t,D.adj[a]) if (t.flow > 0) {
			//dbg(""ED"",a,t.to);
			v[a-1][t.to-N-1] = i;
		}
		//dbg(""CUR"",v);
	}
	//dbg(""OK"",v);
}

void place(int a, int b, int c) { // a twice, b once, c rest
	assert(N >= 4);
	vector<vi> res(N,vi(N));
	res[0][0] = res[1][1] = a;
	res[2][2] = b;
	FOR(i,3,N) res[i][i] = c;
	if (N == 4) {
		res[2][3] = res[3][2] = a;
		res[0][1] = res[1][3] = res[3][0] = b;
		res[0][2] = res[1][0] = res[2][1] = c;
	} else {
		if (N <= 6) {
			if (N == 5) {
				res[3][2] = res[2][4] = res[4][3] = a;
				res[0][2] = res[1][0] = res[2][1] = c;
				res[0][1] = res[1][3] = res[3][4] = res[4][0] = b;
				//dbg(""HUH"");
				//trav(t,res) dbg(t);
			} else {
				res[2][3] = res[3][4] = res[4][5] = res[5][2] = a;
				res[0][2] = res[1][0] = res[2][1] = c;
				res[0][1] = res[1][5] = res[3][0] = res[4][3] = res[5][4] = b;
				//dbg(""??"",N,K,a,b,c);
				//exit(0);
			}
		} else {
			res[2][3] = res[3][2] = a;
			res[0][1] = res[1][3] = res[3][0] = b;
			res[0][2] = res[1][0] = res[2][1] = c;
			F0R(i,N-4) {
				res[i+4][(i+1)%(N-4)+4] = a;
				res[i+4][(i+2)%(N-4)+4] = b;
			}
		}
	}
	fill(res);
	chk(res);
	F0R(i,N) {
		F0R(j,N) pr(res[i][j],' ');
		ps();
	}
}

void solve(int caseNum) {
	// cerr << ""Doing #"" << caseNum << ""\n"";
	if (K == N+1 || K == N*N-1) {
		ps(""IMPOSSIBLE"");
		return;
	}
	if (N == 3) {
		if (K == 5 || K == 7) {
			ps(""IMPOSSIBLE"");
			return;
		}
	}
	ps(""POSSIBLE"");
	int x = K/N; int b = K-N*x; int a = N-b;
	if (a == 1 || b == 1) {
		if (a == 1) {
			// x, x+1, x+1, ...
			// x, x, x+2, x+1, x+1, ...
			place(x,x+2,x+1);
		} else {
			// x, x, x, ..., x+1
			// x-1, x, x, ..., x+1, x+1
			place(x+1,x-1,x);
		}
		return;
	}
	vector<vi> res(N,vi(N));
	F0R(i,N) {
		if (i < a) res[i][i] = x;
		else res[i][i] = x+1;
	}
	if (b) {
		F0R(i,a) res[(i+1)%a][i] = x+1;
		F0R(i,b) res[(i+1)%b+a][i+a] = x;
	}
	fill(res);
	chk(res);
	//ps(""OH"");
	F0R(i,N) {
		F0R(j,N) pr(res[i][j],' ');
		ps();
	}
}

int main() {
	// setIO(""A"");
	/*FOR(_N,2,6) FOR(_K,_N,_N*_N+1) {
		N = _N, K = _K;
		solve(0);
	}*/
	//dbg(""OK"");
	//exit(0);
	int T; re(T);
	FOR(i,1,T+1) {
		pr(""Case #"",i,"": "");
		re(N,K);
		solve(i);
	}
}

/* stuff you should look for
	* int overflow, array bounds
	* special cases (n=1?)
	* do smth instead of nothing and stay organized
	* WRITE STUFF DOWN
*/

",0000000000216a0b.CPP,000000000019fd27,0000000000216a0b,0000000000209aa0,Benq,2020
13,0000000000216261,"#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
typedef long double ld;
typedef double db; 
typedef string str; 

typedef pair<int,int> pi;
typedef pair<ll,ll> pl; 
typedef pair<db,db> pd; 

typedef vector<int> vi; 
typedef vector<ll> vl; 
typedef vector<db> vd; 
typedef vector<str> vs; 
typedef vector<pi> vpi;
typedef vector<pl> vpl; 
typedef vector<pd> vpd; 

#define mp make_pair
#define f first
#define s second
#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
#define rall(x) (x).rbegin(), (x).rend() 
#define rsz resize
#define ins insert 
#define ft front() 
#define bk back()
#define pf push_front 
#define pb push_back
#define eb emplace_back 
#define lb lower_bound 
#define ub upper_bound 

#define FOR(i,a,b) for (int i = (a); i < (b); ++i)
#define F0R(i,a) FOR(i,0,a)
#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)
#define R0F(i,a) ROF(i,0,a)
#define trav(a,x) for (auto& a: x)

const int MOD = 1e9+7; // 998244353;
const int MX = 2e5+5; 
const ll INF = 1e18; 
const ld PI = acos((ld)-1);
const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; 

template<class T> bool ckmin(T& a, const T& b) { 
	return b < a ? a = b, 1 : 0; }
template<class T> bool ckmax(T& a, const T& b) { 
	return a < b ? a = b, 1 : 0; } 
int pct(int x) { return __builtin_popcount(x); } 
int bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) 
int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 

// INPUT
template<class A> void re(complex<A>& c);
template<class A, class B> void re(pair<A,B>& p);
template<class A> void re(vector<A>& v);
template<class A, size_t SZ> void re(array<A,SZ>& a);

template<class T> void re(T& x) { cin >> x; }
void re(db& d) { str t; re(t); d = stod(t); }
void re(ld& d) { str t; re(t); d = stold(t); }
template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }

template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }
template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }
template<class A> void re(vector<A>& x) { trav(a,x) re(a); }
template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }

// TO_STRING
#define ts to_string
template<class A, class B> str ts(pair<A,B> p);
template<class A> str ts(complex<A> c) { return ts(mp(c.real(),c.imag())); }
str ts(bool b) { return b ? ""true"" : ""false""; }
str ts(char c) { str s = """"; s += c; return s; }
str ts(str s) { return s; }
str ts(const char* s) { return (str)s; }
str ts(vector<bool> v) { 
	bool fst = 1; str res = ""{"";
	F0R(i,sz(v)) {
		if (!fst) res += "", "";
		fst = 0; res += ts(v[i]);
	}
	res += ""}""; return res;
}
template<size_t SZ> str ts(bitset<SZ> b) {
	str res = """"; F0R(i,SZ) res += char('0'+b[i]);
	return res; }
template<class T> str ts(T v) {
	bool fst = 1; str res = ""{"";
	for (const auto& x: v) {
		if (!fst) res += "", "";
		fst = 0; res += ts(x);
	}
	res += ""}""; return res;
}
template<class A, class B> str ts(pair<A,B> p) {
	return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }

// OUTPUT
template<class A> void pr(A x) { cout << ts(x); }
template<class H, class... T> void pr(const H& h, const T&... t) { 
	pr(h); pr(t...); }
void ps() { pr(""\n""); } // print w/ spaces
template<class H, class... T> void ps(const H& h, const T&... t) { 
	pr(h); if (sizeof...(t)) pr("" ""); ps(t...); }

// DEBUG
void DBG() { cerr << ""]"" << endl; }
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h); if (sizeof...(t)) cerr << "", "";
	DBG(t...); }
#ifdef LOCAL // compile with -DLOCAL
#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

// FILE I/O
void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
void unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }
void setIO(string s = """") {
	unsyncIO();
	// cin.exceptions(cin.failbit); 
	// throws exception when do smth illegal
	// ex. try to read letter into int
	if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
}

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); 

/**
 * Description: Fast flow. After computing flow, edges ${u,v}$ such that 
	* $level[u] \neq -1,$ $level[v] = -1$ are part of min cut.
 * Time: $O(N^2M)$ flow, $O(M\sqrt N)$ bipartite matching
 * Source: GeeksForGeeks, Chilli
 * Verification: RMI 2017 Day 1 Fashion
	* https://pastebin.com/VJxTvEg1
 */

template<int SZ> struct Dinic {
	int N,s,t; // # verts, source, sink
	typedef ll F; // flow type
	struct Edge { int to, rev; F flow, cap; };
	vector<Edge> adj[SZ];
	void ae(int u, int v, F cap) {
		assert(cap >= 0); // don't try smth dumb
		Edge a{v,sz(adj[v]),0,cap}, b{u,sz(adj[u]),0,0};
		adj[u].pb(a), adj[v].pb(b);
	}
	int level[SZ]; typename vector<Edge>::iterator cur[SZ]; 
	bool bfs() { // level = shortest distance from source
		F0R(i,N) level[i] = -1, cur[i] = begin(adj[i]);
		queue<int> q({s}); level[s] = 0; 
		while (sz(q)) {
			int u = q.ft; q.pop();
			trav(e,adj[u]) if (level[e.to] < 0 && e.flow < e.cap) 
				q.push(e.to), level[e.to] = level[u]+1;
		}
		return level[t] >= 0;
	}
	F sendFlow(int v, F flow) {
		if (v == t) return flow;
		for (; cur[v] != end(adj[v]); cur[v]++) {
			Edge& e = *cur[v];
			if (level[e.to]!=level[v]+1||e.flow==e.cap) continue;
			auto df = sendFlow(e.to,min(flow,e.cap-e.flow));
			if (df) { // saturated at least one edge
				e.flow += df; adj[e.to][e.rev].flow -= df;
				return df;
			}
		}
		return 0;
	}
	F maxFlow(int _N, int _s, int _t) {
		N = _N, s = _s, t = _t; assert(s != t);
		F tot = 0; while (bfs()) while (F df = 
			sendFlow(s,numeric_limits<F>::max())) tot += df;
		return tot;
	}
};

// REINITIALIZE ARRAYS BETWEEN TCs

int N,K;

void inp(vi& v) { // common way to reduce amount of input
	v.rsz(1); ll A,B,C; re(v,A,B,C);
	while (sz(v) < N) v.pb((A*v.back()+B)%C+1);
}

void chk(vector<vi> v) {
	F0R(i,N) F0R(j,N) if (!(1 <= v[i][j] && v[i][j] <= N)) exit(5);
	F0R(i,N) {
		set<int> s(all(v[i]));
		if (sz(s) < N) exit(5);
	}
	F0R(i,N) FOR(j,i+1,N) swap(v[i][j],v[j][i]);
	F0R(i,N) {
		set<int> s(all(v[i]));
		if (sz(s) < N) exit(5);
	}
	int sum = 0;
	F0R(i,N) sum += v[i][i];
	assert(sum == K);
}

void fill(vector<vi>& v) {
	dbg(""FILL"");
	FOR(i,1,N+1) {
		bool found = 0;
		F0R(j,N) if (v[0][j] == i) found = 1;
		dbg(""FOUND"",i,found);
		if (found) continue;
		// ps(""FILL"");
		Dinic<105> D;
		F0R(a,N) {
			D.ae(0,1+a,1);
			D.ae(N+1+a,2*N+1,1);
		}
		F0R(a,N) F0R(b,N) if (!v[a][b]) {
			//dbg(""??"",1+a,N+1+b);
			D.ae(1+a,N+1+b,1);
		}
		//dbg(""START"",v);
		assert(D.maxFlow(2*N+2,0,2*N+1) == N);
		//dbg(""WUT"");
		FOR(a,1,N+1) trav(t,D.adj[a]) if (t.flow > 0) {
			//dbg(""ED"",a,t.to);
			v[a-1][t.to-N-1] = i;
		}
		//dbg(""CUR"",v);
	}
	//dbg(""OK"",v);
}

void place(int a, int b, int c) { // a twice, b once, c rest
	assert(N >= 4);
	vector<vi> res(N,vi(N));
	res[0][0] = res[1][1] = a;
	res[2][2] = b;
	FOR(i,3,N) res[i][i] = c;
	if (N == 4) {
		res[2][3] = res[3][2] = a;
		res[0][1] = res[1][3] = res[3][0] = b;
		res[0][2] = res[1][0] = res[2][1] = c;
	} else {
		if (N <= 6) {
			if (N == 5) {
				res[3][2] = res[2][4] = res[4][3] = a;
				res[0][2] = res[1][0] = res[2][1] = c;
				res[0][1] = res[1][3] = res[3][4] = res[4][0] = b;
				//dbg(""HUH"");
				//trav(t,res) dbg(t);
			} else {
				res[2][3] = res[3][4] = res[4][5] = res[5][2] = a;
				res[0][2] = res[1][0] = res[2][1] = c;
				res[0][1] = res[1][5] = res[3][0] = res[4][3] = res[5][4] = b;
				//dbg(""??"",N,K,a,b,c);
				//exit(0);
			}
		} else {
			res[2][3] = res[3][2] = a;
			res[0][1] = res[1][3] = res[3][0] = b;
			res[0][2] = res[1][0] = res[2][1] = c;
			F0R(i,N-4) {
				res[i+4][(i+1)%(N-4)+4] = a;
				res[i+4][(i+2)%(N-4)+4] = b;
			}
		}
	}
	fill(res);
	chk(res);
}

void solve(int caseNum) {
	cerr << ""Doing #"" << caseNum << ""\n"";

	if (K == N+1 || K == N*N-1) {
		ps(""IMPOSSIBLE"");
		return;
	}
	if (N == 3) {
		if (K == 5 || K == 7) {
			ps(""IMPOSSIBLE"");
			return;
		}
	}
	ps(""POSSIBLE"");
	int x = K/N; int b = K-N*x; int a = N-b;
	if (a == 1 || b == 1) {
		if (a == 1) {
			// x, x+1, x+1, ...
			// x, x, x+2, x+1, x+1, ...
			place(x,x+2,x+1);
		} else {
			// x, x, x, ..., x+1
			// x-1, x, x, ..., x+1, x+1
			place(x+1,x-1,x);
		}
		return;
	}
	vector<vi> res(N,vi(N));
	F0R(i,N) {
		if (i < a) res[i][i] = x;
		else res[i][i] = x+1;
	}
	if (b) {
		F0R(i,a) res[(i+1)%a][i] = x+1;
		F0R(i,b) res[(i+1)%b+a][i+a] = x;
	}
	fill(res);
	chk(res);
	//ps(""OH"");
	F0R(i,N) {
		F0R(j,N) pr(res[i][j],' ');
		ps();
	}
}

int main() {
	// setIO(""A"");
	/*FOR(_N,2,21) FOR(_K,_N,_N*_N+1) {
		N = _N, K = _K;
		solve(0);
	}
	dbg(""OK"");
	exit(0);*/
	int T; re(T);
	FOR(i,1,T+1) {
		pr(""Case #"",i,"": "");
		re(N,K);
		solve(i);
	}
}

/* stuff you should look for
	* int overflow, array bounds
	* special cases (n=1?)
	* do smth instead of nothing and stay organized
	* WRITE STUFF DOWN
*/

",0000000000216261.CPP,000000000019fd27,0000000000216261,0000000000209aa0,Benq,2020
14,0000000000213183,"#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
typedef long double ld;
typedef double db; 
typedef string str; 

typedef pair<int,int> pi;
typedef pair<ll,ll> pl; 
typedef pair<db,db> pd; 

typedef vector<int> vi; 
typedef vector<ll> vl; 
typedef vector<db> vd; 
typedef vector<str> vs; 
typedef vector<pi> vpi;
typedef vector<pl> vpl; 
typedef vector<pd> vpd; 

#define mp make_pair
#define f first
#define s second
#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
#define rall(x) (x).rbegin(), (x).rend() 
#define rsz resize
#define ins insert 
#define ft front() 
#define bk back()
#define pf push_front 
#define pb push_back
#define eb emplace_back 
#define lb lower_bound 
#define ub upper_bound 

#define FOR(i,a,b) for (int i = (a); i < (b); ++i)
#define F0R(i,a) FOR(i,0,a)
#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)
#define R0F(i,a) ROF(i,0,a)
#define trav(a,x) for (auto& a: x)

const int MOD = 1e9+7; // 998244353;
const int MX = 2e5+5; 
const ll INF = 1e18; 
const ld PI = acos((ld)-1);
const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; 

template<class T> bool ckmin(T& a, const T& b) { 
	return b < a ? a = b, 1 : 0; }
template<class T> bool ckmax(T& a, const T& b) { 
	return a < b ? a = b, 1 : 0; } 
int pct(int x) { return __builtin_popcount(x); } 
int bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) 
int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 

// INPUT
template<class A> void re(complex<A>& c);
template<class A, class B> void re(pair<A,B>& p);
template<class A> void re(vector<A>& v);
template<class A, size_t SZ> void re(array<A,SZ>& a);

template<class T> void re(T& x) { cin >> x; }
void re(db& d) { str t; re(t); d = stod(t); }
void re(ld& d) { str t; re(t); d = stold(t); }
template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }

template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }
template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }
template<class A> void re(vector<A>& x) { trav(a,x) re(a); }
template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }

// TO_STRING
#define ts to_string
template<class A, class B> str ts(pair<A,B> p);
template<class A> str ts(complex<A> c) { return ts(mp(c.real(),c.imag())); }
str ts(bool b) { return b ? ""true"" : ""false""; }
str ts(char c) { str s = """"; s += c; return s; }
str ts(str s) { return s; }
str ts(const char* s) { return (str)s; }
str ts(vector<bool> v) { 
	bool fst = 1; str res = ""{"";
	F0R(i,sz(v)) {
		if (!fst) res += "", "";
		fst = 0; res += ts(v[i]);
	}
	res += ""}""; return res;
}
template<size_t SZ> str ts(bitset<SZ> b) {
	str res = """"; F0R(i,SZ) res += char('0'+b[i]);
	return res; }
template<class T> str ts(T v) {
	bool fst = 1; str res = ""{"";
	for (const auto& x: v) {
		if (!fst) res += "", "";
		fst = 0; res += ts(x);
	}
	res += ""}""; return res;
}
template<class A, class B> str ts(pair<A,B> p) {
	return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }

// OUTPUT
template<class A> void pr(A x) { cout << ts(x); }
template<class H, class... T> void pr(const H& h, const T&... t) { 
	pr(h); pr(t...); }
void ps() { pr(""\n""); } // print w/ spaces
template<class H, class... T> void ps(const H& h, const T&... t) { 
	pr(h); if (sizeof...(t)) pr("" ""); ps(t...); }

// DEBUG
void DBG() { cerr << ""]"" << endl; }
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h); if (sizeof...(t)) cerr << "", "";
	DBG(t...); }
#ifdef LOCAL // compile with -DLOCAL
#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

// FILE I/O
void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
void unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }
void setIO(string s = """") {
	unsyncIO();
	// cin.exceptions(cin.failbit); 
	// throws exception when do smth illegal
	// ex. try to read letter into int
	if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
}

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); 

int B,cnt,query;
str s;

void fin() {
	cout << s << endl;
	char c; cin >> c; assert(c == 'Y');
}

void mod(char& c) {
	if (c == '0') c = '1';
	else c = '0';
}

char get(int ind) {
	cout << ind+1 << endl; query ++; cnt ++;
	char c; re(c); return c;
}

void solve() {
	s = str(B,'.'); cnt = 0;
	int ind = 0;
	while (1) {
		assert(cnt%10 == 0);
		query = 0;
		int flip = -1, rev = -1;
		for (int i = 0; 2*i < sz(s); ++i) if (s[i] != '.') {
			if (s[i] == s[sz(s)-i-1]) {
				if (flip == -1) {
					char c = get(i);
					//dbg(""FLIP"",i,c);
					if (c != s[i]) flip = 1;
					else flip = 0;
				}
				if (flip) mod(s[i]), mod(s[sz(s)-1-i]);
			} else {
				if (rev == -1) {
					char c = get(i);
					//dbg(""REV"",i,c);
					if (c != s[i]) rev = 1;
					else rev = 0;
				}
				if (rev) mod(s[i]), mod(s[sz(s)-1-i]);
			}
		}
		while (query+2 <= 10 && ind <= sz(s)-1-ind) {
			//dbg(query,s);
			s[ind] = get(ind);
			s[sz(s)-1-ind] = get(sz(s)-1-ind);
			ind ++;
		}
		if (ind > sz(s)-1-ind) { fin(); return; }
		while (query < 10) get(0);
		assert(query == 10);
	}
}

int main() {
	int T; cin >> T >> B;
	F0R(i,T) solve();
	// you should actually read the stuff at the bottom
}

/* stuff you should look for
	* int overflow, array bounds
	* special cases (n=1?)
	* do smth instead of nothing and stay organized
	* WRITE STUFF DOWN
*/

",0000000000213183.CPP,000000000019fd27,0000000000213183,0000000000209a9e,Benq,2020
15,0000000000211175,"#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
typedef long double ld;
typedef double db; 
typedef string str; 

typedef pair<int,int> pi;
typedef pair<ll,ll> pl; 
typedef pair<db,db> pd; 

typedef vector<int> vi; 
typedef vector<ll> vl; 
typedef vector<db> vd; 
typedef vector<str> vs; 
typedef vector<pi> vpi;
typedef vector<pl> vpl; 
typedef vector<pd> vpd; 

#define mp make_pair
#define f first
#define s second
#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
#define rall(x) (x).rbegin(), (x).rend() 
#define rsz resize
#define ins insert 
#define ft front() 
#define bk back()
#define pf push_front 
#define pb push_back
#define eb emplace_back 
#define lb lower_bound 
#define ub upper_bound 

#define FOR(i,a,b) for (int i = (a); i < (b); ++i)
#define F0R(i,a) FOR(i,0,a)
#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)
#define R0F(i,a) ROF(i,0,a)
#define trav(a,x) for (auto& a: x)

const int MOD = 1e9+7; // 998244353;
const int MX = 2e5+5; 
const ll INF = 1e18; 
const ld PI = acos((ld)-1);
const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; 

template<class T> bool ckmin(T& a, const T& b) { 
	return b < a ? a = b, 1 : 0; }
template<class T> bool ckmax(T& a, const T& b) { 
	return a < b ? a = b, 1 : 0; } 
int pct(int x) { return __builtin_popcount(x); } 
int bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) 
int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 

// INPUT
template<class A> void re(complex<A>& c);
template<class A, class B> void re(pair<A,B>& p);
template<class A> void re(vector<A>& v);
template<class A, size_t SZ> void re(array<A,SZ>& a);

template<class T> void re(T& x) { cin >> x; }
void re(db& d) { str t; re(t); d = stod(t); }
void re(ld& d) { str t; re(t); d = stold(t); }
template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }

template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }
template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }
template<class A> void re(vector<A>& x) { trav(a,x) re(a); }
template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }

// TO_STRING
#define ts to_string
template<class A, class B> str ts(pair<A,B> p);
template<class A> str ts(complex<A> c) { return ts(mp(c.real(),c.imag())); }
str ts(bool b) { return b ? ""true"" : ""false""; }
str ts(char c) { str s = """"; s += c; return s; }
str ts(str s) { return s; }
str ts(const char* s) { return (str)s; }
str ts(vector<bool> v) { 
	bool fst = 1; str res = ""{"";
	F0R(i,sz(v)) {
		if (!fst) res += "", "";
		fst = 0; res += ts(v[i]);
	}
	res += ""}""; return res;
}
template<size_t SZ> str ts(bitset<SZ> b) {
	str res = """"; F0R(i,SZ) res += char('0'+b[i]);
	return res; }
template<class T> str ts(T v) {
	bool fst = 1; str res = ""{"";
	for (const auto& x: v) {
		if (!fst) res += "", "";
		fst = 0; res += ts(x);
	}
	res += ""}""; return res;
}
template<class A, class B> str ts(pair<A,B> p) {
	return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }

// OUTPUT
template<class A> void pr(A x) { cout << ts(x); }
template<class H, class... T> void pr(const H& h, const T&... t) { 
	pr(h); pr(t...); }
void ps() { pr(""\n""); } // print w/ spaces
template<class H, class... T> void ps(const H& h, const T&... t) { 
	pr(h); if (sizeof...(t)) pr("" ""); ps(t...); }

// DEBUG
void DBG() { cerr << ""]"" << endl; }
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h); if (sizeof...(t)) cerr << "", "";
	DBG(t...); }
#ifdef LOCAL // compile with -DLOCAL
#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

// FILE I/O
void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
void unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }
void setIO(string s = """") {
	unsyncIO();
	// cin.exceptions(cin.failbit); 
	// throws exception when do smth illegal
	// ex. try to read letter into int
	if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
}

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); 

// REINITIALIZE ARRAYS BETWEEN TCs

int N;

void inp(vi& v) { // common way to reduce amount of input
	v.rsz(1); ll A,B,C; re(v,A,B,C);
	while (sz(v) < N) v.pb((A*v.back()+B)%C+1);
}

void solve(int caseNum) {
	cerr << ""Doing #"" << caseNum << ""\n"";
	re(N);
	vector<array<int,3>> v(N);
	F0R(i,N) {
		re(v[i][0],v[i][1]);
		v[i][2] = i;
	}
	sort(all(v));
	str res(N,'.');
	int x = 0, y = 0;
	trav(t,v) {
		if (x <= t[0]) x = t[1], res[t[2]] = 'J';
		else if (y <= t[0]) y = t[1], res[t[2]] = 'C';
		else {
			ps(""IMPOSSIBLE"");
			return;
		}
	}
	ps(res);
}

int main() {
	// setIO(""A"");
	int T; re(T);
	FOR(i,1,T+1) {
		pr(""Case #"",i,"": "");
		solve(i);
	}
}

/* stuff you should look for
	* int overflow, array bounds
	* special cases (n=1?)
	* do smth instead of nothing and stay organized
	* WRITE STUFF DOWN
*/

",0000000000211175.CPP,000000000019fd27,0000000000211175,000000000020bdf9,Benq,2020
16,0000000000210d90,"#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
typedef long double ld;
typedef double db; 
typedef string str; 

typedef pair<int,int> pi;
typedef pair<ll,ll> pl; 
typedef pair<db,db> pd; 

typedef vector<int> vi; 
typedef vector<ll> vl; 
typedef vector<db> vd; 
typedef vector<str> vs; 
typedef vector<pi> vpi;
typedef vector<pl> vpl; 
typedef vector<pd> vpd; 

#define mp make_pair
#define f first
#define s second
#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
#define rall(x) (x).rbegin(), (x).rend() 
#define rsz resize
#define ins insert 
#define ft front() 
#define bk back()
#define pf push_front 
#define pb push_back
#define eb emplace_back 
#define lb lower_bound 
#define ub upper_bound 

#define FOR(i,a,b) for (int i = (a); i < (b); ++i)
#define F0R(i,a) FOR(i,0,a)
#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)
#define R0F(i,a) ROF(i,0,a)
#define trav(a,x) for (auto& a: x)

const int MOD = 1e9+7; // 998244353;
const int MX = 2e5+5; 
const ll INF = 1e18; 
const ld PI = acos((ld)-1);
const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; 

template<class T> bool ckmin(T& a, const T& b) { 
	return b < a ? a = b, 1 : 0; }
template<class T> bool ckmax(T& a, const T& b) { 
	return a < b ? a = b, 1 : 0; } 
int pct(int x) { return __builtin_popcount(x); } 
int bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) 
int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 

// INPUT
template<class A> void re(complex<A>& c);
template<class A, class B> void re(pair<A,B>& p);
template<class A> void re(vector<A>& v);
template<class A, size_t SZ> void re(array<A,SZ>& a);

template<class T> void re(T& x) { cin >> x; }
void re(db& d) { str t; re(t); d = stod(t); }
void re(ld& d) { str t; re(t); d = stold(t); }
template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }

template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }
template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }
template<class A> void re(vector<A>& x) { trav(a,x) re(a); }
template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }

// TO_STRING
#define ts to_string
template<class A, class B> str ts(pair<A,B> p);
template<class A> str ts(complex<A> c) { return ts(mp(c.real(),c.imag())); }
str ts(bool b) { return b ? ""true"" : ""false""; }
str ts(char c) { str s = """"; s += c; return s; }
str ts(str s) { return s; }
str ts(const char* s) { return (str)s; }
str ts(vector<bool> v) { 
	bool fst = 1; str res = ""{"";
	F0R(i,sz(v)) {
		if (!fst) res += "", "";
		fst = 0; res += ts(v[i]);
	}
	res += ""}""; return res;
}
template<size_t SZ> str ts(bitset<SZ> b) {
	str res = """"; F0R(i,SZ) res += char('0'+b[i]);
	return res; }
template<class T> str ts(T v) {
	bool fst = 1; str res = ""{"";
	for (const auto& x: v) {
		if (!fst) res += "", "";
		fst = 0; res += ts(x);
	}
	res += ""}""; return res;
}
template<class A, class B> str ts(pair<A,B> p) {
	return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }

// OUTPUT
template<class A> void pr(A x) { cout << ts(x); }
template<class H, class... T> void pr(const H& h, const T&... t) { 
	pr(h); pr(t...); }
void ps() { pr(""\n""); } // print w/ spaces
template<class H, class... T> void ps(const H& h, const T&... t) { 
	pr(h); if (sizeof...(t)) pr("" ""); ps(t...); }

// DEBUG
void DBG() { cerr << ""]"" << endl; }
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h); if (sizeof...(t)) cerr << "", "";
	DBG(t...); }
#ifdef LOCAL // compile with -DLOCAL
#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

// FILE I/O
void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
void unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }
void setIO(string s = """") {
	unsyncIO();
	// cin.exceptions(cin.failbit); 
	// throws exception when do smth illegal
	// ex. try to read letter into int
	if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
}

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); 

// REINITIALIZE ARRAYS BETWEEN TCs

int N;

void inp(vi& v) { // common way to reduce amount of input
	v.rsz(1); ll A,B,C; re(v,A,B,C);
	while (sz(v) < N) v.pb((A*v.back()+B)%C+1);
}

void solve(int caseNum) {
	cerr << ""Doing #"" << caseNum << ""\n"";
	str S; re(S);
	int cur = 0;
	str res;
	trav(c,S) {
		while (cur < c-'0') {
			res += '(';
			cur ++;
		}
		while (cur > c-'0') {
			res += ')';
			cur --;
		}
		res += c;
	}
	while (cur) {
		res += ')';
		cur --;
	}
	ps(res);
}

int main() {
	// setIO(""A"");
	int T; re(T);
	FOR(i,1,T+1) {
		pr(""Case #"",i,"": "");
		solve(i);
	}
}

/* stuff you should look for
	* int overflow, array bounds
	* special cases (n=1?)
	* do smth instead of nothing and stay organized
	* WRITE STUFF DOWN
*/

",0000000000210d90.CPP,000000000019fd27,0000000000210d90,0000000000209a9f,Benq,2020
17,0000000000210bf5,"#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
typedef long double ld;
typedef double db; 
typedef string str; 

typedef pair<int,int> pi;
typedef pair<ll,ll> pl; 
typedef pair<db,db> pd; 

typedef vector<int> vi; 
typedef vector<ll> vl; 
typedef vector<db> vd; 
typedef vector<str> vs; 
typedef vector<pi> vpi;
typedef vector<pl> vpl; 
typedef vector<pd> vpd; 

#define mp make_pair
#define f first
#define s second
#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
#define rall(x) (x).rbegin(), (x).rend() 
#define rsz resize
#define ins insert 
#define ft front() 
#define bk back()
#define pf push_front 
#define pb push_back
#define eb emplace_back 
#define lb lower_bound 
#define ub upper_bound 

#define FOR(i,a,b) for (int i = (a); i < (b); ++i)
#define F0R(i,a) FOR(i,0,a)
#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)
#define R0F(i,a) ROF(i,0,a)
#define trav(a,x) for (auto& a: x)

const int MOD = 1e9+7; // 998244353;
const int MX = 2e5+5; 
const ll INF = 1e18; 
const ld PI = acos((ld)-1);
const int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; 

template<class T> bool ckmin(T& a, const T& b) { 
	return b < a ? a = b, 1 : 0; }
template<class T> bool ckmax(T& a, const T& b) { 
	return a < b ? a = b, 1 : 0; } 
int pct(int x) { return __builtin_popcount(x); } 
int bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) 
int cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 

// INPUT
template<class A> void re(complex<A>& c);
template<class A, class B> void re(pair<A,B>& p);
template<class A> void re(vector<A>& v);
template<class A, size_t SZ> void re(array<A,SZ>& a);

template<class T> void re(T& x) { cin >> x; }
void re(db& d) { str t; re(t); d = stod(t); }
void re(ld& d) { str t; re(t); d = stold(t); }
template<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }

template<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }
template<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }
template<class A> void re(vector<A>& x) { trav(a,x) re(a); }
template<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }

// TO_STRING
#define ts to_string
template<class A, class B> str ts(pair<A,B> p);
template<class A> str ts(complex<A> c) { return ts(mp(c.real(),c.imag())); }
str ts(bool b) { return b ? ""true"" : ""false""; }
str ts(char c) { str s = """"; s += c; return s; }
str ts(str s) { return s; }
str ts(const char* s) { return (str)s; }
str ts(vector<bool> v) { 
	bool fst = 1; str res = ""{"";
	F0R(i,sz(v)) {
		if (!fst) res += "", "";
		fst = 0; res += ts(v[i]);
	}
	res += ""}""; return res;
}
template<size_t SZ> str ts(bitset<SZ> b) {
	str res = """"; F0R(i,SZ) res += char('0'+b[i]);
	return res; }
template<class T> str ts(T v) {
	bool fst = 1; str res = ""{"";
	for (const auto& x: v) {
		if (!fst) res += "", "";
		fst = 0; res += ts(x);
	}
	res += ""}""; return res;
}
template<class A, class B> str ts(pair<A,B> p) {
	return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }

// OUTPUT
template<class A> void pr(A x) { cout << ts(x); }
template<class H, class... T> void pr(const H& h, const T&... t) { 
	pr(h); pr(t...); }
void ps() { pr(""\n""); } // print w/ spaces
template<class H, class... T> void ps(const H& h, const T&... t) { 
	pr(h); if (sizeof...(t)) pr("" ""); ps(t...); }

// DEBUG
void DBG() { cerr << ""]"" << endl; }
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h); if (sizeof...(t)) cerr << "", "";
	DBG(t...); }
#ifdef LOCAL // compile with -DLOCAL
#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

// FILE I/O
void setIn(string s) { freopen(s.c_str(),""r"",stdin); }
void setOut(string s) { freopen(s.c_str(),""w"",stdout); }
void unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }
void setIO(string s = """") {
	unsyncIO();
	// cin.exceptions(cin.failbit); 
	// throws exception when do smth illegal
	// ex. try to read letter into int
	if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO
}

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); 

// REINITIALIZE ARRAYS BETWEEN TCs

int N;

void inp(vi& v) { // common way to reduce amount of input
	v.rsz(1); ll A,B,C; re(v,A,B,C);
	while (sz(v) < N) v.pb((A*v.back()+B)%C+1);
}

void solve(int caseNum) {
	cerr << ""Doing #"" << caseNum << ""\n"";
	re(N); vector<vi> v(N,vi(N)); re(v);
	int k = 0; F0R(i,N) k += v[i][i];
	int r = 0, c = 0;
	F0R(i,N) {
		set<int> s(all(v[i]));
		if (sz(s) < N) r ++;
	}
	F0R(i,N) FOR(j,i+1,N) swap(v[i][j],v[j][i]);
	F0R(i,N) {
		set<int> s(all(v[i]));
		if (sz(s) < N) c ++;
	}
	ps(k,r,c);
}

int main() {
	// setIO(""A"");
	int T; re(T);
	FOR(i,1,T+1) {
		pr(""Case #"",i,"": "");
		solve(i);
	}
}

/* stuff you should look for
	* int overflow, array bounds
	* special cases (n=1?)
	* do smth instead of nothing and stay organized
	* WRITE STUFF DOWN
*/

",0000000000210bf5.CPP,000000000019fd27,0000000000210bf5,000000000020993c,Benq,2020
18,0000000000217a6a,"#include <bits/stdc++.h>

#define itn int
#define all(x) (x).begin(), (x).end()
#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())

using namespace std;

inline int nxt() {
	int x;
	scanf(""%d"", &x);
	return x;
}

struct Kuhn {
	int n;
	vector<vector<int>> a;
	vector<int> left, right;
	vector<char> used;

	explicit Kuhn(int _n): n(_n), a(_n), left(_n, -1), right(_n, -1) {}

	void addEdge(int u, int v) {
		a[u].push_back(v);
	}

	bool dfs(int v) {
		if (used[v]) {
			return false;
		}
		used[v] = true;
		for (int x : a[v]) {
			if (right[x] == -1 || dfs(right[x])) {
				left[v] = x;
				right[x] = v;
				return true;
			}
		}
		return false;
	}

	void getMatching() {
		for (int i = 0; i < n; ++i) {
			used.assign(n, false);
			assert(dfs(i));
		}
	}
};

void fillToTheEnd(vector<vector<int>>& a) {
	int n = a.size();
	for (int x = 1; x <= n; ++x) {
		if (find(all(a[0]), x) != a[0].end()) {
			continue;
		}
		Kuhn kuhn(n);
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < n; ++j) {
				if (!a[i][j]) {
					kuhn.addEdge(i, j);
				}
			}
		}
		kuhn.getMatching();
		for (int i = 0; i < n; ++i) {
			a[i][kuhn.left[i]] = x;
		}
	}
}

bool check(int n, int k, vector<vector<int>> a) {
	int trace = 0;
	for (int i = 0; i < n; ++i) {
		trace += a[i][i];
	}
	if (trace != k) {
		return false;
	}
	for (int i = 0; i < n; ++i) {
		auto v = a[i];
		make_unique(v);
		if ((int)v.size() != n) {
			return false;
		}
	}
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < i; ++j) {
			swap(a[i][j], a[j][i]);
		}
	}
	for (int i = 0; i < n; ++i) {
		auto v = a[i];
		make_unique(v);
		if ((int)v.size() != n) {
			return false;
		}
	}
	return true;
}

// void solve(int n, int k) {
void solve() {
	int n = nxt(), k = nxt();
	if (k % n == 0) {
		int a = k / n - 1;
		cout << ""POSSIBLE\n"";
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < n; ++j) {
				cout << (j - i + a + n) % n + 1 << "" "";
			}
			cout << ""\n"";
		}
		return;
	}
	if (n < 4) {
		cout << ""IMPOSSIBLE\n"";
		return;
	}
	if (k == n + 1 || k == n * n - 1) {
		cout << ""IMPOSSIBLE\n"";
		return;
	}
	vector<vector<int>> ans(n, vector<int>(n, 0));
	bool ok = false;
	for (int a = 2; a <= n - 2; ++a) {
		if (ok) {
			break;
		}
		int b = n - a;
		for (int x = 1; x <= n; ++x) {
			if (ok) {
				break;
			}
			for (int y = 1; y <= n; ++y) {
				if (a * x + b * y == k) {
					for (int i = 0; i < a; ++i) {
						ans[i][i] = x;
						ans[i][(i + 1) % a] = y;
					}
					for (int i = a; i < n; ++i) {
						ans[i][i] = y;
						ans[i][a + (i - a + 1) % b] = x;
					}
					ok = true;
					break;
				}
			}
		}
	}
	for (int a = 3; a <= n - 6; ++a) {
		if (ok) {
			break;
		}
		for (int b = 3; a + b <= n - 3; ++b) {
			if (ok) {
				break;
			}
			int c = n - a - b;
			for (int x = 1; x <= n; ++x) {
				if (ok) {
					break;
				}
				for (int y = 1; y <= n; ++y) {
					if (ok) {
						break;
					}
					for (int z = 1; z <= n; ++z) {
						if (a * x + b * y + c * z == k) {
							for (int i = 0; i < a; ++i) {
								ans[i][i] = x;
								ans[i][(i + 1) % a] = y;
								ans[i][(i + 2) % a] = z;
							}
							for (int i = a; i < a + b; ++i) {
								ans[i][i] = y;
								ans[i][a + (i - a + 1) % b] = z;
								ans[i][a + (i - a + 2) % b] = x;
							}
							for (int i = a + b; i < n; ++i) {
								ans[i][i] = z;
								ans[i][a + b + (i - a - b + 1) % c] = x;
								ans[i][a + b + (i - a - b + 2) % c] = y;
							}
							ok = true;
							break;
						}
					}
				}
			}
		}
	}
	if (n > 4) {
		for (int x = 1; x <= n; ++x) {
			if (ok) {
				break;
			}
			for (int y = 1; y < x; ++y) {
				if (ok) {
					break;
				}
				if ((k - x - y) % (n - 2) == 0) {
					int z = (k - x - y) / (n - 2);
					if (z >= 1 && z <= n && z != x && z != y) {
						ans[0][0] = x;
						ans[1][1] = y;
						ans[0][1] = ans[1][0] = z;
						ans[n - 1][1] = x;
						ans[0][n - 1] = y;
						for (int i = 2; i < n; ++i) {
							ans[i][i] = z;
							ans[i - 1][i] = x;
							ans[i][i - 1] = y;
						}
						ans[2][1] = 0;
						ans[2][0] = y;
						ok = true;
						break;
					}
				}
			}
		}
	}
	if (n == 4 && !ok) {
		if (k == 7) {
			ans = {
				{3,4,2,1},
				{2,1,3,4},
				{4,2,1,3},
				{1,3,4,2},
			};
		} else if (k == 9) {
			ans = {
				{4,3,2,1},
				{2,1,3,4},
				{3,4,1,2},
				{1,2,4,3},
			};
		} else if (k == 11) {
			ans = {
				{4,3,2,1},
				{3,1,4,2},
				{1,2,3,4},
				{2,4,1,3},
			};
		} else if (k == 13) {
			ans = {
				{4,3,2,1},
				{2,4,1,3},
				{1,2,3,4},
				{3,1,4,2},
			};
		} else {
			assert(false);
		}
		ok = true;
	}
	if (!ok) {
		assert(false);
	}
	fillToTheEnd(ans);
	assert(check(n, k, ans));
	cout << ""POSSIBLE\n"";
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			cout << ans[i][j] << "" "";
		}
		cout << ""\n"";
	}
}

int main() {
	// for (int n = 4; n <= 50; ++n) {
	// 	for (int k = n + 2; k < n * n - 1; ++k) {
	// 		solve(n, k);
	// 	}
	// }
	int t = nxt();
	for (int i = 1; i <= t; ++i) {
		cout << ""Case #"" << i << "": "";
		solve();
	}

	return 0;
}
",0000000000217a6a.CPP,000000000019fd27,0000000000217a6a,0000000000209aa0,Golovanov399,2020
19,0000000000217a48,"#include <bits/stdc++.h>

#define itn int
#define all(x) (x).begin(), (x).end()
#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())

using namespace std;

inline int nxt() {
	int x;
	scanf(""%d"", &x);
	return x;
}

struct Kuhn {
	int n;
	vector<vector<int>> a;
	vector<int> left, right;
	vector<char> used;

	explicit Kuhn(int _n): n(_n), a(_n), left(_n, -1), right(_n, -1) {}

	void addEdge(int u, int v) {
		a[u].push_back(v);
	}

	bool dfs(int v) {
		if (used[v]) {
			return false;
		}
		used[v] = true;
		for (int x : a[v]) {
			if (right[x] == -1 || dfs(right[x])) {
				left[v] = x;
				right[x] = v;
				return true;
			}
		}
		return false;
	}

	void getMatching() {
		for (int i = 0; i < n; ++i) {
			used.assign(n, false);
			assert(dfs(i));
		}
	}
};

void fillToTheEnd(vector<vector<int>>& a) {
	int n = a.size();
	for (int x = 1; x <= n; ++x) {
		if (find(all(a[0]), x) != a[0].end()) {
			continue;
		}
		Kuhn kuhn(n);
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < n; ++j) {
				if (!a[i][j]) {
					kuhn.addEdge(i, j);
				}
			}
		}
		kuhn.getMatching();
		for (int i = 0; i < n; ++i) {
			a[i][kuhn.left[i]] = x;
		}
	}
}

bool check(int n, int k, vector<vector<int>> a) {
	int trace = 0;
	for (int i = 0; i < n; ++i) {
		trace += a[i][i];
	}
	if (trace != k) {
		return false;
	}
	for (int i = 0; i < n; ++i) {
		auto v = a[i];
		make_unique(v);
		if ((int)v.size() != n) {
			return false;
		}
	}
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < i; ++j) {
			swap(a[i][j], a[j][i]);
		}
	}
	for (int i = 0; i < n; ++i) {
		auto v = a[i];
		make_unique(v);
		if ((int)v.size() != n) {
			return false;
		}
	}
	return true;
}

// void solve(int n, int k) {
void solve() {
	int n = nxt(), k = nxt();
	if (k % n == 0) {
		int a = n / k - 1;
		cout << ""POSSIBLE\n"";
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < n; ++j) {
				cout << (j - i + a + n) % n + 1 << "" "";
			}
			cout << ""\n"";
		}
		return;
	}
	if (n < 4) {
		cout << ""IMPOSSIBLE\n"";
		return;
	}
	if (k == n + 1 || k == n * n - 1) {
		cout << ""IMPOSSIBLE\n"";
		return;
	}
	vector<vector<int>> ans(n, vector<int>(n, 0));
	bool ok = false;
	for (int a = 2; a <= n - 2; ++a) {
		if (ok) {
			break;
		}
		int b = n - a;
		for (int x = 1; x <= n; ++x) {
			if (ok) {
				break;
			}
			for (int y = 1; y <= n; ++y) {
				if (a * x + b * y == k) {
					for (int i = 0; i < a; ++i) {
						ans[i][i] = x;
						ans[i][(i + 1) % a] = y;
					}
					for (int i = a; i < n; ++i) {
						ans[i][i] = y;
						ans[i][a + (i - a + 1) % b] = x;
					}
					ok = true;
					break;
				}
			}
		}
	}
	for (int a = 3; a <= n - 6; ++a) {
		if (ok) {
			break;
		}
		for (int b = 3; a + b <= n - 3; ++b) {
			if (ok) {
				break;
			}
			int c = n - a - b;
			for (int x = 1; x <= n; ++x) {
				if (ok) {
					break;
				}
				for (int y = 1; y <= n; ++y) {
					if (ok) {
						break;
					}
					for (int z = 1; z <= n; ++z) {
						if (a * x + b * y + c * z == k) {
							for (int i = 0; i < a; ++i) {
								ans[i][i] = x;
								ans[i][(i + 1) % a] = y;
								ans[i][(i + 2) % a] = z;
							}
							for (int i = a; i < a + b; ++i) {
								ans[i][i] = y;
								ans[i][a + (i - a + 1) % b] = z;
								ans[i][a + (i - a + 2) % b] = x;
							}
							for (int i = a + b; i < n; ++i) {
								ans[i][i] = z;
								ans[i][a + b + (i - a - b + 1) % c] = x;
								ans[i][a + b + (i - a - b + 2) % c] = y;
							}
							ok = true;
							break;
						}
					}
				}
			}
		}
	}
	if (n > 4) {
		for (int x = 1; x <= n; ++x) {
			if (ok) {
				break;
			}
			for (int y = 1; y < x; ++y) {
				if (ok) {
					break;
				}
				if ((k - x - y) % (n - 2) == 0) {
					int z = (k - x - y) / (n - 2);
					if (z >= 1 && z <= n && z != x && z != y) {
						ans[0][0] = x;
						ans[1][1] = y;
						ans[0][1] = ans[1][0] = z;
						ans[n - 1][1] = x;
						ans[0][n - 1] = y;
						for (int i = 2; i < n; ++i) {
							ans[i][i] = z;
							ans[i - 1][i] = x;
							ans[i][i - 1] = y;
						}
						ans[2][1] = 0;
						ans[2][0] = y;
						ok = true;
						break;
					}
				}
			}
		}
	}
	if (n == 4 && !ok) {
		if (k == 7) {
			ans = {
				{3,4,2,1},
				{2,1,3,4},
				{4,2,1,3},
				{1,3,4,2},
			};
		} else if (k == 9) {
			ans = {
				{4,3,2,1},
				{2,1,3,4},
				{3,4,1,2},
				{1,2,4,3},
			};
		} else if (k == 11) {
			ans = {
				{4,3,2,1},
				{3,1,4,2},
				{1,2,3,4},
				{2,4,1,3},
			};
		} else if (k == 13) {
			ans = {
				{4,3,2,1},
				{2,4,1,3},
				{1,2,3,4},
				{3,1,4,2},
			};
		} else {
			assert(false);
		}
		ok = true;
	}
	if (!ok) {
		assert(false);
	}
	fillToTheEnd(ans);
	assert(check(n, k, ans));
	cout << ""POSSIBLE\n"";
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			cout << ans[i][j] << "" "";
		}
		cout << ""\n"";
	}
}

int main() {
	// for (int n = 4; n <= 50; ++n) {
	// 	for (int k = n + 2; k < n * n - 1; ++k) {
	// 		solve(n, k);
	// 	}
	// }
	int t = nxt();
	for (int i = 1; i <= t; ++i) {
		cout << ""Case #"" << i << "": "";
		solve();
	}

	return 0;
}
",0000000000217a48.CPP,000000000019fd27,0000000000217a48,0000000000209aa0,Golovanov399,2020
20,0000000000213a14,"#include <bits/stdc++.h>

#define itn int
#define all(x) (x).begin(), (x).end()
#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())

using namespace std;

inline int nxt() {
	int x;
	// scanf(""%d"", &x);
	cin >> x;
	return x;
}

int n;

int ask(int i) {
	cout << i + 1 << endl;
	return nxt();
}

void solve() {
	vector<int> equals, nonequals;
	vector<int> val(n);
	int rem = 0;
	for (int i = 0; 2 * i + 1 <= n; ++i) {
		if (!rem) {
			rem = 10;
			if (!equals.empty()) {
				rem -= 1;
				if (val[equals[0]] != ask(equals[0])) {
					for (int j : equals) {
						val[j] ^= 1;
						if (j != n - 1 - j) {
							val[n - 1 - j] ^= 1;
						}
					}
				}
			}
			if (!nonequals.empty()) {
				rem -= 1;
				if (val[nonequals[0]] != ask(nonequals[0])) {
					for (int j : nonequals) {
						val[j] ^= 1;
						if (j != n - 1 - j) {
							val[n - 1 - j] ^= 1;
						}
					}
				}
			}
			if (rem % 2) {
				ask(0);
				rem -= 1;
			}
		}
		rem -= 2;
		val[i] = ask(i);
		val[n - 1 - i] = ask(n - 1 - i);
		if (val[i] == val[n - 1 - i]) {
			equals.push_back(i);
		} else {
			nonequals.push_back(n - 1 - i);
		}
	}
	while (rem) {
		rem -= 1;
		ask(0);
	}
	rem += 10;
	if (!equals.empty()) {
		rem -= 2;
		ask(n - 1 - equals[0]);
		if (val[equals[0]] != ask(equals[0])) {
			for (int j : equals) {
				val[j] ^= 1;
				if (j != n - 1 - j) {
					val[n - 1 - j] ^= 1;
				}
			}
		}
	}
	if (!nonequals.empty()) {
		rem -= 2;
		ask(n - 1 - nonequals[0]);
		if (val[nonequals[0]] != ask(nonequals[0])) {
			for (int j : nonequals) {
				val[j] ^= 1;
				if (j != n - 1 - j) {
					val[n - 1 - j] ^= 1;
				}
			}
		}
	}
	for (int x : val) {
		cout << x;
	}
	cout << endl;
	string resp;
	cin >> resp;
	// assert(resp == ""Y"");
	if (resp == ""N"") {
		exit(0);
	}
}

int main() {
	int t = nxt(); n = nxt();
	for (int i = 1; i <= t; ++i) {
		// cout << ""Case #"" << i << "": "";
		solve();
	}

	return 0;
}
",0000000000213a14.CPP,000000000019fd27,0000000000213a14,0000000000209a9e,Golovanov399,2020
21,0000000000211425,"#include <bits/stdc++.h>

#define itn int
#define all(x) (x).begin(), (x).end()
#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())

using namespace std;

inline int nxt() {
	int x;
	scanf(""%d"", &x);
	return x;
}

struct Activity {
	int id;
	int from;
	int to;

	bool operator <(const Activity& ot) {
		return tie(from, to) < tie(ot.from, ot.to);
	}
};

bool intersect(const Activity& fst, const Activity& snd) {
	return max(fst.from, snd.from) < min(fst.to, snd.to);
}

void solve() {
	int n = nxt();
	vector<Activity> a(n);
	for (int i = 0; i < n; ++i) {
		a[i].id = i;
		a[i].from = nxt();
		a[i].to = nxt();
	}
	vector<vector<int>> g(n);
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < i; ++j) {
			if (intersect(a[i], a[j])) {
				g[i].push_back(j);
				g[j].push_back(i);
			}
		}
	}

	string ans(n, 0);
	for (int i = 0; i < n; ++i) {
		if (ans[i]) {
			continue;
		}
		vector<int> st = {i};
		ans[i] = 'C';
		while (!st.empty()) {
			int v = st.back();
			st.pop_back();
			for (int x : g[v]) {
				if (ans[x]) {
					if (ans[x] == ans[v]) {
						cout << ""IMPOSSIBLE\n"";
						return;
					}
				} else {
					ans[x] = (ans[v] == 'C') ? 'J' : 'C';
					st.push_back(x);
				}
			}
		}
	}
	cout << ans << ""\n"";
}

int main() {
	int t = nxt();
	for (int i = 1; i <= t; ++i) {
		cout << ""Case #"" << i << "": "";
		solve();
	}

	return 0;
}
",0000000000211425.CPP,000000000019fd27,0000000000211425,000000000020bdf9,Golovanov399,2020
22,0000000000210cde,"#include <bits/stdc++.h>

#define itn int
#define all(x) (x).begin(), (x).end()
#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())

using namespace std;

inline int nxt() {
	int x;
	scanf(""%d"", &x);
	return x;
}

void solve() {
	string s;
	cin >> s;
	int n = s.size();
	auto t = s;
	vector<int> open(n), close(n);
	for (char d = '9'; d > '0'; --d) {
		int l = -1, r = -1;
		for (int i = 0; i < n; ++i) {
			if (s[i] == d) {
				if (r == -1) {
					l = r = i;
				} else if (i > r + 1) {
					open[l] += 1;
					close[r] += 1;
					l = r = i;
				} else {
					r = i;
				}
				--s[i];
			}
		}
		if (r > -1) {
			open[l] += 1;
			close[r] += 1;
		}
	}
	s = t;
	for (int i = 0; i < n; ++i) {
		cout << string(open[i], '(') << s[i] << string(close[i], ')');
	}
	cout << ""\n"";
}

int main() {
	int t = nxt();
	for (int i = 1; i <= t; ++i) {
		cout << ""Case #"" << i << "": "";
		solve();
	}

	return 0;
}
",0000000000210cde.CPP,000000000019fd27,0000000000210cde,0000000000209a9f,Golovanov399,2020
23,0000000000210b40,"#include <bits/stdc++.h>

#define itn int
#define all(x) (x).begin(), (x).end()
#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())

using namespace std;

inline int nxt() {
	int x;
	scanf(""%d"", &x);
	return x;
}

void solve() {
	int n = nxt();
	vector<vector<int>> a(n);
	for (auto& v : a) {
		v.resize(n);
		generate(all(v), nxt);
	}
	int trace = 0;
	for (int i = 0; i < n; ++i) {
		trace += a[i][i];
	}
	cout << trace << "" "";
	int rows = 0;
	for (int i = 0; i < n; ++i) {
		auto v = a[i];
		sort(all(v));
		bool ok = true;
		for (int j = 0; j < n; ++j) {
			if (v[j] != j + 1) {
				ok = false;
			}
		}
		rows += !ok;
	}
	cout << rows << "" "";
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < i; ++j) {
			swap(a[i][j], a[j][i]);
		}
	}
	int cols = 0;
	for (int i = 0; i < n; ++i) {
		auto v = a[i];
		sort(all(v));
		bool ok = true;
		for (int j = 0; j < n; ++j) {
			if (v[j] != j + 1) {
				ok = false;
			}
		}
		cols += !ok;
	}
	cout << cols << ""\n"";
}

int main() {
	int t = nxt();
	for (int i = 1; i <= t; ++i) {
		cout << ""Case #"" << i << "": "";
		solve();
	}

	return 0;
}
",0000000000210b40.CPP,000000000019fd27,0000000000210b40,000000000020993c,Golovanov399,2020
24,0000000000217c3d,"#include <bits/stdc++.h>
#define fi first
#define se second
#define rep(i,n) for(int i = 0; i < (n); ++i)
#define rrep(i,n) for(int i = 1; i <= (n); ++i)
#define drep(i,n) for(int i = (n)-1; i >= 0; --i)
#define srep(i,s,t) for (int i = s; i < t; ++i)
#define rng(a) a.begin(),a.end()
#define rrng(a) a.rbegin(),a.rend()
#define maxs(x,y) (x = max(x,y))
#define mins(x,y) (x = min(x,y))
#define limit(x,l,r) max(l,min(x,r))
#define lims(x,l,r) (x = max(l,min(x,r)))
#define isin(x,l,r) ((l) <= (x) && (x) < (r))
#define pb push_back
#define eb emplace_back
#define sz(x) (int)(x).size()
#define pcnt __builtin_popcountll
#define uni(x) x.erase(unique(rng(x)),x.end())
#define snuke srand((unsigned)clock()+(unsigned)time(NULL));
#define show(x) cout<<#x<<"" = ""<<x<<endl;
#define PQ(T) priority_queue<T,v(T),greater<T> >
#define bn(x) ((1<<x)-1)
#define dup(x,y) (((x)+(y)-1)/(y))
#define newline puts("""")
#define v(T) vector<T>
#define vv(T) v(v(T))
using namespace std;
typedef long long ll;
typedef unsigned uint;
typedef unsigned long long ull;
typedef pair<int,int> P;
typedef tuple<int,int,int> T;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vl;
typedef vector<P> vp;
typedef vector<T> vt;
inline int getInt() { int x; scanf(""%d"",&x); return x;}
template<typename T>inline istream& operator>>(istream&i,v(T)&v)
{rep(j,sz(v))i>>v[j];return i;}
template<typename T>string join(const v(T)&v)
{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}
template<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)
{if(sz(v))o<<join(v);return o;}
template<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)
{return i>>v.fi>>v.se;}
template<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)
{return o<<v.fi<<"",""<<v.se;}
template<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}
const double eps = 1e-10;
const ll LINF = 1001002003004005006ll;
const int INF = 1001001001;
#define dame { puts(""IMPOSSIBLE""); return;}
#define yn {puts(""YES"");}else{puts(""NO"");}
const int MX = 200005;

// bipartite matching
struct match {
  vi pre, root;
  vvi to;
  vi p, q;
  int n, m;
  match(int n, int m):pre(n,-1),root(n,-1),to(n),p(n,-1),q(m,-1),n(n),m(m){}
  void add(int a, int b) { to[a].pb(b);}
  int solve() {
    int res = 0;
    bool upd = true;
    while (upd) {
      upd = false;
      queue<int> s;
      rep(i,n) if (!~p[i]) {
        root[i] = i;
        s.push(i);
      }
      while (sz(s)) {
        int v = s.front(); s.pop();
        if (~p[root[v]]) continue;
        rep(i,sz(to[v])) {
          int u = to[v][i];
          if (!~q[u]) {
            while (~u) {
              q[u] = v;
              swap(p[v],u);
              v = pre[v];
            }
            upd = true;
            ++res;
            break;
          }
          u = q[u];
          if (~pre[u]) continue;
          pre[u] = v; root[u] = root[v];
          s.push(u);
        }
      }
      if (upd) fill(rng(pre),-1), fill(rng(root),-1);
    }
    return res;
  }
};
//
struct Solver {
  void solve() {
    int n,k;
    scanf(""%d%d"",&n,&k);
    if (k < n || k > n*n) dame;
    vvi ans(n,vi(n));
    if (k%n == 0) {
      rep(i,n) ans[i][i] = k/n;
    } else {
      if (k == n+1 || k == n*n-1) dame;
      if (n <= 3) dame;
      vi a(n);
      rep(i,k) a[i%n]++;
      int r = k%n;
      bool three = true;
      if (r == 1) {
        a[1]++; a[n-1]--;
      } else if (r == n-1) {
        a[0]++; a[n-2]--;
        reverse(rng(a));
      } else {
        int x = a[0], y = a.back();
        rep(i,r) ans[i][(i+1)%r] = y;
        rep(i,(n-r)) ans[r+i][r+(i+1)%(n-r)] = x;
        three = false;
      }
      if (three) {
        int x = a[0], y = a[2], z = a.back();
        ans[0][1] = ans[1].back() = ans.back()[0] = y;
        rep(i,n-1) ans[(i+1)%(n-1)][i] = z;
        rep(i,n-2) ans[2+i][2+(i+1)%(n-2)] = x;
      }
      rep(i,n) ans[i][i] = a[i];
    }
    rrep(x,n) {
      int cnt = 0;
      rep(i,n)rep(j,n) if (ans[i][j] == x) ++cnt;
      if (cnt) {
        assert(cnt == n);
        continue;
      }
      match g(n,n);
      rep(i,n)rep(j,n) if (ans[i][j] == 0) g.add(i,j);
      g.solve();
      rep(i,n) ans[i][g.p[i]] = x;
    }
    cout<<""POSSIBLE""<<endl;
    rep(i,n) cout<<ans[i]<<endl;
  }
};

int main() {
  int ts;
  scanf(""%d"",&ts);
  rrep(ti,ts) {
    Solver solver;
    printf(""Case #%d: "",ti);
    solver.solve();
  }
  return 0;
}




















",0000000000217c3d.CPP,000000000019fd27,0000000000217c3d,0000000000209aa0,Snuke,2020
25,0000000000215a31,"#include <bits/stdc++.h>
#define fi first
#define se second
#define rep(i,n) for(int i = 0; i < (n); ++i)
#define rrep(i,n) for(int i = 1; i <= (n); ++i)
#define drep(i,n) for(int i = (n)-1; i >= 0; --i)
#define srep(i,s,t) for (int i = s; i < t; ++i)
#define rng(a) a.begin(),a.end()
#define rrng(a) a.rbegin(),a.rend()
#define maxs(x,y) (x = max(x,y))
#define mins(x,y) (x = min(x,y))
#define limit(x,l,r) max(l,min(x,r))
#define lims(x,l,r) (x = max(l,min(x,r)))
#define isin(x,l,r) ((l) <= (x) && (x) < (r))
#define pb push_back
#define eb emplace_back
#define sz(x) (int)(x).size()
#define pcnt __builtin_popcountll
#define uni(x) x.erase(unique(rng(x)),x.end())
#define snuke srand((unsigned)clock()+(unsigned)time(NULL));
#define show(x) cout<<#x<<"" = ""<<x<<endl;
#define PQ(T) priority_queue<T,v(T),greater<T> >
#define bn(x) ((1<<x)-1)
#define dup(x,y) (((x)+(y)-1)/(y))
#define newline puts("""")
#define v(T) vector<T>
#define vv(T) v(v(T))
using namespace std;
typedef long long ll;
typedef unsigned uint;
typedef unsigned long long ull;
typedef pair<int,int> P;
typedef tuple<int,int,int> T;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vl;
typedef vector<P> vp;
typedef vector<T> vt;
inline int getInt() { int x; scanf(""%d"",&x); return x;}
template<typename T>inline istream& operator>>(istream&i,v(T)&v)
{rep(j,sz(v))i>>v[j];return i;}
template<typename T>string join(const v(T)&v)
{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}
template<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)
{if(sz(v))o<<join(v);return o;}
template<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)
{return i>>v.fi>>v.se;}
template<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)
{return o<<v.fi<<"",""<<v.se;}
template<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}
const double eps = 1e-10;
const ll LINF = 1001002003004005006ll;
const int INF = 1001001001;
#define dame { puts(""-1""); return;}
#define yn {puts(""YES"");}else{puts(""NO"");}
const int MX = 200005;

int n;

struct Solver {
  int cnt;
  int f(int i) {
    ++cnt;
    cout<<i+1<<endl;
    int res;
    cin>>res;
    return res;
  }
  void solve() {
    vi ans(n);
    vi a(n,-1);
    int si = -1, di = -1;
    cnt = 0;
    rep(i,n) {
      int j = n-1-i;
      if (i > j) break;
      if (cnt%10 == 0) {
        if (si != -1 || di != -1) {
          if (si == -1) f(0); else {
            if (f(si) != ans[si]) {
              rep(k,n) ans[k] ^= 1;
            }
          }
          if (di == -1) f(0); else {
            if (f(di) != ans[di]) reverse(rng(ans));
          }
        }
      }
      ans[i] = f(i);
      ans[j] = f(j);
      if (ans[i] == ans[j]) si = i;
      else di = i;
    }
    string as;
    rep(i,n) as += '0'+ans[i];
    cout<<as<<endl;
    cin>>as;
  }
};

int main() {
  int ts;
  cin>>ts>>n;
  rrep(ti,ts) {
    Solver solver;
    solver.solve();
  }
  return 0;
}




















",0000000000215a31.CPP,000000000019fd27,0000000000215a31,0000000000209a9e,Snuke,2020
26,000000000021385c,"#include <bits/stdc++.h>
#define fi first
#define se second
#define rep(i,n) for(int i = 0; i < (n); ++i)
#define rrep(i,n) for(int i = 1; i <= (n); ++i)
#define drep(i,n) for(int i = (n)-1; i >= 0; --i)
#define srep(i,s,t) for (int i = s; i < t; ++i)
#define rng(a) a.begin(),a.end()
#define rrng(a) a.rbegin(),a.rend()
#define maxs(x,y) (x = max(x,y))
#define mins(x,y) (x = min(x,y))
#define limit(x,l,r) max(l,min(x,r))
#define lims(x,l,r) (x = max(l,min(x,r)))
#define isin(x,l,r) ((l) <= (x) && (x) < (r))
#define pb push_back
#define eb emplace_back
#define sz(x) (int)(x).size()
#define pcnt __builtin_popcountll
#define uni(x) x.erase(unique(rng(x)),x.end())
#define snuke srand((unsigned)clock()+(unsigned)time(NULL));
#define show(x) cout<<#x<<"" = ""<<x<<endl;
#define PQ(T) priority_queue<T,v(T),greater<T> >
#define bn(x) ((1<<x)-1)
#define dup(x,y) (((x)+(y)-1)/(y))
#define newline puts("""")
#define v(T) vector<T>
#define vv(T) v(v(T))
using namespace std;
typedef long long ll;
typedef unsigned uint;
typedef unsigned long long ull;
typedef pair<int,int> P;
typedef tuple<int,int,int> T;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vl;
typedef vector<P> vp;
typedef vector<T> vt;
inline int getInt() { int x; scanf(""%d"",&x); return x;}
template<typename T>inline istream& operator>>(istream&i,v(T)&v)
{rep(j,sz(v))i>>v[j];return i;}
template<typename T>string join(const v(T)&v)
{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}
template<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)
{if(sz(v))o<<join(v);return o;}
template<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)
{return i>>v.fi>>v.se;}
template<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)
{return o<<v.fi<<"",""<<v.se;}
template<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}
const double eps = 1e-10;
const ll LINF = 1001002003004005006ll;
const int INF = 1001001001;
#define dame { puts(""IMPOSSIBLE""); return;}
#define yn {puts(""YES"");}else{puts(""NO"");}
const int MX = 200005;

struct Solver {
  void solve() {
    int n;
    scanf(""%d"",&n);
    vt a;
    rep(i,n) {
      int l,r;
      scanf(""%d%d"",&l,&r);
      a.eb(l,r,i);
    }
    sort(rng(a));
    vi rs(2,-INF);
    string ans(n,'?');
    rep(i,n) {
      int l,r,ai;
      tie(l,r,ai) = a[i];
      bool ok = false;
      rep(j,2) {
        if (l < rs[j]) continue;
        rs[j] = r;
        ans[ai] = ""CJ""[j];
        ok = true;
        break;
      }
      if (!ok) dame;
    }
    cout<<ans<<endl;
  }
};

int main() {
  int ts;
  scanf(""%d"",&ts);
  rrep(ti,ts) {
    Solver solver;
    printf(""Case #%d: "",ti);
    solver.solve();
  }
  return 0;
}




















",000000000021385c.CPP,000000000019fd27,000000000021385c,000000000020bdf9,Snuke,2020
27,0000000000212f43,"#include <bits/stdc++.h>
#define fi first
#define se second
#define rep(i,n) for(int i = 0; i < (n); ++i)
#define rrep(i,n) for(int i = 1; i <= (n); ++i)
#define drep(i,n) for(int i = (n)-1; i >= 0; --i)
#define srep(i,s,t) for (int i = s; i < t; ++i)
#define rng(a) a.begin(),a.end()
#define rrng(a) a.rbegin(),a.rend()
#define maxs(x,y) (x = max(x,y))
#define mins(x,y) (x = min(x,y))
#define limit(x,l,r) max(l,min(x,r))
#define lims(x,l,r) (x = max(l,min(x,r)))
#define isin(x,l,r) ((l) <= (x) && (x) < (r))
#define pb push_back
#define eb emplace_back
#define sz(x) (int)(x).size()
#define pcnt __builtin_popcountll
#define uni(x) x.erase(unique(rng(x)),x.end())
#define snuke srand((unsigned)clock()+(unsigned)time(NULL));
#define show(x) cout<<#x<<"" = ""<<x<<endl;
#define PQ(T) priority_queue<T,v(T),greater<T> >
#define bn(x) ((1<<x)-1)
#define dup(x,y) (((x)+(y)-1)/(y))
#define newline puts("""")
#define v(T) vector<T>
#define vv(T) v(v(T))
using namespace std;
typedef long long ll;
typedef unsigned uint;
typedef unsigned long long ull;
typedef pair<int,int> P;
typedef tuple<int,int,int> T;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vl;
typedef vector<P> vp;
typedef vector<T> vt;
inline int getInt() { int x; scanf(""%d"",&x); return x;}
template<typename T>inline istream& operator>>(istream&i,v(T)&v)
{rep(j,sz(v))i>>v[j];return i;}
template<typename T>string join(const v(T)&v)
{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}
template<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)
{if(sz(v))o<<join(v);return o;}
template<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)
{return i>>v.fi>>v.se;}
template<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)
{return o<<v.fi<<"",""<<v.se;}
template<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}
const double eps = 1e-10;
const ll LINF = 1001002003004005006ll;
const int INF = 1001001001;
#define dame { puts(""-1""); return;}
#define yn {puts(""YES"");}else{puts(""NO"");}
const int MX = 200005;

struct Solver {
  void solve() {
    string s;
    cin>>s;
    int x = 0;
    string ans;
    for (char c : s) {
      int a = c-'0';
      while (x < a) ans += '(', ++x;
      while (x > a) ans += ')', --x;
      ans += c;
    }
    while (x) ans += ')', --x;
    cout<<ans<<endl;
  }
};

int main() {
  int ts;
  scanf(""%d"",&ts);
  rrep(ti,ts) {
    Solver solver;
    printf(""Case #%d: "",ti);
    solver.solve();
  }
  return 0;
}




















",0000000000212f43.CPP,000000000019fd27,0000000000212f43,0000000000209a9f,Snuke,2020
28,0000000000211da6,"#include <bits/stdc++.h>
#define fi first
#define se second
#define rep(i,n) for(int i = 0; i < (n); ++i)
#define rrep(i,n) for(int i = 1; i <= (n); ++i)
#define drep(i,n) for(int i = (n)-1; i >= 0; --i)
#define srep(i,s,t) for (int i = s; i < t; ++i)
#define rng(a) a.begin(),a.end()
#define rrng(a) a.rbegin(),a.rend()
#define maxs(x,y) (x = max(x,y))
#define mins(x,y) (x = min(x,y))
#define limit(x,l,r) max(l,min(x,r))
#define lims(x,l,r) (x = max(l,min(x,r)))
#define isin(x,l,r) ((l) <= (x) && (x) < (r))
#define pb push_back
#define eb emplace_back
#define sz(x) (int)(x).size()
#define pcnt __builtin_popcountll
#define uni(x) x.erase(unique(rng(x)),x.end())
#define snuke srand((unsigned)clock()+(unsigned)time(NULL));
#define show(x) cout<<#x<<"" = ""<<x<<endl;
#define PQ(T) priority_queue<T,v(T),greater<T> >
#define bn(x) ((1<<x)-1)
#define dup(x,y) (((x)+(y)-1)/(y))
#define newline puts("""")
#define v(T) vector<T>
#define vv(T) v(v(T))
using namespace std;
typedef long long ll;
typedef unsigned uint;
typedef unsigned long long ull;
typedef pair<int,int> P;
typedef tuple<int,int,int> T;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vl;
typedef vector<P> vp;
typedef vector<T> vt;
inline int getInt() { int x; scanf(""%d"",&x); return x;}
template<typename T>inline istream& operator>>(istream&i,v(T)&v)
{rep(j,sz(v))i>>v[j];return i;}
template<typename T>string join(const v(T)&v)
{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}
template<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)
{if(sz(v))o<<join(v);return o;}
template<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)
{return i>>v.fi>>v.se;}
template<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)
{return o<<v.fi<<"",""<<v.se;}
template<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}
const double eps = 1e-10;
const ll LINF = 1001002003004005006ll;
const int INF = 1001001001;
#define dame { puts(""-1""); return;}
#define yn {puts(""YES"");}else{puts(""NO"");}
const int MX = 200005;

struct Solver {
  void solve() {
    int n;
    scanf(""%d"",&n);
    vvi a(n,vi(n));
    cin>>a;
    int ans = 0;
    rep(i,n) ans += a[i][i];
    int r = 0, c = 0;
    rep(i,n) {
      set<int> s;
      rep(j,n) s.insert(a[i][j]);
      r += sz(s) != n;
    }
    rep(j,n) {
      set<int> s;
      rep(i,n) s.insert(a[i][j]);
      c += sz(s) != n;
    }
    cout<<ans<<"" ""<<r<<"" ""<<c<<endl;
  }
};

int main() {
  int ts;
  scanf(""%d"",&ts);
  rrep(ti,ts) {
    Solver solver;
    printf(""Case #%d: "",ti);
    solver.solve();
  }
  return 0;
}




















",0000000000211da6.CPP,000000000019fd27,0000000000211da6,000000000020993c,Snuke,2020
29,0000000000211cc5,"#include <bits/stdc++.h>
#define fi first
#define se second
#define rep(i,n) for(int i = 0; i < (n); ++i)
#define rrep(i,n) for(int i = 1; i <= (n); ++i)
#define drep(i,n) for(int i = (n)-1; i >= 0; --i)
#define srep(i,s,t) for (int i = s; i < t; ++i)
#define rng(a) a.begin(),a.end()
#define rrng(a) a.rbegin(),a.rend()
#define maxs(x,y) (x = max(x,y))
#define mins(x,y) (x = min(x,y))
#define limit(x,l,r) max(l,min(x,r))
#define lims(x,l,r) (x = max(l,min(x,r)))
#define isin(x,l,r) ((l) <= (x) && (x) < (r))
#define pb push_back
#define eb emplace_back
#define sz(x) (int)(x).size()
#define pcnt __builtin_popcountll
#define uni(x) x.erase(unique(rng(x)),x.end())
#define snuke srand((unsigned)clock()+(unsigned)time(NULL));
#define show(x) cout<<#x<<"" = ""<<x<<endl;
#define PQ(T) priority_queue<T,v(T),greater<T> >
#define bn(x) ((1<<x)-1)
#define dup(x,y) (((x)+(y)-1)/(y))
#define newline puts("""")
#define v(T) vector<T>
#define vv(T) v(v(T))
using namespace std;
typedef long long ll;
typedef unsigned uint;
typedef unsigned long long ull;
typedef pair<int,int> P;
typedef tuple<int,int,int> T;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vl;
typedef vector<P> vp;
typedef vector<T> vt;
inline int getInt() { int x; scanf(""%d"",&x); return x;}
template<typename T>inline istream& operator>>(istream&i,v(T)&v)
{rep(j,sz(v))i>>v[j];return i;}
template<typename T>string join(const v(T)&v)
{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}
template<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)
{if(sz(v))o<<join(v);return o;}
template<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)
{return i>>v.fi>>v.se;}
template<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)
{return o<<v.fi<<"",""<<v.se;}
template<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}
const double eps = 1e-10;
const ll LINF = 1001002003004005006ll;
const int INF = 1001001001;
#define dame { puts(""-1""); return;}
#define yn {puts(""YES"");}else{puts(""NO"");}
const int MX = 200005;

struct Solver {
  void solve() {
    int n;
    scanf(""%d"",&n);
    vvi a(n,vi(n));
    cin>>a;
    int ans = 0;
    rep(i,n) ans += a[i][i];
    int r = 0, c = 0;
    rep(i,n) {
      set<int> s;
      rep(j,n) s.insert(a[i][j]);
      r += sz(s) != n;
    }
    rep(j,n) {
      set<int> s;
      rep(i,n) s.insert(a[i][j]);
      c += sz(s) != n;
    }
    cout<<ans<<"" ""<<r<<"" ""<<c<<endl;
  }
};

int main() {
  int ts;
  scanf(""%d"",&ts);
  rrep(ti,ts) {
    Solver solver;
    printf(""Case #%d: "",ti);
    solver.solve();
  }
  return 0;
}




















",0000000000211cc5.PYTHON3,000000000019fd27,0000000000211cc5,000000000020993c,Snuke,2020
30,0000000000218bb8,"#include <bits/stdc++.h>
using namespace std;
typedef vector<int> vi;
typedef vector<pair<int, int> > vpii;
typedef pair<int, int> pii;
typedef long long ll;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;
typedef vector<ll> vll;
#define INF 0x3f3f3f3f
#define MOD 1000000007LL
#define EPSILON 0.00001
#define f first
#define s second
#define pb push_back
#define mp make_pair

#define FOR(i, a, b) for (ll i=(a); i<=(signed)(b); i++)
#define F0R(i, a) for (ll i=0; i<(signed)(a); i++)
#define RFOR(i, a, b) for (ll i=(a); i >= b; i--)

#define MN 105
int tc;
int n, sm;
int gr[MN][MN];
void sing(int x){
    FOR(i, 1, n){
        FOR(j, 1, n){
            gr[i][j] = (j-i+n)%n+1;
        }
    }
    FOR(i, 1, n){
        FOR(j, 1, n){
            if(gr[i][j] == 1) gr[i][j] = x;
            else if(gr[i][j] == x) gr[i][j] = 1;
        }
    }
}
int bruh[MN];
void doub(int x, int y){
    FOR(i, 1, n){
        FOR(j, 1, n){
            gr[i][j] = (j-i+n)%n+1;
        }
    }
    if(n % 2 == 0){
        FOR(i, 1, n){
            if(i%2 == 1) continue;
            FOR(j, 1, n){
                if(gr[i][j] == 2 || gr[i][j] == n) gr[i][j] = 2+n-gr[i][j];
            }
        }
        FOR(i, 1, n) swap(gr[n-1][i], gr[n][i]);
    } else{
        FOR(i, 1, n) swap(gr[n-1][i], gr[n][i]);
        swap(gr[n-2][1], gr[n-2][n-1]);
        swap(gr[n-1][1], gr[n-1][n-1]);
        /*int ree[4] = {1, 2, n-5, n-4};
        F0R(i, 4) FOR(j, 1, n){
            if(gr[ree[i]][j] == 4 || gr[ree[i]][j] == n){
                gr[ree[i]][j] = 4+n-gr[ree[i]][j];
            }
        }*/
        int l4 = 4, ln = n;
        int cur = 1;
        int nw;
        F0R(_, n){
            FOR(i, 1, n){
                if(i == cur) continue;
                if(gr[i][l4] == 4 || gr[i][l4] == n){
                    nw = i;
                    break;
                }
            }
            FOR(i, 1, n){
                if(i == l4) continue;
                if(gr[nw][i] == 4 || gr[nw][i] == n){
                    ln = i;
                    break;
                }
            }
            swap(l4, ln);
            gr[nw][l4] = 4; gr[nw][ln] = n;
            cur = nw;
        }
    }
    bruh[1] = x; bruh[2] = y;
    int cur = 1;
    FOR(i, 3, n){
        while(cur == x || cur == y) ++cur;
        bruh[i] = cur++;
    }
    FOR(i, 1, n){
        FOR(j, 1, n){
            gr[i][j] = bruh[gr[i][j]];
        }
    }
}
void trip(int x, int y, int z){
    FOR(i, 1, n){
        FOR(j, 1, n){
            gr[i][j] = (j-i+n)%n+1;
        }
    }
    FOR(i, 1, n) swap(gr[n-1][i], gr[n][i]);
    bruh[1] = x; bruh[2] = y; bruh[n] = z;
    int cur = 1;
    FOR(i, 3, n-1){
        while(cur == x || cur == y || cur == z) ++cur;
        bruh[i] = cur++;
    }
    //FOR(i, 1, n) cout << bruh[i] << "" "";
    //cout << ""got\n"";
    FOR(i, 1, n){
        FOR(j, 1, n){
            gr[i][j] = bruh[gr[i][j]];
        }
    }
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> tc;
    FOR(asdf, 1, tc){
        cin >> n >> sm;

        bool ok = false;

        FOR(i, 1, n){
            if(i*n == sm){
                sing(i);
                //cout << ""found!\n"";
                ok = true;
                break;
            }
            FOR(j, 1, n){
                if(i == j) continue;
                if(i*(n-2)+j*2 == sm && n != 3){
                    doub(i, j);
                    //cout << ""ok "" << i << "" "" << j << ""\n"";
                    ok = true;
                    break;
                }
                FOR(k, 1, n){
                    if(i == k || j == k) continue;
                    if(i*(n-2)+j+k == sm){
                        trip(i, j, k);
                        //cout << ""ok "" << i << "" "" << j << "" "" << k << ""\n"";
                        ok = true;
                        break;
                    }
                }
                if(ok) break;
            }
            if(ok) break;
        }
        cout << ""Case #"" << asdf << "": "";
        if(!ok){
            cout << ""IMPOSSIBLE\n"";
        } else{
            cout << ""POSSIBLE\n"";
            FOR(i, 1, n){
                FOR(j, 1, n){
                    cout << gr[i][j] << "" "";
                }
                cout << ""\n"";
            }
        }
    }
    /*n=5;
    doub(5, 3, 2);
    FOR(i, 1, n){
        FOR(j, 1, n){
            cout << gr[i][j] << "" "";
        }
        cout << ""\n"";
    }*/
    
    return 0;
}

/*
123456
612345
561234
456123
234561
345612

123456
216345
561234
452163
345612
634521

for evens: swap every other appearance of a and b, then take them in order

12345
51234
45123
23451
34512

12345
51234
24153
35412
43521

123..
.123.
2.1.3
.3.21
3..12

1234567
4123756
6412375
5671234
2567143
7345621
3756412

swap 47 on 2, 3.

123456789
912345678
891234567
789123456
678912345
567891234
256789193
345678912
934567821

so we have: a*n, a*(n-2)+b*2, a*(n-2)+b+c
*/",0000000000218bb8.CPP,000000000019fd27,0000000000218bb8,0000000000209aa0,summitwei,2020
31,0000000000218a49,"#include <bits/stdc++.h>
using namespace std;
typedef vector<int> vi;
typedef vector<pair<int, int> > vpii;
typedef pair<int, int> pii;
typedef long long ll;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;
typedef vector<ll> vll;
#define INF 0x3f3f3f3f
#define MOD 1000000007LL
#define EPSILON 0.00001
#define f first
#define s second
#define pb push_back
#define mp make_pair

#define FOR(i, a, b) for (ll i=(a); i<=(signed)(b); i++)
#define F0R(i, a) for (ll i=0; i<(signed)(a); i++)
#define RFOR(i, a, b) for (ll i=(a); i >= b; i--)

#define MN 105
int tc;
int n, sm;
int gr[MN][MN];
void sing(int x){
    FOR(i, 1, n){
        FOR(j, 1, n){
            gr[i][j] = (j-i+n)%n+1;
        }
    }
    FOR(i, 1, n){
        FOR(j, 1, n){
            if(gr[i][j] == 1) gr[i][j] = x;
            else if(gr[i][j] == x) gr[i][j] = 1;
        }
    }
}
int bruh[MN];
void doub(int x, int y){
    FOR(i, 1, n){
        FOR(j, 1, n){
            gr[i][j] = (j-i+n)%n+1;
        }
    }
    if(n % 2 == 0){
        FOR(i, 1, n){
            if(i%2 == 1) continue;
            FOR(j, 1, n){
                if(gr[i][j] == 2 || gr[i][j] == n) gr[i][j] = 2+n-gr[i][j];
            }
        }
        FOR(i, 1, n) swap(gr[n-1][i], gr[n][i]);
    } else{
        FOR(i, 1, n) swap(gr[n-1][i], gr[n][i]);
        swap(gr[n-2][1], gr[n-2][n-1]);
        swap(gr[n-1][1], gr[n-1][n-1]);
        /*int ree[4] = {1, 2, n-5, n-4};
        F0R(i, 4) FOR(j, 1, n){
            if(gr[ree[i]][j] == 4 || gr[ree[i]][j] == n){
                gr[ree[i]][j] = 4+n-gr[ree[i]][j];
            }
        }*/
        int l4 = 4, ln = n;
        int cur = 1;
        int nw;
        F0R(_, n){
            FOR(i, 1, n){
                if(i == cur) continue;
                if(gr[i][l4] == 4 || gr[i][l4] == n){
                    nw = i;
                    break;
                }
            }
            FOR(i, 1, n){
                if(i == l4) continue;
                if(gr[nw][i] == 4 || gr[nw][i] == n){
                    ln = i;
                    break;
                }
            }
            swap(l4, ln);
            gr[nw][l4] = 4; gr[nw][ln] = n;
            cur = nw;
        }
    }
    bruh[1] = x; bruh[2] = y;
    int cur = 1;
    FOR(i, 3, n){
        while(cur == x || cur == y) ++cur;
        bruh[i] = cur++;
    }
    FOR(i, 1, n){
        FOR(j, 1, n){
            gr[i][j] = bruh[gr[i][j]];
        }
    }
}
void trip(int x, int y, int z){
    FOR(i, 1, n){
        FOR(j, 1, n){
            gr[i][j] = (j-i+n)%n+1;
        }
    }
    FOR(i, 1, n) swap(gr[n-1][i], gr[n][i]);
    bruh[1] = x; bruh[2] = y; bruh[n] = z;
    int cur = 1;
    FOR(i, 3, n-1){
        while(cur == x || cur == y || cur == z) ++cur;
        bruh[i] = cur++;
    }
    FOR(i, 1, n) cout << bruh[i] << "" "";
    cout << ""got\n"";
    FOR(i, 1, n){
        FOR(j, 1, n){
            gr[i][j] = bruh[gr[i][j]];
        }
    }
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> tc;
    FOR(asdf, 1, tc){
        cin >> n >> sm;

        bool ok = false;

        FOR(i, 1, n){
            if(i*n == sm){
                sing(i);
                //cout << ""found!\n"";
                ok = true;
                break;
            }
            FOR(j, 1, n){
                if(i == j) continue;
                if(i*(n-2)+j*2 == sm && n != 3){
                    doub(i, j);
                    //cout << ""ok "" << i << "" "" << j << ""\n"";
                    ok = true;
                    break;
                }
                FOR(k, 1, n){
                    if(i == k || j == k) continue;
                    if(i*(n-2)+j+k == sm){
                        trip(i, j, k);
                        //cout << ""ok "" << i << "" "" << j << "" "" << k << ""\n"";
                        ok = true;
                        break;
                    }
                }
                if(ok) break;
            }
            if(ok) break;
        }
        cout << ""Case #"" << asdf << "": "";
        if(!ok){
            cout << ""IMPOSSIBLE\n"";
        } else{
            cout << ""POSSIBLE\n"";
            FOR(i, 1, n){
                FOR(j, 1, n){
                    cout << gr[i][j] << "" "";
                }
                cout << ""\n"";
            }
        }
    }
    /*n=5;
    doub(5, 3, 2);
    FOR(i, 1, n){
        FOR(j, 1, n){
            cout << gr[i][j] << "" "";
        }
        cout << ""\n"";
    }*/
    
    return 0;
}

/*
123456
612345
561234
456123
234561
345612

123456
216345
561234
452163
345612
634521

for evens: swap every other appearance of a and b, then take them in order

12345
51234
45123
23451
34512

12345
51234
24153
35412
43521

123..
.123.
2.1.3
.3.21
3..12

1234567
4123756
6412375
5671234
2567143
7345621
3756412

swap 47 on 2, 3.

123456789
912345678
891234567
789123456
678912345
567891234
256789193
345678912
934567821

so we have: a*n, a*(n-2)+b*2, a*(n-2)+b+c
*/",0000000000218a49.CPP,000000000019fd27,0000000000218a49,0000000000209aa0,summitwei,2020
32,0000000000213557,"#include <bits/stdc++.h>
using namespace std;
typedef vector<int> vi;
typedef vector<pair<int, int> > vpii;
typedef pair<int, int> pii;
typedef long long ll;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;
typedef vector<ll> vll;
#define INF 0x3f3f3f3f
#define MOD 1000000007LL
#define EPSILON 0.00001
#define f first
#define s second
#define pb push_back
#define mp make_pair

#define FOR(i, a, b) for (ll i=(a); i<=(signed)(b); i++)
#define F0R(i, a) for (ll i=0; i<(signed)(a); i++)
#define RFOR(i, a, b) for (ll i=(a); i >= b; i--)

#define MN 105
int tc;
int b;
int a[MN];

int que(int x){
    //cout << ""que "";
    cout << x << endl;
    cout.flush();
    int resp;
    cin >> resp;
    return resp;
}

void inv(){
    int l=1, r=b;
    while(l<r){ swap(a[l], a[r]); ++l; --r;}
}
void flip(){
    FOR(i, 1, b) a[i] = 1-a[i];
}

int main(){
    //ios_base::sync_with_stdio(false);
    //cin.tie(0);

    cin >> tc >> b;
    FOR(asdf, 1, tc){
        //cin >> b;
        int sm = -1;
        int dif = -1;
        FOR(i, 1, (b+1)/2){
            a[i] = que(i);
            a[b+1-i] = que(b+1-i);
            if(a[i] == a[b+1-i] && sm == -1) sm = i;
            if(a[i] != a[b+1-i] && dif == -1) dif = i; 

            if(i % 4 == 1 && i != 1){
                //cout << ""doing "" << sm << "" "" << dif << ""\n"";
                if(sm != -1){
                    int res = que(sm);
                    if(res != a[sm]){
                        flip();
                    }
                } else{
                    que(1);
                }
                if(dif != -1){
                    int res = que(dif);
                    if(res != a[dif]){
                        inv();
                    }
                } else{
                    que(1);
                }
            }
        }

        //cout << ""Case #"" << asdf << "": "" << s << ""\n"";
        FOR(i, 1, b) cout << a[i];
        cout << endl;
        cout.flush();
        char resp;
        cin >> resp;
        if(resp == 'N') exit(0);
    }
    
    return 0;
}
",0000000000213557.CPP,000000000019fd27,0000000000213557,0000000000209a9e,summitwei,2020
33,0000000000213084,"#include <bits/stdc++.h>
using namespace std;
typedef vector<int> vi;
typedef vector<pair<int, int> > vpii;
typedef pair<int, int> pii;
typedef long long ll;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;
typedef vector<ll> vll;
#define INF 0x3f3f3f3f
#define MOD 1000000007LL
#define EPSILON 0.00001
#define f first
#define s second
#define pb push_back
#define mp make_pair

#define FOR(i, a, b) for (ll i=(a); i<=(signed)(b); i++)
#define F0R(i, a) for (ll i=0; i<(signed)(a); i++)
#define RFOR(i, a, b) for (ll i=(a); i >= b; i--)

#define MN 105
int tc;
int b;
int a[MN];

int que(int x){
    //cout << ""que "";
    cout << x << endl;
    cout.flush();
    int resp;
    cin >> resp;
    return resp;
}

void inv(){
    int l=1, r=b;
    while(l<r){ swap(a[l], a[r]); ++l; --r;}
}
void flip(){
    FOR(i, 1, b) a[i] = 1-a[i];
}

int main(){
    //ios_base::sync_with_stdio(false);
    //cin.tie(0);

    cin >> tc;
    FOR(asdf, 1, tc){
        cin >> b;
        int sm = -1;
        int dif = -1;
        FOR(i, 1, (b+1)/2){
            a[i] = que(i);
            a[b+1-i] = que(b+1-i);
            if(a[i] == a[b+1-i] && sm == -1) sm = i;
            if(a[i] != a[b+1-i] && dif == -1) dif = i; 

            if(i % 4 == 1 && i != 1){
                //cout << ""doing "" << sm << "" "" << dif << ""\n"";
                if(sm != -1){
                    int res = que(sm);
                    if(res != a[sm]){
                        flip();
                    }
                } else{
                    que(1);
                }
                if(dif != -1){
                    int res = que(dif);
                    if(res != a[dif]){
                        inv();
                    }
                } else{
                    que(1);
                }
            }
        }

        //cout << ""Case #"" << asdf << "": "" << s << ""\n"";
        FOR(i, 1, b) cout << a[i];
        cout << endl;
        cout.flush();
        char resp;
        cin >> resp;
        if(resp == 'N') exit(0);
    }
    
    return 0;
}
",0000000000213084.CPP,000000000019fd27,0000000000213084,0000000000209a9e,summitwei,2020
34,00000000002129dd,"#include <bits/stdc++.h>
using namespace std;
typedef vector<int> vi;
typedef vector<pair<int, int> > vpii;
typedef pair<int, int> pii;
typedef long long ll;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;
typedef vector<ll> vll;
#define INF 0x3f3f3f3f
#define MOD 1000000007LL
#define EPSILON 0.00001
#define f first
#define s second
#define pb push_back
#define mp make_pair

#define FOR(i, a, b) for (ll i=(a); i<=(signed)(b); i++)
#define F0R(i, a) for (ll i=0; i<(signed)(a); i++)
#define RFOR(i, a, b) for (ll i=(a); i >= b; i--)

#define MN 105
int tc;
int b;
int a[MN];

int que(int x){
    //cout << ""que "";
    cout << x << endl;
    cout.flush();
    int resp;
    cin >> resp;
    return resp;
}

void inv(){
    int l=1, r=b;
    while(l<r){ swap(a[l], a[r]); ++l; --r;}
}
void flip(){
    FOR(i, 1, b) a[i] = 1-a[i];
}

int main(){
    //ios_base::sync_with_stdio(false);
    //cin.tie(0);

    cin >> tc;
    FOR(asdf, 1, tc){
        cin >> b;
        int sm = -1;
        int dif = -1;
        FOR(i, 1, (b+1)/2){
            a[i] = que(i);
            a[b+1-i] = que(b+1-i);
            if(a[i] == a[b+1-i] && sm == -1) sm = i;
            if(a[i] != a[b+1-i] && dif == -1) dif = i; 

            if(i % 4 == 1 && i != 1){
                //cout << ""doing "" << sm << "" "" << dif << ""\n"";
                if(sm != -1){
                    int res = que(sm);
                    if(res != a[sm]){
                        inv();
                    }
                } else{
                    que(1);
                }
                if(dif != -1){
                    int res = que(dif);
                    if(res != a[dif]){
                        flip();
                    }
                } else{
                    que(1);
                }
            }
        }

        //cout << ""Case #"" << asdf << "": "" << s << ""\n"";
        FOR(i, 1, b) cout << a[i];
        cout << endl;
        cout.flush();
        char resp;
        cin >> resp;
        if(resp == 'N') exit(0);
    }
    
    return 0;
}
",00000000002129dd.CPP,000000000019fd27,00000000002129dd,0000000000209a9e,summitwei,2020
35,0000000000211322,"#include <bits/stdc++.h>
using namespace std;
typedef vector<int> vi;
typedef vector<pair<int, int> > vpii;
typedef pair<int, int> pii;
typedef long long ll;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;
typedef vector<ll> vll;
#define INF 0x3f3f3f3f
#define MOD 1000000007LL
#define EPSILON 0.00001
#define f first
#define s second
#define pb push_back
#define mp make_pair

#define FOR(i, a, b) for (ll i=(a); i<=(signed)(b); i++)
#define F0R(i, a) for (ll i=0; i<(signed)(a); i++)
#define RFOR(i, a, b) for (ll i=(a); i >= b; i--)

#define MN 1005
int tc;
int n;
pair<pii, int> a[MN];
string s;

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> tc;
    FOR(asdf, 1, tc){
        cin >> n;
        F0R(i, n){
            cin >> a[i].f.s >> a[i].f.f;
            a[i].s = i;
        }
        sort(a, a+n);

        s.resize(n);

        int j = -1, c = -1;
        F0R(i, n){
            if(j > c && a[i].f.s >= j){
                s[a[i].s] = 'J';
                j = a[i].f.f;
            } else if(j < c && a[i].f.s >= c){
                s[a[i].s] = 'C';
                c = a[i].f.f;
            } else if(a[i].f.s >= j){
                s[a[i].s] = 'J';
                j = a[i].f.f;
            } else if(a[i].f.s >= c){
                s[a[i].s] = 'C';
                c = a[i].f.f;
            } else{
                s = ""IMPOSSIBLE"";
                break;
            }
        }

        cout << ""Case #"" << asdf << "": "" << s << ""\n"";
    }
    
    return 0;
}
",0000000000211322.CPP,000000000019fd27,0000000000211322,000000000020bdf9,summitwei,2020
36,0000000000210b67,"#include <bits/stdc++.h>
using namespace std;
typedef vector<int> vi;
typedef vector<pair<int, int> > vpii;
typedef pair<int, int> pii;
typedef long long ll;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;
typedef vector<ll> vll;
#define INF 0x3f3f3f3f
#define MOD 1000000007LL
#define EPSILON 0.00001
#define f first
#define s second
#define pb push_back
#define mp make_pair

#define FOR(i, a, b) for (ll i=(a); i<=(signed)(b); i++)
#define F0R(i, a) for (ll i=0; i<(signed)(a); i++)
#define RFOR(i, a, b) for (ll i=(a); i >= b; i--)

#define MN 105
int tc;
int n;
string s;
string t;

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> tc;
    FOR(asdf, 1, tc){
        cin >> s;
        n = s.length();
        int cd = 0;
        F0R(i, n){
            while(cd < s[i]-'0'){
                t += '(';
                ++cd;
            }
            while(cd > s[i]-'0'){
                t += ')';
                --cd;
            }
            t += s[i];
        }
        while(cd > 0){
            t += ')';
            --cd;
        }

        cout << ""Case #"" << asdf << "": "" << t << ""\n"";
        t = """";
    }
    
    return 0;
}
",0000000000210b67.CPP,000000000019fd27,0000000000210b67,0000000000209a9f,summitwei,2020
37,0000000000210b08,"#include <bits/stdc++.h>
using namespace std;
typedef vector<int> vi;
typedef vector<pair<int, int> > vpii;
typedef pair<int, int> pii;
typedef long long ll;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;
typedef vector<ll> vll;
#define INF 0x3f3f3f3f
#define MOD 1000000007LL
#define EPSILON 0.00001
#define f first
#define s second
#define pb push_back
#define mp make_pair

#define FOR(i, a, b) for (ll i=(a); i<=(signed)(b); i++)
#define F0R(i, a) for (ll i=0; i<(signed)(a); i++)
#define RFOR(i, a, b) for (ll i=(a); i >= b; i--)

#define MN 105
int t;
int n;
int gr[MN][MN];

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> t;
    FOR(asdf, 1, t){
        cin >> n;
        F0R(i, n){
            F0R(j, n){
                cin >> gr[i][j];
            }
        }
        int rcnt = 0;
        F0R(i, n){
            set<int> ree;
            F0R(j, n){
                if(ree.count(gr[i][j])){
                    ++rcnt;
                    break;
                }
                ree.insert(gr[i][j]);
            }
        }
        int ccnt = 0;
        F0R(j, n){
            set<int> ree;
            F0R(i, n){
                if(ree.count(gr[i][j])){
                    ++ccnt;
                    break;
                }
                ree.insert(gr[i][j]);
            }
        }
        int sm = 0;
        F0R(i, n) sm += gr[i][i];

        cout << ""Case #"" << asdf << "": "" << sm << "" "" << rcnt << "" "" << ccnt << ""\n"";
    }
    
    return 0;
}
",0000000000210b08.CPP,000000000019fd27,0000000000210b08,000000000020993c,summitwei,2020
38,000000000021932f,"#include <bits/stdc++.h>
using namespace std;
template<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }
template<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }
struct hopcroft{
    vector<int> dist, pair_l, pair_r;
    vector<bool> seen;
    vector<vector<int>> to;
    int n1, n2;
    hopcroft(int n1, int n2) : n1(n1), n2(n2){
        to.resize(n1);
        pair_l.assign(n1, -1);
        pair_r.assign(n2, -1);
        dist.resize(n1);
        seen.resize(n1);
    }
    void add_edge(int u, int v){
        to[u].push_back(v);
    }
    bool bfs(){
        fill(dist.begin(), dist.end(), -1);
        queue<int> q;
        for (int i = 0; i < n1; i++){
            if (pair_l[i] == -1){
                dist[i] = 0;
                q.push(i);
            }
        }
        bool reach_minus = false;
        while (!q.empty()){
            int u = q.front();
            q.pop();
            for (int adj : to[u]){
                int radj = pair_r[adj];
                if (radj == -1){
                    reach_minus = true;
                } else if (dist[radj] == -1){
                    dist[radj] = dist[u] + 1;
                    q.push(radj);
                }
            }
        }
        return reach_minus;
    }
    bool dfs(int u){
        seen[u] = true;
        for (int adj : to[u]){
            int radj = pair_r[adj];
            if (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){
                pair_l[u] = adj;
                pair_r[adj] = u;
                return true;
            }
        }
        return false;
    }
    int max_matching(){
        int res = 0;
        while (bfs()){
            fill(seen.begin(), seen.end(), false);
            for (int i = 0; i < n1; i++)
                if (pair_l[i] == -1 && dfs(i))
                    res++;
        }
        return res;
    }
};
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tt; cin >> tt;
	for(int _ = 1; _ <= tt; _++){
		cout << ""Case #"" << _ << "":"";
		int n, k; cin >> n >> k;
		k -= n;
		auto g = create<int>(n, n);
		for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) g[i][j] = 1;
		auto rg = g;
		bool found = false;
		for(int iter = 0; iter < 200; iter++){
			g = rg;
			for(int j = 0; j < k; j++){
				vector<int> pos;
				for(int z = 0; z < n; z++) if(g[z][z] < n) pos.push_back(z);
				int p = pos[rand() % pos.size()];
				g[p][p]++;
			}
			bool bad = false;
			for(int j = 0; j < n; j++){
				int take = g[j][j] - 1;
				hopcroft hop(n, n);
				for(int i = 0; i < n; i++){
					if(j == i){

					} else {
						vector<int> good(n, 1);
						good[take] = 0;
						good[g[i][i] - 1] = 0;
						for(int k = 0; k < j; k++) good[g[i][k] - 1] = 0;
						for(int k = 0; k < n; k++){
							if(good[k]){
								hop.add_edge(k, i);
							}
						}
					}
				}
				int c = hop.max_matching();
				// cout << ""ma "" << c << endl;
				if(c == n - 1){
					for(int k = 0; k < n; k++) if(k != take){
						// cout << hop.pair_l[k] << ' ' << j << ' ' << k << endl;
						g[hop.pair_l[k]][j] += k;
					}
				} else {
					bad = true;
					break;
				}
			}
			if(bad){
				continue;
			}
			found = true;
			cout << "" POSSIBLE\n"";
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					cout << g[i][j] << "" \n""[j + 1 == n];
				}
			}
			break;
		}
		if(!found) cout << "" IMPOSSIBLE\n"";
	}
	return 0;
}
",000000000021932f.CPP,000000000019fd27,000000000021932f,0000000000209aa0,FMota,2020
39,000000000021901d,"#include <bits/stdc++.h>
using namespace std;
template<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }
template<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }
struct hopcroft{
    vector<int> dist, pair_l, pair_r;
    vector<bool> seen;
    vector<vector<int>> to;
    int n1, n2;
    hopcroft(int n1, int n2) : n1(n1), n2(n2){
        to.resize(n1);
        pair_l.assign(n1, -1);
        pair_r.assign(n2, -1);
        dist.resize(n1);
        seen.resize(n1);
    }
    void add_edge(int u, int v){
        to[u].push_back(v);
    }
    bool bfs(){
        fill(dist.begin(), dist.end(), -1);
        queue<int> q;
        for (int i = 0; i < n1; i++){
            if (pair_l[i] == -1){
                dist[i] = 0;
                q.push(i);
            }
        }
        bool reach_minus = false;
        while (!q.empty()){
            int u = q.front();
            q.pop();
            for (int adj : to[u]){
                int radj = pair_r[adj];
                if (radj == -1){
                    reach_minus = true;
                } else if (dist[radj] == -1){
                    dist[radj] = dist[u] + 1;
                    q.push(radj);
                }
            }
        }
        return reach_minus;
    }
    bool dfs(int u){
        seen[u] = true;
        for (int adj : to[u]){
            int radj = pair_r[adj];
            if (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){
                pair_l[u] = adj;
                pair_r[adj] = u;
                return true;
            }
        }
        return false;
    }
    int max_matching(){
        int res = 0;
        while (bfs()){
            fill(seen.begin(), seen.end(), false);
            for (int i = 0; i < n1; i++)
                if (pair_l[i] == -1 && dfs(i))
                    res++;
        }
        return res;
    }
};
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tt; cin >> tt;
	for(int _ = 1; _ <= tt; _++){
		cout << ""Case #"" << _ << "":"";
		int n, k; cin >> n >> k;
		k -= n;
		auto g = create<int>(n, n);
		for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) g[i][j] = 1;
		auto rg = g;
		bool found = false;
		for(int iter = 0; iter < 200; iter++){
			g = rg;
			for(int j = 0; j < k; j++){
				vector<int> pos;
				for(int z = 0; z < n; z++) if(g[z][z] < n) pos.push_back(z);
				int p = pos[rand() % pos.size()];
				g[p][p]++;
			}
			bool bad = false;
			for(int j = 0; j < n; j++){
				int take = g[j][j] - 1;
				hopcroft hop(n, n);
				for(int i = 0; i < n; i++){
					if(j == i){

					} else {
						vector<int> good(n, 1);
						good[take] = 0;
						for(int k = 0; k < j; k++) good[g[i][k] - 1] = 0;
						for(int k = 0; k < n; k++){
							if(good[k]){
								hop.add_edge(k, i);
							}
						}
					}
				}
				int c = hop.max_matching();
				// cout << ""ma "" << c << endl;
				if(c == n - 1){
					for(int k = 0; k < n; k++) if(k != take){
						// cout << hop.pair_l[k] << ' ' << j << ' ' << k << endl;
						g[hop.pair_l[k]][j] += k;
					}
				} else {
					bad = true;
					break;
				}
			}
			if(bad){
				continue;
			}
			found = true;
			cout << "" POSSIBLE\n"";
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					cout << g[i][j] << "" \n""[j + 1 == n];
				}
			}
			break;
		}
		if(!found) cout << "" IMPOSSIBLE\n"";
	}
	return 0;
}
",000000000021901d.CPP,000000000019fd27,000000000021901d,0000000000209aa0,FMota,2020
40,0000000000217d3a,"#include <bits/stdc++.h>
using namespace std;
template<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }
template<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }
struct hopcroft{
    vector<int> dist, pair_l, pair_r;
    vector<bool> seen;
    vector<vector<int>> to;
    int n1, n2;
    hopcroft(int n1, int n2) : n1(n1), n2(n2){
        to.resize(n1);
        pair_l.assign(n1, -1);
        pair_r.assign(n2, -1);
        dist.resize(n1);
        seen.resize(n1);
    }
    void add_edge(int u, int v){
        to[u].push_back(v);
    }
    bool bfs(){
        fill(dist.begin(), dist.end(), -1);
        queue<int> q;
        for (int i = 0; i < n1; i++){
            if (pair_l[i] == -1){
                dist[i] = 0;
                q.push(i);
            }
        }
        bool reach_minus = false;
        while (!q.empty()){
            int u = q.front();
            q.pop();
            for (int adj : to[u]){
                int radj = pair_r[adj];
                if (radj == -1){
                    reach_minus = true;
                } else if (dist[radj] == -1){
                    dist[radj] = dist[u] + 1;
                    q.push(radj);
                }
            }
        }
        return reach_minus;
    }
    bool dfs(int u){
        seen[u] = true;
        for (int adj : to[u]){
            int radj = pair_r[adj];
            if (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){
                pair_l[u] = adj;
                pair_r[adj] = u;
                return true;
            }
        }
        return false;
    }
    int max_matching(){
        int res = 0;
        while (bfs()){
            fill(seen.begin(), seen.end(), false);
            for (int i = 0; i < n1; i++)
                if (pair_l[i] == -1 && dfs(i))
                    res++;
        }
        return res;
    }
};
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tt; cin >> tt;
	for(int _ = 1; _ <= tt; _++){
		cout << ""Case #"" << _ << "":"";
		int n, k; cin >> n >> k;
		k -= n;
		auto g = create<int>(n, n);
		for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) g[i][j] = 1;
		bool bad = false;
		for(int j = 0; j < n; j++){
			int take = min(k, n - 1);
			k -= take;
			hopcroft hop(n, n);
			for(int i = 0; i < n; i++){
				if(j == i){
					g[i][j] += take;
				} else {
					vector<int> good(n, 1);
					good[take] = 0;
					for(int k = 0; k < j; k++) good[g[i][k] - 1] = 0;
					for(int k = 0; k < n; k++){
						if(good[k]){
							hop.add_edge(k, i);
						}
					}
				}
			}
			int c = hop.max_matching();
			// cout << ""ma "" << c << endl;
			if(c == n - 1){
				for(int k = 0; k < n; k++) if(k != take){
					// cout << hop.pair_l[k] << ' ' << j << ' ' << k << endl;
					g[hop.pair_l[k]][j] += k;
				}
			} else {
				bad = true;
			}
		}
		if(bad){
			cout << "" IMPOSSIBLE\n"";
			continue;
		}
		cout << "" POSSIBLE\n"";
		for(int i = 0; i < n; i++){
			for(int j = 0; j < n; j++){
				cout << g[i][j] << "" \n""[j + 1 == n];
			}
		}
	}
	return 0;
}
",0000000000217d3a.CPP,000000000019fd27,0000000000217d3a,0000000000209aa0,FMota,2020
41,0000000000215ad8,"#include <bits/stdc++.h>
using namespace std;
template<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }
template<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t, b;
	cin >> t >> b;
	for(int _ = 0; _ < t; _++){
		string ans(b, 'x');
		vector<int> ord;
		for(int i = 1; i < b - i + 1; i++){
			ord.push_back(i);
			ord.push_back(b - i + 1);
		}
		if(b & 1) ord.push_back((b + 1) / 2);
		int ch = 1, at = 0;
		while(true){
			if(count(ans.begin(), ans.end(), 'x') == 0){
				cout << ans << endl;
				char c;
				cin >> c;
				if(c == 'N') return 0;
				break;
			}
			if(ch > 10 && (ch%10) == 1){
				for(int i = 1; i < b - i + 1; i++){
					if(ans[i - 1] == 'x' && ans[b - i] != 'x'){
						at--;
						ans[b - i] = 'x';
						continue;
					}
					if(ans[i - 1] != 'x' && ans[b - i] == 'x'){
						at--;
						ans[i - 1] = 'x';
						continue;
					}
				}
				for(int i = 0; i < b; i++){
					if(ans[i] == 'x'){
						int j = at;
						for(; j < ord.size(); j++) if(ord[j] == i + 1) break;
						assert(j < ord.size());
					}
				}
				int l = -1, r = -1;
				int p = -1, q = -1;
				for(int i = 0; i < b - i - 1; i++){
					int j = b - i - 1;
					if(ans[i] != 'x' && ans[j] != 'x'){
						if(ans[i] == ans[j]){
							l = i;
							r = j;
						}
						if(ans[i] != ans[j]){
							p = i;
							q = j;
						}
					}
				}
				bool swp = false, flip = false;
				if(l != -1){
					ch++;
					cout << l + 1 << endl;
					char op;
					cin >> op;
					if(op != ans[l]) flip = true;
				}
				if(flip){
					for(int i = 0; i < b; i++) if(ans[i] != 'x'){
						ans[i] = ans[i] == '0' ? '1' : '0';
					}
				}
				if(p != -1){
					ch++;
					cout << p + 1 << endl;
					char op;
					cin >> op;
					if(op != ans[p]) swp = true;
				}
				if(swp){
					for(int i = 1; i < b - i + 1; i++){
						swap(ans[i - 1], ans[b - i]);
					}
				}
				continue;
			}
			ch++;
			cout << ord[at] << endl;
			cin >> ans[ord[at] - 1];
			at++;
		}
	}
	return 0;
}
",0000000000215ad8.CPP,000000000019fd27,0000000000215ad8,0000000000209a9e,FMota,2020
42,00000000002114ad,"#include <bits/stdc++.h>
using namespace std;
template<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }
template<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tt; cin >> tt;
	for(int _ = 1; _ <= tt; _++){
		cout << ""Case #"" << _ << "":"";
		vector<tuple<int,int,int>> p;
		int n; cin >> n;
		for(int i = 0; i < n; i++){
			int l, r;
			cin >> l >> r;
			p.push_back(make_tuple(r, l, i));
		}
		sort(p.begin(), p.end());
		auto can = [&](int x, int y){
			return get<1>(p[y]) >= get<0>(p[x]);
		};
		auto vis = create<int>(n + 1, n + 1);
		string ans(n, '0');
		function<bool(int,int)> dfs = [&](int x, int y){
			if(vis[x][y]) return false;
			int put = max(x, y);
			if(put == n) return true;
			if(x == 0 || can(x - 1, put)){
				if(dfs(put + 1, y)){
					ans[get<2>(p[put])] = 'C';
					return true;
				}
			}
			if(y == 0 || can(y - 1, put)){
				if(dfs(x, put + 1)){
					ans[get<2>(p[put])] = 'J';
					return true;
				}
			}
			vis[x][y] = 1;
			return false;
		};
		if(dfs(0, 0)) cout << ' ' << ans << '\n';
		else cout << "" IMPOSSIBLE\n"";
	}
	return 0;
}
",00000000002114ad.CPP,000000000019fd27,00000000002114ad,000000000020bdf9,FMota,2020
43,00000000002113bf,"#include <bits/stdc++.h>
using namespace std;
template<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }
template<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tt; cin >> tt;
	for(int _ = 1; _ <= tt; _++){
		cout << ""Case #"" << _ << "":"";
		vector<tuple<int,int,int>> p;
		int n; cin >> n;
		for(int i = 0; i < n; i++){
			int l, r;
			cin >> l >> r;
			p.push_back(make_tuple(r, l, i));
		}
		sort(p.begin(), p.end());
		auto can = [&](int x, int y){
			return get<1>(p[y]) >= get<0>(p[x]);
		};
		auto vis = create<int>(n + 1, n + 1);
		string ans(n, '0');
		function<bool(int,int)> dfs = [&](int x, int y){
			if(vis[x][y]) return false;
			int put = max(x, y);
			if(put == n) return true;
			if(x == 0 || can(x - 1, put)){
				if(dfs(put + 1, y)){
					ans[get<2>(p[put])] = 'C';
					return true;
				}
			}
			if(y == 0 || can(y - 1, put)){
				if(dfs(x, put + 1)){
					ans[get<2>(p[put])] = 'J';
					return true;
				}
			}
			vis[x][y] = 1;
			return false;
		};
		if(dfs(0, 0)) cout << ' ' << ans << '\n';
		else cout << ""IMPOSSIBLE\n"";
	}
	return 0;
}
",00000000002113bf.CPP,000000000019fd27,00000000002113bf,000000000020bdf9,FMota,2020
44,0000000000210cd1,"#include <bits/stdc++.h>
using namespace std;
template<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }
template<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tt; cin >> tt;
	for(int _ = 1; _ <= tt; _++){
		cout << ""Case #"" << _ << "":"";
		string s, r; cin >> s;
		int d = 0;
		for(auto c : s){
			int p = c - '0';
			while(d < p) r.push_back('('), d++;
			while(d > p) r.push_back(')'), d--;
			r.push_back(c);
		}
		while(d > 0) r.push_back(')'), d--;
		cout << ' ' << r << '\n';
	}
	return 0;
}
",0000000000210cd1.CPP,000000000019fd27,0000000000210cd1,0000000000209a9f,FMota,2020
45,0000000000210b86,"#include <bits/stdc++.h>
using namespace std;
template<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }
template<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int tt; cin >> tt;
	for(int _ = 1; _ <= tt; _++){
		cout << ""Case #"" << _ << "":"";
		int n; cin >> n;
		auto g = create<int>(n, n);
		for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) cin >> g[i][j];
		int ans = 0;
		for(int i = 0; i < n; i++) ans += g[i][i];
		int r = 0, c = 0;
		for(int i = 0; i < n; i++){
			set<int> sr, sc;
			bool rr = false, cc = false;
			for(int j = 0; j < n; j++){
				if(sr.count(g[i][j])) rr = true;
				if(sc.count(g[j][i])) cc = true;
				sr.insert(g[i][j]);
				sc.insert(g[j][i]);
			}
			if(rr) r++;
			if(cc) c++;
		}
		cout << ' ' << ans << ' ' << r << ' ' << c << '\n';
	}
	return 0;
}
",0000000000210b86.CPP,000000000019fd27,0000000000210b86,000000000020993c,FMota,2020
46,000000000021aba4,"/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Egor Kulikov
 */







#include <bits/stdc++.h>

using namespace std;

// BEGIN CUT HERE
template <typename T>
class Vector : public vector<T> {
    using parent = vector<T>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const T& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<T> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    const T& operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    T& operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<T>& operator=(Vector<T>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<T>& operator=(const Vector<T>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

template <>
class Vector<bool> : public vector<bool> {
    using parent = vector<bool>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<bool> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    parent::const_reference operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    parent::reference operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<bool>& operator=(const Vector<bool>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

#ifdef LOCAL
#define vec Vector
#else
// END CUT HERE
#define vec vector
// BEGIN CUT HERE
#endif
// END CUT HERE

using vi = vec<int>;


#define all(v) (v).begin(), (v).end()

using ll = long long;
using ld = long double;
using pii = pair<int, int>;

void doReplace() {
}

template <typename T, typename U, typename...Vs>
void doReplace(T& t, const U& u, Vs&& ...vs) {
    t = u;
    doReplace(vs...);
}

template <typename T, typename...Us>
T minim(T& was, const T& cand, Us&& ...us) {
    if (was > cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}

template <typename T, typename...Us>
T maxim(T& was, const T& cand, Us&& ...us) {
    if (was < cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}


template <typename D>
D dPower(D base, ll exponent) {
    if (exponent < 0) {
        return dPower(1 / base, -exponent);
    }
    if (exponent == 0) {
        return 1;
    }
    if ((exponent & 1) == 1) {
        return dPower(base, exponent - 1) * base;
    } else {
        D res = dPower(base, exponent >> 1);
        return res * res;
    }
}


class NumberIterator : iterator<forward_iterator_tag, int> {
public:
    int v;

    NumberIterator(int v) : v(v) {}

    operator int&() { return v; }

    int operator*() { return v; }
};

class range : pii {
public:
    range(int begin, int end) : pii(begin, max(begin, end)) {}

    range(int n) : pii(0, max(0, n)) {}

    NumberIterator begin() {
        return first;
    }

    NumberIterator end() {
        return second;
    }
};


template <typename T>
class arr {
    T* b;
    int n;

    void allocate(int sz) {
#ifdef LOCAL
        if (sz < 0) {
            throw ""bad alloc"";
        }
#endif
        n = sz;
        if (sz > 0) {
            b = (T*) (::operator new(sz * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr(int n = 0) {
        allocate(n);
#ifdef LOCAL
        view();
#endif
    }

    arr(int n, const T& init) {
        allocate(n);
        for (int i : range(n)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(initializer_list<T> l) {
        allocate(n);
        if (n > 0) {
            memcpy(b, l.begin(), n * sizeof(T));
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(T* b, int n) : arr(b, b + n) {}

    arr(T* b, T* e) : b(b), n(e - b) {}

    int size() const {
        return n;
    }

    T* begin() {
        return b;
    }

    const T* begin() const {
        return b;
    }

    T* end() {
        return b + n;
    }

    const T* end() const {
        return b + n;
    }

    arr<T> clone() const {
        arr<T> res(n);
        copy(b, b + n, res.begin());
        return res;
    }

    T& operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    const T& operator[](int at) const {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    bool operator==(const arr& other) const {
        if (n != other.n) {
            return false;
        }
        for (int i : range(n)) {
            if (b[i] != other.b[i]) {
                return false;
            }
        }
        return true;
    }

    vector<T> view() {
        return vector<T>(b, b + min(n, 50));
    }
};

typedef arr<int> arri;

void decreaseByOne() {}

template <typename T, class...Vs>
void decreaseByOne(arr<T>& array, Vs& ...vs) {
    int n = array.size();
    for (int i = 0; i < n; ++i) {
        array[i]--;
    }
    decreaseByOne(vs...);
}

template <typename T, typename U>
void decreaseByOne(arr<pair<T, U>>& v) {
    for (auto& p : v) {
        p.first--;
        p.second--;
    }
}


template <typename T>
class arr2d {
    T* b;
    int d1;
    int d2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
#ifdef LOCAL
        view();
#endif
    }

    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    const T& operator()(int i1, int i2) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    arr<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr<T>(b + at * d2, d2);
    }

    vector<vector<T>> view() {
        vector<vector<T>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }

    arr2d<T> clone() {
        arr2d<T> res(d1, d2);
        copy(b, b + sz, res.b);
        return res;
    }
};

template <typename T>
class arr3d {
    T* b;
    int d1;
    int d2;
    int d3;
    int shift;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    const T& operator()(int i1, int i2, int i3) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    arr2d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr2d<T>(b + at * shift, d2, d3);
    }

    vector<vector<vector<T>>> view() {
        vector<vector<vector<T>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};

template <typename T>
class arr4d {
    T* b;
    int d1;
    int d2;
    int d3;
    int d4;
    int shift1;
    int shift2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
    }

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    int dim4() const {
        return d4;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3, int i4) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    const T& operator()(int i1, int i2, int i3, int i4) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    arr3d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr3d<T>(b + at * shift1, d2, d3, d4);
    }

    vector<vector<vector<vector<T>>>> view() {
        vector<vector<vector<vector<T>>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};


inline bool isWhitespace(int c) {
    return isspace(c) || c == EOF;
}

class Input {
private:
    bool exhausted = false;
    int bufSize = 4096;
    char* buf = new char[bufSize];
    int bufRead = 0;
    int bufAt = 0;

    inline int get() {
        if (exhausted) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return EOF;
        }
        if (bufRead == bufAt) {
            bufRead = fread(buf, sizeof(char), bufSize, stdin);
            bufAt = 0;
        }
        if (bufRead == bufAt) {
            exhausted = true;
            return EOF;
        }
        return buf[bufAt++];
    }

    template <typename T>
    inline T readInteger() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        T res = 0;
        do {
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c));
        return res * sgn;
    }

    void initArrays(int) {}

    template <typename T, class...Vs>
    void initArrays(int n, arr<T>& array, Vs& ...vs) {
        array = arr<T>(n);
        initArrays(n, vs...);
    }

    template <typename T, class...Vs>
    void initArrays(int n, vec<T>&, Vs& ...vs) {
        initArrays(n, vs...);
    }

    void readImpl(int) {}

    template <typename T, class...Vs>
    void readImpl(int i, arr<T>& arr, Vs& ...vs) {
        arr[i] = readType<T>();
        readImpl(i, vs...);
    }

    template <typename T, class...Vs>
    void readImpl(int i, vec<T>& arr, Vs& ...vs) {
        arr.push_back(readType<T>());
        readImpl(i, vs...);
    }

public:
    inline int skipWhitespace() {
        int c;
        while (isWhitespace(c = get()) && c != EOF);
        if (c == EOF) {
            exhausted = true;
        }
        return c;
    }

    inline int readInt() {
        return readInteger<int>();
    }

    ll readLong() {
        return readInteger<ll>();
    }

    string readString() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
        } while (!isWhitespace(c = get()));
        return string(all(res));
    }

    arri readIntArray(int size) {
        return readArray<int>(size);
    }

    arr<ll> readLongArray(int size) {
        return readArray<ll>(size);
    }

    arr<double> readDoubleArray(int size) {
        return readArray<double>(size);
    }

    arr<string> readStringArray(int size) {
        return readArray<string>(size);
    }

    arr<char> readCharArray(int size) {
        return readArray<char>(size);
    }

    template <typename T>
    T readType() {
        throw ""Operation not supported"";
    }

    template <typename U, typename V>
    pair<U, V> readType() {
        U first = readType<U>();
        V second = readType<V>();
        return make_pair(first, second);
    }

    template <typename T>
    arr<T> readArray(int n) {
        arr<T> res(n, T());
        for (int i = 0; i < n; i++) {
            res[i] = readType<T>();
        }
        return res;
    }


    template <class...Vs>
    void readArrays(int n, Vs& ...vs) {
        initArrays(n, vs...);
        for (int i = 0; i < n; i++) {
            readImpl(i, vs...);
        }
    }

    template <typename U, typename V>
    arr<pair<U, V>> readArray(int n) {
        arr<pair<U, V>> res(n);
        for (int i = 0; i < n; i++) {
            res[i] = readType<U, V>();
        }
        return res;
    }

    template <typename T>
    arr2d<T> readTable(int rows, int cols) {
        arr2d<T> result(rows, cols);
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                result(i, j) = readType<T>();
            }
        }
        return result;
    }

    arr2d<int> readIntTable(int rows, int cols) {
        return readTable<int>(rows, cols);
    }

    arr2d<char> readCharTable(int rows, int cols) {
        return readTable<char>(rows, cols);
    }

    string readLine() {
        int c = get();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
            c = get();
        } while (c != '\n' && c != '\r' && c != EOF);
        return string(all(res));
    }

    double readDouble() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        double res = 0;
        do {
            if (tolower(c) == 'e') {
                return sgn * res * dPower(double(10), readInt());
            }
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c) && c != '.');
        if (c == '.') {
            double add = 0;
            int length = 0;
            c = get();
            do {
                if (tolower(c) == 'e') {
                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());
                }
                if (!isdigit(c)) {
#ifdef LOCAL
                    throw ""Number format error"";
#endif
                    res += add * dPower(10, -length);
                    return res * sgn;
                }
                add *= 10;
                add += c - '0';
                length++;
                c = get();
            } while (!isWhitespace(c));
            res += add * dPower(double(10), -length);
        }
        return res * sgn;
    }

    char readChar() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return 0;
        }
        return c;
    }

    bool isExhausted() { return exhausted; }

    void setBufSize(int newBufSize) {
        if (newBufSize > bufSize) {
            char* newBuf = new char[newBufSize];
            memcpy(newBuf, buf, bufSize);
            buf = newBuf;
        }
        bufSize = newBufSize;
    }
};

template <>
double Input::readType() {
    return readDouble();
}

template <>
int Input::readType() {
    return readInt();
}

template <>
ll Input::readType() {
    return readLong();
}

template <>
char Input::readType() {
    return readChar();
}

template <>
string Input::readType() {
    return readString();
}

Input in;


class Output {
private:
    ostream& out = cout;

    template <typename T>
    void printSingle(const T& value) {
        out << value;
    }

    template <typename T>
    void printSingle(const vec<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr2d<T>& array) {
        size_t n = array.dim1();
        size_t m = array.dim2();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                out << array(i, j);
                if (j + 1 != m) {
                    out << ' ';
                }
            }
            if (i + 1 != n) {
                out << '\n';
            }
        }
    }

    template <typename T, typename U>
    void printSingle(const pair<T, U>& value) {
        out << value.first << ' ' << value.second;
    }

public:
    Output() {//ostream& out) : out(out) {
        out << fixed << setprecision(20);
    }

    void print() {}

    template <typename T, typename...Targs>
    void print(const T& first, const Targs... args) {
        printSingle(first);
        if (sizeof...(args) != 0) {
            out << ' ';
            print(args...);
        }
    }

    template <typename...Targs>
    void printLine(const Targs... args) {
        print(args...);
        out << '\n';
    }

    void flush() {
        out.flush();
    }
};

Output out;


class ReverseNumberIterator : public NumberIterator {
public:
    ReverseNumberIterator(int v) : NumberIterator(v) {}

    ReverseNumberIterator& operator++() {
        --v;
        return *this;
    }
};

class RevRange : pii {
public:
    RevRange(int begin, int end) : pii(begin - 1, min(begin, end) - 1) {}

    RevRange(int n) : pii(n - 1, min(n, 0) - 1) {}

    ReverseNumberIterator begin() {
        return first;
    }

    ReverseNumberIterator end() {
        return second;
    }
};


template <typename T>
inline void unique(vec<T>& v) {
    v.resize(unique(all(v)) - v.begin());
}

arri createOrder(int n) {
    arri order(n);
    for (int i = 0; i < n; i++) {
        order[i] = i;
    }
    return order;
}

arri inverse(const arri& p) {
    arri res(p.size());
    for (int i : range(p.size())) {
        res[p[i]] = i;
    }
    return res;
}

template <typename T, typename Iterator>
inline void addAll(vec<T>& v, Iterator begin, Iterator end) {
    v.insert(v.end(), begin, end);
}

template <class Collection, typename Iterator>
inline void addAll(Collection& v, Iterator begin, Iterator end) {
    v.insert(begin, end);
}

template <typename Iterator>
arri getQty(Iterator begin, Iterator end, int length) {
    arri res(length, 0);
    for (Iterator it = begin; it != end; it++) {
        res[*it]++;
    }
    return res;
}

template <typename Iterator>
arri getQty(Iterator begin, Iterator end) {
    return getQty(begin, end, *max_element(begin, end) + 1);
}

template <class Collection>
void collect(Collection&) {}

template <class Collection, class Other, class ...Vs>
void collect(Collection& all, Other& a, Vs& ...vs) {
    addAll(all, all(a));
    collect(all, vs...);
}

void replace(const vi&) {}

template <class ...Vs>
void replace(const vi& all, vi& a, Vs& ...vs) {
    for (int& i : a) {
        i = lower_bound(all(all), i) - all.begin();
    }
    replace(all, vs...);
}

template <class ...Vs>
void replace(const vi& all, arri& a, Vs& ...vs) {
    for (int& i : a) {
        i = lower_bound(all(all), i) - all.begin();
    }
    replace(all, vs...);
}

template <class ...Vs>
vi compress(Vs& ...vs) {
    vi vals;
    collect(vals, vs...);
    sort(all(vals));
    unique(vals);
    replace(vals, vs...);
    return vals;
}


template <typename W, typename C>
class WeightedFlowEdge {
private:
    WeightedFlowEdge<W, C>* reverseEdge;

public:
    const int from;
    const int to;
    W weight;
    C capacity;
    int id;

    WeightedFlowEdge(int from, int to, W weight, C capacity) : from(from), to(to), weight(weight), capacity(capacity) {
        reverseEdge = new WeightedFlowEdge(this);
    }

    WeightedFlowEdge<W, C>* transposed() { return nullptr; }

    WeightedFlowEdge<W, C>* reverse() { return reverseEdge; }

    void push(C flow) {
        capacity -= flow;
        reverseEdge->capacity += flow;
    }

    C flow() const {
        return reverseEdge->capacity;
    }

private:
    WeightedFlowEdge(WeightedFlowEdge<W, C>* reverse) : from(reverse->to), to(reverse->from), weight(-reverse->weight),
                                                        capacity(0) {
        reverseEdge = reverse;
    }
};

template <typename C>
class FlowEdge {
private:
    FlowEdge<C>* reverseEdge;

public:
    const int from;
    const int to;
    C capacity;
    int id;

    FlowEdge(int from, int to, C capacity) : from(from), to(to), capacity(capacity) {
        reverseEdge = new FlowEdge(this);
    }

    FlowEdge<C>* transposed() { return nullptr; }

    FlowEdge<C>* reverse() { return reverseEdge; }

    void push(C flow) {
        capacity -= flow;
        reverseEdge->capacity += flow;
    }

    C flow() const {
        return reverseEdge->capacity;
    }

private:
    FlowEdge(FlowEdge<C>* reverse) : from(reverse->to), to(reverse->from), capacity(0) {
        reverseEdge = reverse;
    }
};

template <typename W>
class WeightedEdge {
public:
    const int from;
    const int to;
    W weight;
    int id;

    WeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {
    }

    WeightedEdge<W>* transposed() { return nullptr; }

    WeightedEdge<W>* reverse() { return nullptr; }
};

template <typename W>
class BiWeightedEdge {
private:
    BiWeightedEdge<W>* transposedEdge;

public:
    const int from;
    const int to;
    W weight;
    int id;

    BiWeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {
        transposedEdge = new BiWeightedEdge(this);
    }

    BiWeightedEdge<W>* transposed() { return transposedEdge; }

    BiWeightedEdge<W>* reverse() { return nullptr; }

private:
    BiWeightedEdge(BiWeightedEdge<W>* transposed) : from(transposed->to), to(transposed->from),
                                                    weight(transposed->weight) {
        transposedEdge = transposed;
    }
};

class BaseEdge {
public:
    const int from;
    const int to;
    int id;

    BaseEdge(int from, int to) : from(from), to(to) {
    }

    BaseEdge* transposed() { return nullptr; }

    BaseEdge* reverse() { return nullptr; }
};

class BiEdge {
private:
    BiEdge* transposedEdge;

public:
    const int from;
    const int to;
    int id;

    BiEdge(int from, int to) : from(from), to(to) {
        transposedEdge = new BiEdge(this);
    }

    BiEdge* transposed() { return transposedEdge; }

    BiEdge* reverse() { return nullptr; }

private:
    BiEdge(BiEdge* transposed) : from(transposed->to), to(transposed->from) {
        transposedEdge = transposed;
    }
};

template <class Edge>
class Graph {
public:
    int vertexCount;
    int edgeCount = 0;
private:
    vec<vec<Edge*>> edges;

public:
    Graph(int vertexCount) : vertexCount(vertexCount), edges(vertexCount, vec<Edge*>()) {}

    void addEdge(Edge* edge) {
#ifdef LOCAL
        if (edge->from < 0 || edge->to < 0 || edge->from >= vertexCount || edge->to >= vertexCount) {
            throw ""Out of bounds"";
        }
#endif
        edge->id = edgeCount;
        edges[edge->from].push_back(edge);
        Edge* reverse = edge->reverse();
        if (reverse != nullptr) {
            reverse->id = edgeCount;
            edges[reverse->from].push_back(reverse);
        }
        Edge* transposed = edge->transposed();
        if (transposed != nullptr) {
            edges[transposed->from].push_back(transposed);
            transposed->id = edgeCount;
            Edge* transRev = transposed->reverse();
            if (transRev != nullptr) {
                edges[transRev->from].push_back(transRev);
                transRev->id = edgeCount;
            }
        }
        edgeCount++;
    }

    template <typename...Ts>
    void addEdge(Ts...args) {
        addEdge(new Edge(args...));
    }

    vec<Edge*>& operator[](int at) {
        return edges[at];
    }

    void addVertices(int count) {
        vertexCount += count;
        edges.resize(vertexCount);
    }
};


template <class Edge, typename C>
C maxFlow(Graph<Edge>& graph, int source, int destination) {
    arri dist(graph.vertexCount);
    arri nextEdge(graph.vertexCount);
    C inf = numeric_limits<C>::max();
    C totalFlow = 0;
    queue<int> q;
    auto edgeDistances = [&]() {
        fill(all(dist), -1);
        dist[source] = 0;
        q.push(source);
        while (!q.empty()) {
            int current = q.front();
            q.pop();
            for (auto edge : graph[current]) {
                if (edge->capacity != 0) {
                    int next = edge->to;
                    if (dist[next] == -1) {
                        dist[next] = dist[current] + 1;
                        q.push(next);
                    }
                }
            }
        }
    };
    function<C(int, C)> dinicImpl = [&](int source, C flow) {
        if (source == destination) {
            return flow;
        }
        if (flow == 0 || dist[source] == dist[destination]) {
            return 0;
        }
        C totalPushed = 0;
        while (nextEdge[source] < graph[source].size()) {
            auto edge = graph[source][nextEdge[source]];
            if (edge->capacity != 0 && dist[edge->to] == dist[source] + 1) {
                C pushed = dinicImpl(edge->to, min(flow, edge->capacity));
                if (pushed != 0) {
                    edge->push(pushed);
                    flow -= pushed;
                    totalPushed += pushed;
                    if (flow == 0) {
                        return totalPushed;
                    }
                }
            }
            nextEdge[source]++;
        }
        return totalPushed;
    };

    while (true) {
        edgeDistances();
        if (dist[destination] == -1) {
            break;
        }
        fill(nextEdge.begin(), nextEdge.end(), 0);
        totalFlow += dinicImpl(source, inf);
    }
    return totalFlow;
}


int id = 1;

class Indicium {
public:
    arr2d<int> solve(int n, int k) {
        arr2d<int> answer(n, n, -1);
        int rem = k;
        for (int i : RevRange(n)) {
            answer(i, i) = min(rem - i, n);
            rem -= answer(i, i);
        }
        if (answer(n - 2, n - 2) == 1 && answer(n - 1, n - 1) != 1) {
            answer(n - 2, n - 2)++;
            answer(n - 1, n - 1)--;
        }
        if (answer(1, 1) == n && answer(0, 0) != n) {
            answer(1, 1)--;
            answer(0, 0)++;
        }
        arri q(n, 0);
        for (int i : range(n)) {
            q[answer(i, i) - 1]++;
        }
        auto order = createOrder(n);
        sort(all(order), [&](int x, int y) -> bool {
            return q[y] < q[x];
        });
        for (int i : order) {
            Graph<FlowEdge<int>> graph(2 * n + 2);
            int source = 2 * n;
            int sink = source + 1;
            for (int j : range(n)) {
                if (answer(j, j) != i + 1) {
                    graph.addEdge(source, j, 1);
                    graph.addEdge(n + j, sink, 1);
                }
                for (int k : range(n)) {
                    if (answer(j, k) == -1) {
                        graph.addEdge(j, n + k, 1);
                    }
                }
            }
            if (maxFlow<FlowEdge<int>, int>(graph, source, sink) != n - q[i]) {
                throw ""Jopa"";
            }
            for (int j : range(n)) {
                for (auto* e : graph[j]) {
                    if (e->to >= n && e->flow()) {
                        answer(j, e->to - n) = i + 1;
                        break;
                    }
                }
            }
        }
        return answer;
    }

    void solve() {
        int n = in.readInt();
        int k = in.readInt();

        if (k == n + 1 || k == n * n - 1 || n == 3 && k == 5 || n == 3 && k == 7) {
            out.printLine(""Case #"" + to_string(id++) + "": IMPOSSIBLE"");
            return;
        }
        auto answer = solve(n, k);
        out.printLine(""Case #"" + to_string(id++) + "": POSSIBLE"");
        out.printLine(answer);
    }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    Indicium solver;


    int n;
    scanf(""%d"", &n);
    for (int i = 0; i < n; ++i) {
        solver.solve();
    }

    fflush(stdout);
    return 0;
}
",000000000021aba4.CPP,000000000019fd27,000000000021aba4,0000000000209aa0,Egor,2020
47,0000000000219983,"/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Egor Kulikov
 */







#include <bits/stdc++.h>

using namespace std;

// BEGIN CUT HERE
template <typename T>
class Vector : public vector<T> {
    using parent = vector<T>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const T& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<T> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    const T& operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    T& operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<T>& operator=(Vector<T>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<T>& operator=(const Vector<T>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

template <>
class Vector<bool> : public vector<bool> {
    using parent = vector<bool>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<bool> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    parent::const_reference operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    parent::reference operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<bool>& operator=(const Vector<bool>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

#ifdef LOCAL
#define vec Vector
#else
// END CUT HERE
#define vec vector
// BEGIN CUT HERE
#endif
// END CUT HERE

using vi = vec<int>;


#define all(v) (v).begin(), (v).end()

using ll = long long;
using ld = long double;
using pii = pair<int, int>;

void doReplace() {
}

template <typename T, typename U, typename...Vs>
void doReplace(T& t, const U& u, Vs&& ...vs) {
    t = u;
    doReplace(vs...);
}

template <typename T, typename...Us>
T minim(T& was, const T& cand, Us&& ...us) {
    if (was > cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}

template <typename T, typename...Us>
T maxim(T& was, const T& cand, Us&& ...us) {
    if (was < cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}


template <typename D>
D dPower(D base, ll exponent) {
    if (exponent < 0) {
        return dPower(1 / base, -exponent);
    }
    if (exponent == 0) {
        return 1;
    }
    if ((exponent & 1) == 1) {
        return dPower(base, exponent - 1) * base;
    } else {
        D res = dPower(base, exponent >> 1);
        return res * res;
    }
}


class NumberIterator : iterator<forward_iterator_tag, int> {
public:
    int v;

    NumberIterator(int v) : v(v) {}

    operator int&() { return v; }

    int operator*() { return v; }
};

class range : pii {
public:
    range(int begin, int end) : pii(begin, max(begin, end)) {}

    range(int n) : pii(0, max(0, n)) {}

    NumberIterator begin() {
        return first;
    }

    NumberIterator end() {
        return second;
    }
};


template <typename T>
class arr {
    T* b;
    int n;

    void allocate(int sz) {
#ifdef LOCAL
        if (sz < 0) {
            throw ""bad alloc"";
        }
#endif
        n = sz;
        if (sz > 0) {
            b = (T*) (::operator new(sz * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr(int n = 0) {
        allocate(n);
#ifdef LOCAL
        view();
#endif
    }

    arr(int n, const T& init) {
        allocate(n);
        for (int i : range(n)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(initializer_list<T> l) {
        allocate(n);
        if (n > 0) {
            memcpy(b, l.begin(), n * sizeof(T));
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(T* b, int n) : arr(b, b + n) {}

    arr(T* b, T* e) : b(b), n(e - b) {}

    int size() const {
        return n;
    }

    T* begin() {
        return b;
    }

    const T* begin() const {
        return b;
    }

    T* end() {
        return b + n;
    }

    const T* end() const {
        return b + n;
    }

    arr<T> clone() const {
        arr<T> res(n);
        copy(b, b + n, res.begin());
        return res;
    }

    T& operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    const T& operator[](int at) const {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    bool operator==(const arr& other) const {
        if (n != other.n) {
            return false;
        }
        for (int i : range(n)) {
            if (b[i] != other.b[i]) {
                return false;
            }
        }
        return true;
    }

    vector<T> view() {
        return vector<T>(b, b + min(n, 50));
    }
};

typedef arr<int> arri;

void decreaseByOne() {}

template <typename T, class...Vs>
void decreaseByOne(arr<T>& array, Vs& ...vs) {
    int n = array.size();
    for (int i = 0; i < n; ++i) {
        array[i]--;
    }
    decreaseByOne(vs...);
}

template <typename T, typename U>
void decreaseByOne(arr<pair<T, U>>& v) {
    for (auto& p : v) {
        p.first--;
        p.second--;
    }
}


template <typename T>
class arr2d {
    T* b;
    int d1;
    int d2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
#ifdef LOCAL
        view();
#endif
    }

    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    const T& operator()(int i1, int i2) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    arr<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr<T>(b + at * d2, d2);
    }

    vector<vector<T>> view() {
        vector<vector<T>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }

    arr2d<T> clone() {
        arr2d<T> res(d1, d2);
        copy(b, b + sz, res.b);
        return res;
    }
};

template <typename T>
class arr3d {
    T* b;
    int d1;
    int d2;
    int d3;
    int shift;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    const T& operator()(int i1, int i2, int i3) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    arr2d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr2d<T>(b + at * shift, d2, d3);
    }

    vector<vector<vector<T>>> view() {
        vector<vector<vector<T>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};

template <typename T>
class arr4d {
    T* b;
    int d1;
    int d2;
    int d3;
    int d4;
    int shift1;
    int shift2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
    }

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    int dim4() const {
        return d4;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3, int i4) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    const T& operator()(int i1, int i2, int i3, int i4) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    arr3d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr3d<T>(b + at * shift1, d2, d3, d4);
    }

    vector<vector<vector<vector<T>>>> view() {
        vector<vector<vector<vector<T>>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};


inline bool isWhitespace(int c) {
    return isspace(c) || c == EOF;
}

class Input {
private:
    bool exhausted = false;
    int bufSize = 4096;
    char* buf = new char[bufSize];
    int bufRead = 0;
    int bufAt = 0;

    inline int get() {
        if (exhausted) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return EOF;
        }
        if (bufRead == bufAt) {
            bufRead = fread(buf, sizeof(char), bufSize, stdin);
            bufAt = 0;
        }
        if (bufRead == bufAt) {
            exhausted = true;
            return EOF;
        }
        return buf[bufAt++];
    }

    template <typename T>
    inline T readInteger() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        T res = 0;
        do {
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c));
        return res * sgn;
    }

    void initArrays(int) {}

    template <typename T, class...Vs>
    void initArrays(int n, arr<T>& array, Vs& ...vs) {
        array = arr<T>(n);
        initArrays(n, vs...);
    }

    template <typename T, class...Vs>
    void initArrays(int n, vec<T>&, Vs& ...vs) {
        initArrays(n, vs...);
    }

    void readImpl(int) {}

    template <typename T, class...Vs>
    void readImpl(int i, arr<T>& arr, Vs& ...vs) {
        arr[i] = readType<T>();
        readImpl(i, vs...);
    }

    template <typename T, class...Vs>
    void readImpl(int i, vec<T>& arr, Vs& ...vs) {
        arr.push_back(readType<T>());
        readImpl(i, vs...);
    }

public:
    inline int skipWhitespace() {
        int c;
        while (isWhitespace(c = get()) && c != EOF);
        if (c == EOF) {
            exhausted = true;
        }
        return c;
    }

    inline int readInt() {
        return readInteger<int>();
    }

    ll readLong() {
        return readInteger<ll>();
    }

    string readString() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
        } while (!isWhitespace(c = get()));
        return string(all(res));
    }

    arri readIntArray(int size) {
        return readArray<int>(size);
    }

    arr<ll> readLongArray(int size) {
        return readArray<ll>(size);
    }

    arr<double> readDoubleArray(int size) {
        return readArray<double>(size);
    }

    arr<string> readStringArray(int size) {
        return readArray<string>(size);
    }

    arr<char> readCharArray(int size) {
        return readArray<char>(size);
    }

    template <typename T>
    T readType() {
        throw ""Operation not supported"";
    }

    template <typename U, typename V>
    pair<U, V> readType() {
        U first = readType<U>();
        V second = readType<V>();
        return make_pair(first, second);
    }

    template <typename T>
    arr<T> readArray(int n) {
        arr<T> res(n, T());
        for (int i = 0; i < n; i++) {
            res[i] = readType<T>();
        }
        return res;
    }


    template <class...Vs>
    void readArrays(int n, Vs& ...vs) {
        initArrays(n, vs...);
        for (int i = 0; i < n; i++) {
            readImpl(i, vs...);
        }
    }

    template <typename U, typename V>
    arr<pair<U, V>> readArray(int n) {
        arr<pair<U, V>> res(n);
        for (int i = 0; i < n; i++) {
            res[i] = readType<U, V>();
        }
        return res;
    }

    template <typename T>
    arr2d<T> readTable(int rows, int cols) {
        arr2d<T> result(rows, cols);
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                result(i, j) = readType<T>();
            }
        }
        return result;
    }

    arr2d<int> readIntTable(int rows, int cols) {
        return readTable<int>(rows, cols);
    }

    arr2d<char> readCharTable(int rows, int cols) {
        return readTable<char>(rows, cols);
    }

    string readLine() {
        int c = get();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
            c = get();
        } while (c != '\n' && c != '\r' && c != EOF);
        return string(all(res));
    }

    double readDouble() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        double res = 0;
        do {
            if (tolower(c) == 'e') {
                return sgn * res * dPower(double(10), readInt());
            }
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c) && c != '.');
        if (c == '.') {
            double add = 0;
            int length = 0;
            c = get();
            do {
                if (tolower(c) == 'e') {
                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());
                }
                if (!isdigit(c)) {
#ifdef LOCAL
                    throw ""Number format error"";
#endif
                    res += add * dPower(10, -length);
                    return res * sgn;
                }
                add *= 10;
                add += c - '0';
                length++;
                c = get();
            } while (!isWhitespace(c));
            res += add * dPower(double(10), -length);
        }
        return res * sgn;
    }

    char readChar() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return 0;
        }
        return c;
    }

    bool isExhausted() { return exhausted; }

    void setBufSize(int newBufSize) {
        if (newBufSize > bufSize) {
            char* newBuf = new char[newBufSize];
            memcpy(newBuf, buf, bufSize);
            buf = newBuf;
        }
        bufSize = newBufSize;
    }
};

template <>
double Input::readType() {
    return readDouble();
}

template <>
int Input::readType() {
    return readInt();
}

template <>
ll Input::readType() {
    return readLong();
}

template <>
char Input::readType() {
    return readChar();
}

template <>
string Input::readType() {
    return readString();
}

Input in;


class Output {
private:
    ostream& out = cout;

    template <typename T>
    void printSingle(const T& value) {
        out << value;
    }

    template <typename T>
    void printSingle(const vec<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr2d<T>& array) {
        size_t n = array.dim1();
        size_t m = array.dim2();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                out << array(i, j);
                if (j + 1 != m) {
                    out << ' ';
                }
            }
            if (i + 1 != n) {
                out << '\n';
            }
        }
    }

    template <typename T, typename U>
    void printSingle(const pair<T, U>& value) {
        out << value.first << ' ' << value.second;
    }

public:
    Output() {//ostream& out) : out(out) {
        out << fixed << setprecision(20);
    }

    void print() {}

    template <typename T, typename...Targs>
    void print(const T& first, const Targs... args) {
        printSingle(first);
        if (sizeof...(args) != 0) {
            out << ' ';
            print(args...);
        }
    }

    template <typename...Targs>
    void printLine(const Targs... args) {
        print(args...);
        out << '\n';
    }

    void flush() {
        out.flush();
    }
};

Output out;


template <typename T>
class que : public queue<T> {
    using parent = queue<T>;
public:
    que() : parent() {}

    que(const que<T>& q) : parent(q) {}

    que(que<T>&& q) noexcept : parent(move(q)) {}

    T pop() {
#ifdef LOCAL
        if (parent::empty()) {
            throw ""Pop on empty queue"";
        }
#endif
        T res = parent::front();
        parent::pop();
        return res;
    }

    que<T>& operator=(que<T>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    que<T>& operator=(const que<T>& __x) {
        parent::operator=(__x);
        return *this;
    }
};

using qi = que<int>;


class ESAbATAd {
public:
    void solve() {
        in.setBufSize(1);
        int t = in.readInt();
        int b = in.readInt();

        for (int x : range(t)) {
            arr<char> answer(b);
            for (int i : range(b / 10)) {
                for (int j : range(5)) {
                    out.printLine(i * 5 + j + 1);
                    out.flush();
                    answer[i * 5 + j] = in.readChar();
                    out.printLine(b - i * 5 - j);
                    out.flush();
                    answer[b - i * 5 - j - 1] = in.readChar();
                }
            }
            que<int> ranges;
            for (int i : range(b / 10)) {
                ranges.push(1 << i);
            }
            bool first = true;
            while (ranges.size() > 1 || first) {
                first = false;
                vi cur;
                for (int i : range(5)) {
                    if (!ranges.empty()) {
                        cur.push_back(ranges.pop());
                    }
                }
                int req = 0;
                int total = 0;
                for (int i : cur) {
                    total += i;
                    bool checkedInverse = false;
                    bool inverse = false;
                    bool checkerReverse = false;
                    bool reverse = false;
                    for (int j : range(b / 2)) {
                        if ((i >> (j / 5) & 1)) {
                            if (answer[j] == answer[b - 1 - j] && !checkedInverse) {
                                out.printLine(j + 1);
                                out.flush();
                                inverse = in.readChar() != answer[j];
                                checkedInverse = true;
                                req++;
                            } else if (answer[j] != answer[b - 1 - j] && !checkerReverse) {
                                out.printLine(j + 1);
                                out.flush();
                                reverse = in.readChar() != answer[j];
                                checkerReverse = true;
                                req++;
                            }
                        }
                    }
                    if (checkerReverse) {
                        reverse ^= inverse;
                    }
                    for (int j : range(b / 2)) {
                        if ((i >> (j / 5) & 1)) {
                            if (inverse) {
                                answer[j] = '0' + '1' - answer[j];
                                answer[b - j - 1] = '0' + '1' - answer[b - j - 1];
                            }
                            if (reverse) {
                                swap(answer[j], answer[b - j - 1]);
                            }
                        }
                    }
                }
                for (int y : range(10 - req)) {
                    out.printLine(1);
                    out.flush();
                    in.readChar();
                }
                ranges.push(total);
            }
            out.printLine(string(all(answer)));
            out.flush();
            if (in.readChar() != 'Y') {
                return;
            }
        }
    }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    ESAbATAd solver;


    solver.solve();
    fflush(stdout);
    return 0;
}
",0000000000219983.CPP,000000000019fd27,0000000000219983,0000000000209a9e,Egor,2020
48,0000000000219230,"/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Egor Kulikov
 */







#include <bits/stdc++.h>

using namespace std;

// BEGIN CUT HERE
template <typename T>
class Vector : public vector<T> {
    using parent = vector<T>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const T& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<T> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    const T& operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    T& operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<T>& operator=(Vector<T>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<T>& operator=(const Vector<T>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

template <>
class Vector<bool> : public vector<bool> {
    using parent = vector<bool>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<bool> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    parent::const_reference operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    parent::reference operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<bool>& operator=(const Vector<bool>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

#ifdef LOCAL
#define vec Vector
#else
// END CUT HERE
#define vec vector
// BEGIN CUT HERE
#endif
// END CUT HERE

using vi = vec<int>;


#define all(v) (v).begin(), (v).end()

using ll = long long;
using ld = long double;
using pii = pair<int, int>;

void doReplace() {
}

template <typename T, typename U, typename...Vs>
void doReplace(T& t, const U& u, Vs&& ...vs) {
    t = u;
    doReplace(vs...);
}

template <typename T, typename...Us>
T minim(T& was, const T& cand, Us&& ...us) {
    if (was > cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}

template <typename T, typename...Us>
T maxim(T& was, const T& cand, Us&& ...us) {
    if (was < cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}


template <typename D>
D dPower(D base, ll exponent) {
    if (exponent < 0) {
        return dPower(1 / base, -exponent);
    }
    if (exponent == 0) {
        return 1;
    }
    if ((exponent & 1) == 1) {
        return dPower(base, exponent - 1) * base;
    } else {
        D res = dPower(base, exponent >> 1);
        return res * res;
    }
}


class NumberIterator : iterator<forward_iterator_tag, int> {
public:
    int v;

    NumberIterator(int v) : v(v) {}

    operator int&() { return v; }

    int operator*() { return v; }
};

class range : pii {
public:
    range(int begin, int end) : pii(begin, max(begin, end)) {}

    range(int n) : pii(0, max(0, n)) {}

    NumberIterator begin() {
        return first;
    }

    NumberIterator end() {
        return second;
    }
};


template <typename T>
class arr {
    T* b;
    int n;

    void allocate(int sz) {
#ifdef LOCAL
        if (sz < 0) {
            throw ""bad alloc"";
        }
#endif
        n = sz;
        if (sz > 0) {
            b = (T*) (::operator new(sz * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr(int n = 0) {
        allocate(n);
#ifdef LOCAL
        view();
#endif
    }

    arr(int n, const T& init) {
        allocate(n);
        for (int i : range(n)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(initializer_list<T> l) {
        allocate(n);
        if (n > 0) {
            memcpy(b, l.begin(), n * sizeof(T));
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(T* b, int n) : arr(b, b + n) {}

    arr(T* b, T* e) : b(b), n(e - b) {}

    int size() const {
        return n;
    }

    T* begin() {
        return b;
    }

    const T* begin() const {
        return b;
    }

    T* end() {
        return b + n;
    }

    const T* end() const {
        return b + n;
    }

    arr<T> clone() const {
        arr<T> res(n);
        copy(b, b + n, res.begin());
        return res;
    }

    T& operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    const T& operator[](int at) const {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    bool operator==(const arr& other) const {
        if (n != other.n) {
            return false;
        }
        for (int i : range(n)) {
            if (b[i] != other.b[i]) {
                return false;
            }
        }
        return true;
    }

    vector<T> view() {
        return vector<T>(b, b + min(n, 50));
    }
};

typedef arr<int> arri;

void decreaseByOne() {}

template <typename T, class...Vs>
void decreaseByOne(arr<T>& array, Vs& ...vs) {
    int n = array.size();
    for (int i = 0; i < n; ++i) {
        array[i]--;
    }
    decreaseByOne(vs...);
}

template <typename T, typename U>
void decreaseByOne(arr<pair<T, U>>& v) {
    for (auto& p : v) {
        p.first--;
        p.second--;
    }
}


template <typename T>
class arr2d {
    T* b;
    int d1;
    int d2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
#ifdef LOCAL
        view();
#endif
    }

    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    const T& operator()(int i1, int i2) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    arr<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr<T>(b + at * d2, d2);
    }

    vector<vector<T>> view() {
        vector<vector<T>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }

    arr2d<T> clone() {
        arr2d<T> res(d1, d2);
        copy(b, b + sz, res.b);
        return res;
    }
};

template <typename T>
class arr3d {
    T* b;
    int d1;
    int d2;
    int d3;
    int shift;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    const T& operator()(int i1, int i2, int i3) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    arr2d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr2d<T>(b + at * shift, d2, d3);
    }

    vector<vector<vector<T>>> view() {
        vector<vector<vector<T>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};

template <typename T>
class arr4d {
    T* b;
    int d1;
    int d2;
    int d3;
    int d4;
    int shift1;
    int shift2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
    }

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    int dim4() const {
        return d4;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3, int i4) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    const T& operator()(int i1, int i2, int i3, int i4) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    arr3d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr3d<T>(b + at * shift1, d2, d3, d4);
    }

    vector<vector<vector<vector<T>>>> view() {
        vector<vector<vector<vector<T>>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};


inline bool isWhitespace(int c) {
    return isspace(c) || c == EOF;
}

class Input {
private:
    bool exhausted = false;
    int bufSize = 4096;
    char* buf = new char[bufSize];
    int bufRead = 0;
    int bufAt = 0;

    inline int get() {
        if (exhausted) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return EOF;
        }
        if (bufRead == bufAt) {
            bufRead = fread(buf, sizeof(char), bufSize, stdin);
            bufAt = 0;
        }
        if (bufRead == bufAt) {
            exhausted = true;
            return EOF;
        }
        return buf[bufAt++];
    }

    template <typename T>
    inline T readInteger() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        T res = 0;
        do {
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c));
        return res * sgn;
    }

    void initArrays(int) {}

    template <typename T, class...Vs>
    void initArrays(int n, arr<T>& array, Vs& ...vs) {
        array = arr<T>(n);
        initArrays(n, vs...);
    }

    template <typename T, class...Vs>
    void initArrays(int n, vec<T>&, Vs& ...vs) {
        initArrays(n, vs...);
    }

    void readImpl(int) {}

    template <typename T, class...Vs>
    void readImpl(int i, arr<T>& arr, Vs& ...vs) {
        arr[i] = readType<T>();
        readImpl(i, vs...);
    }

    template <typename T, class...Vs>
    void readImpl(int i, vec<T>& arr, Vs& ...vs) {
        arr.push_back(readType<T>());
        readImpl(i, vs...);
    }

public:
    inline int skipWhitespace() {
        int c;
        while (isWhitespace(c = get()) && c != EOF);
        if (c == EOF) {
            exhausted = true;
        }
        return c;
    }

    inline int readInt() {
        return readInteger<int>();
    }

    ll readLong() {
        return readInteger<ll>();
    }

    string readString() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
        } while (!isWhitespace(c = get()));
        return string(all(res));
    }

    arri readIntArray(int size) {
        return readArray<int>(size);
    }

    arr<ll> readLongArray(int size) {
        return readArray<ll>(size);
    }

    arr<double> readDoubleArray(int size) {
        return readArray<double>(size);
    }

    arr<string> readStringArray(int size) {
        return readArray<string>(size);
    }

    arr<char> readCharArray(int size) {
        return readArray<char>(size);
    }

    template <typename T>
    T readType() {
        throw ""Operation not supported"";
    }

    template <typename U, typename V>
    pair<U, V> readType() {
        U first = readType<U>();
        V second = readType<V>();
        return make_pair(first, second);
    }

    template <typename T>
    arr<T> readArray(int n) {
        arr<T> res(n, T());
        for (int i = 0; i < n; i++) {
            res[i] = readType<T>();
        }
        return res;
    }


    template <class...Vs>
    void readArrays(int n, Vs& ...vs) {
        initArrays(n, vs...);
        for (int i = 0; i < n; i++) {
            readImpl(i, vs...);
        }
    }

    template <typename U, typename V>
    arr<pair<U, V>> readArray(int n) {
        arr<pair<U, V>> res(n);
        for (int i = 0; i < n; i++) {
            res[i] = readType<U, V>();
        }
        return res;
    }

    template <typename T>
    arr2d<T> readTable(int rows, int cols) {
        arr2d<T> result(rows, cols);
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                result(i, j) = readType<T>();
            }
        }
        return result;
    }

    arr2d<int> readIntTable(int rows, int cols) {
        return readTable<int>(rows, cols);
    }

    arr2d<char> readCharTable(int rows, int cols) {
        return readTable<char>(rows, cols);
    }

    string readLine() {
        int c = get();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
            c = get();
        } while (c != '\n' && c != '\r' && c != EOF);
        return string(all(res));
    }

    double readDouble() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        double res = 0;
        do {
            if (tolower(c) == 'e') {
                return sgn * res * dPower(double(10), readInt());
            }
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c) && c != '.');
        if (c == '.') {
            double add = 0;
            int length = 0;
            c = get();
            do {
                if (tolower(c) == 'e') {
                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());
                }
                if (!isdigit(c)) {
#ifdef LOCAL
                    throw ""Number format error"";
#endif
                    res += add * dPower(10, -length);
                    return res * sgn;
                }
                add *= 10;
                add += c - '0';
                length++;
                c = get();
            } while (!isWhitespace(c));
            res += add * dPower(double(10), -length);
        }
        return res * sgn;
    }

    char readChar() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return 0;
        }
        return c;
    }

    bool isExhausted() { return exhausted; }

    void setBufSize(int newBufSize) {
        if (newBufSize > bufSize) {
            char* newBuf = new char[newBufSize];
            memcpy(newBuf, buf, bufSize);
            buf = newBuf;
        }
        bufSize = newBufSize;
    }
};

template <>
double Input::readType() {
    return readDouble();
}

template <>
int Input::readType() {
    return readInt();
}

template <>
ll Input::readType() {
    return readLong();
}

template <>
char Input::readType() {
    return readChar();
}

template <>
string Input::readType() {
    return readString();
}

Input in;


class Output {
private:
    ostream& out = cout;

    template <typename T>
    void printSingle(const T& value) {
        out << value;
    }

    template <typename T>
    void printSingle(const vec<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr2d<T>& array) {
        size_t n = array.dim1();
        size_t m = array.dim2();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                out << array(i, j);
                if (j + 1 != m) {
                    out << ' ';
                }
            }
            if (i + 1 != n) {
                out << '\n';
            }
        }
    }

    template <typename T, typename U>
    void printSingle(const pair<T, U>& value) {
        out << value.first << ' ' << value.second;
    }

public:
    Output() {//ostream& out) : out(out) {
        out << fixed << setprecision(20);
    }

    void print() {}

    template <typename T, typename...Targs>
    void print(const T& first, const Targs... args) {
        printSingle(first);
        if (sizeof...(args) != 0) {
            out << ' ';
            print(args...);
        }
    }

    template <typename...Targs>
    void printLine(const Targs... args) {
        print(args...);
        out << '\n';
    }

    void flush() {
        out.flush();
    }
};

Output out;


template <typename T>
class que : public queue<T> {
    using parent = queue<T>;
public:
    que() : parent() {}

    que(const que<T>& q) : parent(q) {}

    que(que<T>&& q) noexcept : parent(move(q)) {}

    T pop() {
#ifdef LOCAL
        if (parent::empty()) {
            throw ""Pop on empty queue"";
        }
#endif
        T res = parent::front();
        parent::pop();
        return res;
    }

    que<T>& operator=(que<T>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    que<T>& operator=(const que<T>& __x) {
        parent::operator=(__x);
        return *this;
    }
};

using qi = que<int>;


class ESAbATAd {
public:
    void solve() {
        in.setBufSize(1);
        int t = in.readInt();
        int b = in.readInt();

        for (int x : range(t)) {
            arr<char> answer(b);
            for (int i : range(b / 10)) {
                for (int j : range(5)) {
                    out.printLine(i * 5 + j + 1);
                    out.flush();
                    answer[i * 5 + j] = in.readChar();
                    out.printLine(b - i * 5 - j);
                    out.flush();
                    answer[b - i * 5 - j - 1] = in.readChar();
                }
            }
            que<int> ranges;
            for (int i : range(b / 10)) {
                ranges.push(1 << i);
            }
            while (ranges.size() > 1) {
                vi cur;
                for (int i : range(5)) {
                    if (!ranges.empty()) {
                        cur.push_back(ranges.pop());
                    }
                }
                int req = 0;
                int total = 0;
                for (int i : cur) {
                    total += i;
                    bool checkedInverse = false;
                    bool inverse = false;
                    bool checkerReverse = false;
                    bool reverse = false;
                    for (int j : range(b / 2)) {
                        if ((i >> (j / 5) & 1)) {
                            if (answer[j] == answer[b - 1 - j] && !checkedInverse) {
                                out.printLine(j + 1);
                                out.flush();
                                inverse = in.readChar() == answer[j];
                                checkedInverse = true;
                                req++;
                            } else if (answer[j] != answer[b - 1 - j] && !checkerReverse) {
                                out.printLine(j + 1);
                                out.flush();
                                reverse = in.readChar() == answer[j];
                                checkerReverse = true;
                                req++;
                            }
                        }
                    }
                    if (checkerReverse) {
                        reverse ^= inverse;
                    }
                    for (int j : range(b / 2)) {
                        if ((i >> (j / 5) & 1)) {
                            if (inverse) {
                                answer[j] = '0' + '1' - answer[j];
                                answer[b - j - 1] = '0' + '1' - answer[b - j - 1];
                            }
                            if (reverse) {
                                swap(answer[j], answer[b - j - 1]);
                            }
                        }
                    }
                }
                for (int y : range(10 - req)) {
                    out.printLine(1);
                    out.flush();
                    in.readChar();
                }
                ranges.push(total);
            }
            out.printLine(string(all(answer)));
            out.flush();
            if (in.readChar() != 'Y') {
                return;
            }
        }
    }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    ESAbATAd solver;


    solver.solve();
    fflush(stdout);
    return 0;
}
",0000000000219230.CPP,000000000019fd27,0000000000219230,0000000000209a9e,Egor,2020
49,0000000000214bbd,"/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Egor Kulikov
 */







#include <bits/stdc++.h>

using namespace std;

// BEGIN CUT HERE
template <typename T>
class Vector : public vector<T> {
    using parent = vector<T>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const T& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<T> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    const T& operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    T& operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<T>& operator=(Vector<T>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<T>& operator=(const Vector<T>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

template <>
class Vector<bool> : public vector<bool> {
    using parent = vector<bool>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<bool> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    parent::const_reference operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    parent::reference operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<bool>& operator=(const Vector<bool>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

#ifdef LOCAL
#define vec Vector
#else
// END CUT HERE
#define vec vector
// BEGIN CUT HERE
#endif
// END CUT HERE

using vi = vec<int>;


#define all(v) (v).begin(), (v).end()

using ll = long long;
using ld = long double;
using pii = pair<int, int>;

void doReplace() {
}

template <typename T, typename U, typename...Vs>
void doReplace(T& t, const U& u, Vs&& ...vs) {
    t = u;
    doReplace(vs...);
}

template <typename T, typename...Us>
T minim(T& was, const T& cand, Us&& ...us) {
    if (was > cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}

template <typename T, typename...Us>
T maxim(T& was, const T& cand, Us&& ...us) {
    if (was < cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}


template <typename D>
D dPower(D base, ll exponent) {
    if (exponent < 0) {
        return dPower(1 / base, -exponent);
    }
    if (exponent == 0) {
        return 1;
    }
    if ((exponent & 1) == 1) {
        return dPower(base, exponent - 1) * base;
    } else {
        D res = dPower(base, exponent >> 1);
        return res * res;
    }
}


class NumberIterator : iterator<forward_iterator_tag, int> {
public:
    int v;

    NumberIterator(int v) : v(v) {}

    operator int&() { return v; }

    int operator*() { return v; }
};

class range : pii {
public:
    range(int begin, int end) : pii(begin, max(begin, end)) {}

    range(int n) : pii(0, max(0, n)) {}

    NumberIterator begin() {
        return first;
    }

    NumberIterator end() {
        return second;
    }
};


template <typename T>
class arr {
    T* b;
    int n;

    void allocate(int sz) {
#ifdef LOCAL
        if (sz < 0) {
            throw ""bad alloc"";
        }
#endif
        n = sz;
        if (sz > 0) {
            b = (T*) (::operator new(sz * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr(int n = 0) {
        allocate(n);
#ifdef LOCAL
        view();
#endif
    }

    arr(int n, const T& init) {
        allocate(n);
        for (int i : range(n)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(initializer_list<T> l) {
        allocate(n);
        if (n > 0) {
            memcpy(b, l.begin(), n * sizeof(T));
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(T* b, int n) : arr(b, b + n) {}

    arr(T* b, T* e) : b(b), n(e - b) {}

    int size() const {
        return n;
    }

    T* begin() {
        return b;
    }

    const T* begin() const {
        return b;
    }

    T* end() {
        return b + n;
    }

    const T* end() const {
        return b + n;
    }

    arr<T> clone() const {
        arr<T> res(n);
        copy(b, b + n, res.begin());
        return res;
    }

    T& operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    const T& operator[](int at) const {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    bool operator==(const arr& other) const {
        if (n != other.n) {
            return false;
        }
        for (int i : range(n)) {
            if (b[i] != other.b[i]) {
                return false;
            }
        }
        return true;
    }

    vector<T> view() {
        return vector<T>(b, b + min(n, 50));
    }
};

typedef arr<int> arri;

void decreaseByOne() {}

template <typename T, class...Vs>
void decreaseByOne(arr<T>& array, Vs& ...vs) {
    int n = array.size();
    for (int i = 0; i < n; ++i) {
        array[i]--;
    }
    decreaseByOne(vs...);
}

template <typename T, typename U>
void decreaseByOne(arr<pair<T, U>>& v) {
    for (auto& p : v) {
        p.first--;
        p.second--;
    }
}


template <typename T>
class arr2d {
    T* b;
    int d1;
    int d2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
#ifdef LOCAL
        view();
#endif
    }

    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    const T& operator()(int i1, int i2) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    arr<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr<T>(b + at * d2, d2);
    }

    vector<vector<T>> view() {
        vector<vector<T>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }

    arr2d<T> clone() {
        arr2d<T> res(d1, d2);
        copy(b, b + sz, res.b);
        return res;
    }
};

template <typename T>
class arr3d {
    T* b;
    int d1;
    int d2;
    int d3;
    int shift;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    const T& operator()(int i1, int i2, int i3) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    arr2d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr2d<T>(b + at * shift, d2, d3);
    }

    vector<vector<vector<T>>> view() {
        vector<vector<vector<T>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};

template <typename T>
class arr4d {
    T* b;
    int d1;
    int d2;
    int d3;
    int d4;
    int shift1;
    int shift2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
    }

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    int dim4() const {
        return d4;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3, int i4) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    const T& operator()(int i1, int i2, int i3, int i4) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    arr3d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr3d<T>(b + at * shift1, d2, d3, d4);
    }

    vector<vector<vector<vector<T>>>> view() {
        vector<vector<vector<vector<T>>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};


inline bool isWhitespace(int c) {
    return isspace(c) || c == EOF;
}

class Input {
private:
    bool exhausted = false;
    int bufSize = 4096;
    char* buf = new char[bufSize];
    int bufRead = 0;
    int bufAt = 0;

    inline int get() {
        if (exhausted) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return EOF;
        }
        if (bufRead == bufAt) {
            bufRead = fread(buf, sizeof(char), bufSize, stdin);
            bufAt = 0;
        }
        if (bufRead == bufAt) {
            exhausted = true;
            return EOF;
        }
        return buf[bufAt++];
    }

    template <typename T>
    inline T readInteger() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        T res = 0;
        do {
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c));
        return res * sgn;
    }

    void initArrays(int) {}

    template <typename T, class...Vs>
    void initArrays(int n, arr<T>& array, Vs& ...vs) {
        array = arr<T>(n);
        initArrays(n, vs...);
    }

    template <typename T, class...Vs>
    void initArrays(int n, vec<T>&, Vs& ...vs) {
        initArrays(n, vs...);
    }

    void readImpl(int) {}

    template <typename T, class...Vs>
    void readImpl(int i, arr<T>& arr, Vs& ...vs) {
        arr[i] = readType<T>();
        readImpl(i, vs...);
    }

    template <typename T, class...Vs>
    void readImpl(int i, vec<T>& arr, Vs& ...vs) {
        arr.push_back(readType<T>());
        readImpl(i, vs...);
    }

public:
    inline int skipWhitespace() {
        int c;
        while (isWhitespace(c = get()) && c != EOF);
        if (c == EOF) {
            exhausted = true;
        }
        return c;
    }

    inline int readInt() {
        return readInteger<int>();
    }

    ll readLong() {
        return readInteger<ll>();
    }

    string readString() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
        } while (!isWhitespace(c = get()));
        return string(all(res));
    }

    arri readIntArray(int size) {
        return readArray<int>(size);
    }

    arr<ll> readLongArray(int size) {
        return readArray<ll>(size);
    }

    arr<double> readDoubleArray(int size) {
        return readArray<double>(size);
    }

    arr<string> readStringArray(int size) {
        return readArray<string>(size);
    }

    arr<char> readCharArray(int size) {
        return readArray<char>(size);
    }

    template <typename T>
    T readType() {
        throw ""Operation not supported"";
    }

    template <typename U, typename V>
    pair<U, V> readType() {
        U first = readType<U>();
        V second = readType<V>();
        return make_pair(first, second);
    }

    template <typename T>
    arr<T> readArray(int n) {
        arr<T> res(n, T());
        for (int i = 0; i < n; i++) {
            res[i] = readType<T>();
        }
        return res;
    }


    template <class...Vs>
    void readArrays(int n, Vs& ...vs) {
        initArrays(n, vs...);
        for (int i = 0; i < n; i++) {
            readImpl(i, vs...);
        }
    }

    template <typename U, typename V>
    arr<pair<U, V>> readArray(int n) {
        arr<pair<U, V>> res(n);
        for (int i = 0; i < n; i++) {
            res[i] = readType<U, V>();
        }
        return res;
    }

    template <typename T>
    arr2d<T> readTable(int rows, int cols) {
        arr2d<T> result(rows, cols);
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                result(i, j) = readType<T>();
            }
        }
        return result;
    }

    arr2d<int> readIntTable(int rows, int cols) {
        return readTable<int>(rows, cols);
    }

    arr2d<char> readCharTable(int rows, int cols) {
        return readTable<char>(rows, cols);
    }

    string readLine() {
        int c = get();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
            c = get();
        } while (c != '\n' && c != '\r' && c != EOF);
        return string(all(res));
    }

    double readDouble() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        double res = 0;
        do {
            if (tolower(c) == 'e') {
                return sgn * res * dPower(double(10), readInt());
            }
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c) && c != '.');
        if (c == '.') {
            double add = 0;
            int length = 0;
            c = get();
            do {
                if (tolower(c) == 'e') {
                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());
                }
                if (!isdigit(c)) {
#ifdef LOCAL
                    throw ""Number format error"";
#endif
                    res += add * dPower(10, -length);
                    return res * sgn;
                }
                add *= 10;
                add += c - '0';
                length++;
                c = get();
            } while (!isWhitespace(c));
            res += add * dPower(double(10), -length);
        }
        return res * sgn;
    }

    char readChar() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return 0;
        }
        return c;
    }

    bool isExhausted() { return exhausted; }

    void setBufSize(int newBufSize) {
        if (newBufSize > bufSize) {
            char* newBuf = new char[newBufSize];
            memcpy(newBuf, buf, bufSize);
            buf = newBuf;
        }
        bufSize = newBufSize;
    }
};

template <>
double Input::readType() {
    return readDouble();
}

template <>
int Input::readType() {
    return readInt();
}

template <>
ll Input::readType() {
    return readLong();
}

template <>
char Input::readType() {
    return readChar();
}

template <>
string Input::readType() {
    return readString();
}

Input in;


class Output {
private:
    ostream& out = cout;

    template <typename T>
    void printSingle(const T& value) {
        out << value;
    }

    template <typename T>
    void printSingle(const vec<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr2d<T>& array) {
        size_t n = array.dim1();
        size_t m = array.dim2();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                out << array(i, j);
                if (j + 1 != m) {
                    out << ' ';
                }
            }
            if (i + 1 != n) {
                out << '\n';
            }
        }
    }

    template <typename T, typename U>
    void printSingle(const pair<T, U>& value) {
        out << value.first << ' ' << value.second;
    }

public:
    Output() {//ostream& out) : out(out) {
        out << fixed << setprecision(20);
    }

    void print() {}

    template <typename T, typename...Targs>
    void print(const T& first, const Targs... args) {
        printSingle(first);
        if (sizeof...(args) != 0) {
            out << ' ';
            print(args...);
        }
    }

    template <typename...Targs>
    void printLine(const Targs... args) {
        print(args...);
        out << '\n';
    }

    void flush() {
        out.flush();
    }
};

Output out;


template <typename T>
inline void unique(vec<T>& v) {
    v.resize(unique(all(v)) - v.begin());
}

arri createOrder(int n) {
    arri order(n);
    for (int i = 0; i < n; i++) {
        order[i] = i;
    }
    return order;
}

arri inverse(const arri& p) {
    arri res(p.size());
    for (int i : range(p.size())) {
        res[p[i]] = i;
    }
    return res;
}

template <typename T, typename Iterator>
inline void addAll(vec<T>& v, Iterator begin, Iterator end) {
    v.insert(v.end(), begin, end);
}

template <class Collection, typename Iterator>
inline void addAll(Collection& v, Iterator begin, Iterator end) {
    v.insert(begin, end);
}

template <typename Iterator>
arri getQty(Iterator begin, Iterator end, int length) {
    arri res(length, 0);
    for (Iterator it = begin; it != end; it++) {
        res[*it]++;
    }
    return res;
}

template <typename Iterator>
arri getQty(Iterator begin, Iterator end) {
    return getQty(begin, end, *max_element(begin, end) + 1);
}

template <class Collection>
void collect(Collection&) {}

template <class Collection, class Other, class ...Vs>
void collect(Collection& all, Other& a, Vs& ...vs) {
    addAll(all, all(a));
    collect(all, vs...);
}

void replace(const vi&) {}

template <class ...Vs>
void replace(const vi& all, vi& a, Vs& ...vs) {
    for (int& i : a) {
        i = lower_bound(all(all), i) - all.begin();
    }
    replace(all, vs...);
}

template <class ...Vs>
void replace(const vi& all, arri& a, Vs& ...vs) {
    for (int& i : a) {
        i = lower_bound(all(all), i) - all.begin();
    }
    replace(all, vs...);
}

template <class ...Vs>
vi compress(Vs& ...vs) {
    vi vals;
    collect(vals, vs...);
    sort(all(vals));
    unique(vals);
    replace(vals, vs...);
    return vals;
}


int id = 1;

class ParentingPartneringReturns {
public:
    void solve() {
        int n = in.readInt();
        arri s, e;
        in.readArrays(n, s, e);

        string answer(n, ' ');
        auto order = createOrder(n);
        sort(all(order), [&](int a, int b) -> bool {
            return e[a] < e[b];
        });
        int jamie = 0;
        int cameron = 0;
        for (int i : order) {
            if (jamie < cameron) {
                if (s[i] >= cameron) {
                    answer[i] = 'C';
                    cameron = e[i];
                } else if (s[i] >= jamie) {
                    answer[i] = 'J';
                    jamie = e[i];
                } else {
                    answer = ""IMPOSSIBLE"";
                    break;
                }
            } else {
                if (s[i] >= jamie) {
                    answer[i] = 'J';
                    jamie = e[i];
                } else if (s[i] >= cameron) {
                    answer[i] = 'C';
                    cameron = e[i];
                } else {
                    answer = ""IMPOSSIBLE"";
                    break;
                }
            }
        }
        out.printLine(""Case #"" + to_string(id++) + "":"", answer);
    }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    ParentingPartneringReturns solver;


    int n;
    scanf(""%d"", &n);
    for (int i = 0; i < n; ++i) {
        solver.solve();
    }

    fflush(stdout);
    return 0;
}
",0000000000214bbd.CPP,000000000019fd27,0000000000214bbd,000000000020bdf9,Egor,2020
50,000000000021442b,"/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Egor Kulikov
 */







#include <bits/stdc++.h>

using namespace std;

// BEGIN CUT HERE
template <typename T>
class Vector : public vector<T> {
    using parent = vector<T>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const T& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<T> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    const T& operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    T& operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<T>& operator=(Vector<T>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<T>& operator=(const Vector<T>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

template <>
class Vector<bool> : public vector<bool> {
    using parent = vector<bool>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<bool> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    parent::const_reference operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    parent::reference operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<bool>& operator=(const Vector<bool>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

#ifdef LOCAL
#define vec Vector
#else
// END CUT HERE
#define vec vector
// BEGIN CUT HERE
#endif
// END CUT HERE

using vi = vec<int>;


#define all(v) (v).begin(), (v).end()

using ll = long long;
using ld = long double;
using pii = pair<int, int>;

void doReplace() {
}

template <typename T, typename U, typename...Vs>
void doReplace(T& t, const U& u, Vs&& ...vs) {
    t = u;
    doReplace(vs...);
}

template <typename T, typename...Us>
T minim(T& was, const T& cand, Us&& ...us) {
    if (was > cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}

template <typename T, typename...Us>
T maxim(T& was, const T& cand, Us&& ...us) {
    if (was < cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}


template <typename D>
D dPower(D base, ll exponent) {
    if (exponent < 0) {
        return dPower(1 / base, -exponent);
    }
    if (exponent == 0) {
        return 1;
    }
    if ((exponent & 1) == 1) {
        return dPower(base, exponent - 1) * base;
    } else {
        D res = dPower(base, exponent >> 1);
        return res * res;
    }
}


class NumberIterator : iterator<forward_iterator_tag, int> {
public:
    int v;

    NumberIterator(int v) : v(v) {}

    operator int&() { return v; }

    int operator*() { return v; }
};

class range : pii {
public:
    range(int begin, int end) : pii(begin, max(begin, end)) {}

    range(int n) : pii(0, max(0, n)) {}

    NumberIterator begin() {
        return first;
    }

    NumberIterator end() {
        return second;
    }
};


template <typename T>
class arr {
    T* b;
    int n;

    void allocate(int sz) {
#ifdef LOCAL
        if (sz < 0) {
            throw ""bad alloc"";
        }
#endif
        n = sz;
        if (sz > 0) {
            b = (T*) (::operator new(sz * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr(int n = 0) {
        allocate(n);
#ifdef LOCAL
        view();
#endif
    }

    arr(int n, const T& init) {
        allocate(n);
        for (int i : range(n)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(initializer_list<T> l) {
        allocate(n);
        if (n > 0) {
            memcpy(b, l.begin(), n * sizeof(T));
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(T* b, int n) : arr(b, b + n) {}

    arr(T* b, T* e) : b(b), n(e - b) {}

    int size() const {
        return n;
    }

    T* begin() {
        return b;
    }

    const T* begin() const {
        return b;
    }

    T* end() {
        return b + n;
    }

    const T* end() const {
        return b + n;
    }

    arr<T> clone() const {
        arr<T> res(n);
        copy(b, b + n, res.begin());
        return res;
    }

    T& operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    const T& operator[](int at) const {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    bool operator==(const arr& other) const {
        if (n != other.n) {
            return false;
        }
        for (int i : range(n)) {
            if (b[i] != other.b[i]) {
                return false;
            }
        }
        return true;
    }

    vector<T> view() {
        return vector<T>(b, b + min(n, 50));
    }
};

typedef arr<int> arri;

void decreaseByOne() {}

template <typename T, class...Vs>
void decreaseByOne(arr<T>& array, Vs& ...vs) {
    int n = array.size();
    for (int i = 0; i < n; ++i) {
        array[i]--;
    }
    decreaseByOne(vs...);
}

template <typename T, typename U>
void decreaseByOne(arr<pair<T, U>>& v) {
    for (auto& p : v) {
        p.first--;
        p.second--;
    }
}


template <typename T>
class arr2d {
    T* b;
    int d1;
    int d2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
#ifdef LOCAL
        view();
#endif
    }

    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    const T& operator()(int i1, int i2) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    arr<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr<T>(b + at * d2, d2);
    }

    vector<vector<T>> view() {
        vector<vector<T>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }

    arr2d<T> clone() {
        arr2d<T> res(d1, d2);
        copy(b, b + sz, res.b);
        return res;
    }
};

template <typename T>
class arr3d {
    T* b;
    int d1;
    int d2;
    int d3;
    int shift;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    const T& operator()(int i1, int i2, int i3) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    arr2d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr2d<T>(b + at * shift, d2, d3);
    }

    vector<vector<vector<T>>> view() {
        vector<vector<vector<T>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};

template <typename T>
class arr4d {
    T* b;
    int d1;
    int d2;
    int d3;
    int d4;
    int shift1;
    int shift2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
    }

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    int dim4() const {
        return d4;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3, int i4) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    const T& operator()(int i1, int i2, int i3, int i4) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    arr3d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr3d<T>(b + at * shift1, d2, d3, d4);
    }

    vector<vector<vector<vector<T>>>> view() {
        vector<vector<vector<vector<T>>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};


inline bool isWhitespace(int c) {
    return isspace(c) || c == EOF;
}

class Input {
private:
    bool exhausted = false;
    int bufSize = 4096;
    char* buf = new char[bufSize];
    int bufRead = 0;
    int bufAt = 0;

    inline int get() {
        if (exhausted) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return EOF;
        }
        if (bufRead == bufAt) {
            bufRead = fread(buf, sizeof(char), bufSize, stdin);
            bufAt = 0;
        }
        if (bufRead == bufAt) {
            exhausted = true;
            return EOF;
        }
        return buf[bufAt++];
    }

    template <typename T>
    inline T readInteger() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        T res = 0;
        do {
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c));
        return res * sgn;
    }

    void initArrays(int) {}

    template <typename T, class...Vs>
    void initArrays(int n, arr<T>& array, Vs& ...vs) {
        array = arr<T>(n);
        initArrays(n, vs...);
    }

    template <typename T, class...Vs>
    void initArrays(int n, vec<T>&, Vs& ...vs) {
        initArrays(n, vs...);
    }

    void readImpl(int) {}

    template <typename T, class...Vs>
    void readImpl(int i, arr<T>& arr, Vs& ...vs) {
        arr[i] = readType<T>();
        readImpl(i, vs...);
    }

    template <typename T, class...Vs>
    void readImpl(int i, vec<T>& arr, Vs& ...vs) {
        arr.push_back(readType<T>());
        readImpl(i, vs...);
    }

public:
    inline int skipWhitespace() {
        int c;
        while (isWhitespace(c = get()) && c != EOF);
        if (c == EOF) {
            exhausted = true;
        }
        return c;
    }

    inline int readInt() {
        return readInteger<int>();
    }

    ll readLong() {
        return readInteger<ll>();
    }

    string readString() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
        } while (!isWhitespace(c = get()));
        return string(all(res));
    }

    arri readIntArray(int size) {
        return readArray<int>(size);
    }

    arr<ll> readLongArray(int size) {
        return readArray<ll>(size);
    }

    arr<double> readDoubleArray(int size) {
        return readArray<double>(size);
    }

    arr<string> readStringArray(int size) {
        return readArray<string>(size);
    }

    arr<char> readCharArray(int size) {
        return readArray<char>(size);
    }

    template <typename T>
    T readType() {
        throw ""Operation not supported"";
    }

    template <typename U, typename V>
    pair<U, V> readType() {
        U first = readType<U>();
        V second = readType<V>();
        return make_pair(first, second);
    }

    template <typename T>
    arr<T> readArray(int n) {
        arr<T> res(n, T());
        for (int i = 0; i < n; i++) {
            res[i] = readType<T>();
        }
        return res;
    }


    template <class...Vs>
    void readArrays(int n, Vs& ...vs) {
        initArrays(n, vs...);
        for (int i = 0; i < n; i++) {
            readImpl(i, vs...);
        }
    }

    template <typename U, typename V>
    arr<pair<U, V>> readArray(int n) {
        arr<pair<U, V>> res(n);
        for (int i = 0; i < n; i++) {
            res[i] = readType<U, V>();
        }
        return res;
    }

    template <typename T>
    arr2d<T> readTable(int rows, int cols) {
        arr2d<T> result(rows, cols);
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                result(i, j) = readType<T>();
            }
        }
        return result;
    }

    arr2d<int> readIntTable(int rows, int cols) {
        return readTable<int>(rows, cols);
    }

    arr2d<char> readCharTable(int rows, int cols) {
        return readTable<char>(rows, cols);
    }

    string readLine() {
        int c = get();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
            c = get();
        } while (c != '\n' && c != '\r' && c != EOF);
        return string(all(res));
    }

    double readDouble() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        double res = 0;
        do {
            if (tolower(c) == 'e') {
                return sgn * res * dPower(double(10), readInt());
            }
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c) && c != '.');
        if (c == '.') {
            double add = 0;
            int length = 0;
            c = get();
            do {
                if (tolower(c) == 'e') {
                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());
                }
                if (!isdigit(c)) {
#ifdef LOCAL
                    throw ""Number format error"";
#endif
                    res += add * dPower(10, -length);
                    return res * sgn;
                }
                add *= 10;
                add += c - '0';
                length++;
                c = get();
            } while (!isWhitespace(c));
            res += add * dPower(double(10), -length);
        }
        return res * sgn;
    }

    char readChar() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return 0;
        }
        return c;
    }

    bool isExhausted() { return exhausted; }

    void setBufSize(int newBufSize) {
        if (newBufSize > bufSize) {
            char* newBuf = new char[newBufSize];
            memcpy(newBuf, buf, bufSize);
            buf = newBuf;
        }
        bufSize = newBufSize;
    }
};

template <>
double Input::readType() {
    return readDouble();
}

template <>
int Input::readType() {
    return readInt();
}

template <>
ll Input::readType() {
    return readLong();
}

template <>
char Input::readType() {
    return readChar();
}

template <>
string Input::readType() {
    return readString();
}

Input in;


class Output {
private:
    ostream& out = cout;

    template <typename T>
    void printSingle(const T& value) {
        out << value;
    }

    template <typename T>
    void printSingle(const vec<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr2d<T>& array) {
        size_t n = array.dim1();
        size_t m = array.dim2();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                out << array(i, j);
                if (j + 1 != m) {
                    out << ' ';
                }
            }
            if (i + 1 != n) {
                out << '\n';
            }
        }
    }

    template <typename T, typename U>
    void printSingle(const pair<T, U>& value) {
        out << value.first << ' ' << value.second;
    }

public:
    Output() {//ostream& out) : out(out) {
        out << fixed << setprecision(20);
    }

    void print() {}

    template <typename T, typename...Targs>
    void print(const T& first, const Targs... args) {
        printSingle(first);
        if (sizeof...(args) != 0) {
            out << ' ';
            print(args...);
        }
    }

    template <typename...Targs>
    void printLine(const Targs... args) {
        print(args...);
        out << '\n';
    }

    void flush() {
        out.flush();
    }
};

Output out;


int id = 1;

class NestingDepth {
public:
    void solve() {
        string s = in.readString();

        vec<char> res;
        int cur = 0;
        for (char c : s) {
            c -= '0';
            for (int x : range(c - cur)) {
                res.push_back('(');
            }
            for (int x : range(cur - c)) {
                res.push_back(')');
            }
            res.push_back(c + '0');
            cur = c;
        }
        for (int x : range(cur)) {
            res.push_back(')');
        }
        out.printLine(""Case #"" + to_string(id++) + "":"", string(all(res)));
    }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    NestingDepth solver;


    int n;
    scanf(""%d"", &n);
    for (int i = 0; i < n; ++i) {
        solver.solve();
    }

    fflush(stdout);
    return 0;
}
",000000000021442b.CPP,000000000019fd27,000000000021442b,0000000000209a9f,Egor,2020
51,0000000000213f77,"/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Egor Kulikov
 */







#include <bits/stdc++.h>

using namespace std;

// BEGIN CUT HERE
template <typename T>
class Vector : public vector<T> {
    using parent = vector<T>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const T& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<T> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    const T& operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    T& operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<T>& operator=(Vector<T>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<T>& operator=(const Vector<T>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

template <>
class Vector<bool> : public vector<bool> {
    using parent = vector<bool>;
public:
    Vector() : parent() {}

    explicit Vector(size_t __n) : parent(__n) {}

    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}

    explicit Vector(const parent& __x) : parent(__x) {}

    Vector(const Vector& __x) : parent(__x) {}

    Vector(Vector&& __x) noexcept : parent(move(__x)) {}

    Vector(initializer_list<bool> __l) : parent(__l) {}

    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>
    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}

    parent::const_reference operator[](size_t ind) const {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    parent::reference operator[](size_t ind) {
#ifdef LOCAL
        if (ind >= parent::size()) {
            throw ""Out of bounds"";
        }
#endif
        return parent::operator[](ind);
    }

    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {
        parent::operator=(__x);
        return *this;
    }

    Vector<bool>& operator=(const Vector<bool>& __x) {
        if (&__x == this) {
            return *this;
        }
        parent::operator=(__x);
        return *this;
    }
};

#ifdef LOCAL
#define vec Vector
#else
// END CUT HERE
#define vec vector
// BEGIN CUT HERE
#endif
// END CUT HERE

using vi = vec<int>;


#define all(v) (v).begin(), (v).end()

using ll = long long;
using ld = long double;
using pii = pair<int, int>;

void doReplace() {
}

template <typename T, typename U, typename...Vs>
void doReplace(T& t, const U& u, Vs&& ...vs) {
    t = u;
    doReplace(vs...);
}

template <typename T, typename...Us>
T minim(T& was, const T& cand, Us&& ...us) {
    if (was > cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}

template <typename T, typename...Us>
T maxim(T& was, const T& cand, Us&& ...us) {
    if (was < cand) {
        was = cand;
        doReplace(us...);
    }
    return was;
}


template <typename D>
D dPower(D base, ll exponent) {
    if (exponent < 0) {
        return dPower(1 / base, -exponent);
    }
    if (exponent == 0) {
        return 1;
    }
    if ((exponent & 1) == 1) {
        return dPower(base, exponent - 1) * base;
    } else {
        D res = dPower(base, exponent >> 1);
        return res * res;
    }
}


class NumberIterator : iterator<forward_iterator_tag, int> {
public:
    int v;

    NumberIterator(int v) : v(v) {}

    operator int&() { return v; }

    int operator*() { return v; }
};

class range : pii {
public:
    range(int begin, int end) : pii(begin, max(begin, end)) {}

    range(int n) : pii(0, max(0, n)) {}

    NumberIterator begin() {
        return first;
    }

    NumberIterator end() {
        return second;
    }
};


template <typename T>
class arr {
    T* b;
    int n;

    void allocate(int sz) {
#ifdef LOCAL
        if (sz < 0) {
            throw ""bad alloc"";
        }
#endif
        n = sz;
        if (sz > 0) {
            b = (T*) (::operator new(sz * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr(int n = 0) {
        allocate(n);
#ifdef LOCAL
        view();
#endif
    }

    arr(int n, const T& init) {
        allocate(n);
        for (int i : range(n)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(initializer_list<T> l) {
        allocate(n);
        if (n > 0) {
            memcpy(b, l.begin(), n * sizeof(T));
        }
#ifdef LOCAL
        view();
#endif
    }

    arr(T* b, int n) : arr(b, b + n) {}

    arr(T* b, T* e) : b(b), n(e - b) {}

    int size() const {
        return n;
    }

    T* begin() {
        return b;
    }

    const T* begin() const {
        return b;
    }

    T* end() {
        return b + n;
    }

    const T* end() const {
        return b + n;
    }

    arr<T> clone() const {
        arr<T> res(n);
        copy(b, b + n, res.begin());
        return res;
    }

    T& operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    const T& operator[](int at) const {
#ifdef LOCAL
        if (at < 0 || at >= n) {
            throw ""Out of bounds"";
        }
#endif
        return b[at];
    }

    bool operator==(const arr& other) const {
        if (n != other.n) {
            return false;
        }
        for (int i : range(n)) {
            if (b[i] != other.b[i]) {
                return false;
            }
        }
        return true;
    }

    vector<T> view() {
        return vector<T>(b, b + min(n, 50));
    }
};

typedef arr<int> arri;

void decreaseByOne() {}

template <typename T, class...Vs>
void decreaseByOne(arr<T>& array, Vs& ...vs) {
    int n = array.size();
    for (int i = 0; i < n; ++i) {
        array[i]--;
    }
    decreaseByOne(vs...);
}

template <typename T, typename U>
void decreaseByOne(arr<pair<T, U>>& v) {
    for (auto& p : v) {
        p.first--;
        p.second--;
    }
}


template <typename T>
class arr2d {
    T* b;
    int d1;
    int d2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
#ifdef LOCAL
        view();
#endif
    }

    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    const T& operator()(int i1, int i2) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * d2 + i2];
    }

    arr<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr<T>(b + at * d2, d2);
    }

    vector<vector<T>> view() {
        vector<vector<T>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }

    arr2d<T> clone() {
        arr2d<T> res(d1, d2);
        copy(b, b + sz, res.b);
        return res;
    }
};

template <typename T>
class arr3d {
    T* b;
    int d1;
    int d2;
    int d3;
    int shift;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    const T& operator()(int i1, int i2, int i3) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift + i2 * d3 + i3];
    }

    arr2d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr2d<T>(b + at * shift, d2, d3);
    }

    vector<vector<vector<T>>> view() {
        vector<vector<vector<T>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};

template <typename T>
class arr4d {
    T* b;
    int d1;
    int d2;
    int d3;
    int d4;
    int shift1;
    int shift2;
    int sz;

    void allocate(int n) {
#ifdef LOCAL
        if (n < 0) {
            throw ""bad alloc"";
        }
#endif
        if (n > 0) {
            b = (T*) (::operator new(n * sizeof(T)));
        } else {
            b = nullptr;
        }
    }

public:
    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T;
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
#ifdef LOCAL
        if (d1 < 0 || d2 < 0 || d3 < 0) {
            throw ""bad alloc"";
        }
#endif
        allocate(sz);
        for (int i : range(sz)) {
            ::new((void*) (b + i)) T(init);
        }
#ifdef LOCAL
        view();
#endif
    }

    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),
                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {
    }

    int size() const {
        return sz;
    }

    int dim1() const {
        return d1;
    }

    int dim2() const {
        return d2;
    }

    int dim3() const {
        return d3;
    }

    int dim4() const {
        return d4;
    }

    T* begin() {
        return b;
    }

    T* end() {
        return b + sz;
    }

    T& operator()(int i1, int i2, int i3, int i4) {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    const T& operator()(int i1, int i2, int i3, int i4) const {
#ifdef LOCAL
        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {
            throw ""Out of bounds"";
        }
#endif
        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];
    }

    arr3d<T> operator[](int at) {
#ifdef LOCAL
        if (at < 0 || at >= d1) {
            throw ""Out of bounds"";
        }
#endif
        return arr3d<T>(b + at * shift1, d2, d3, d4);
    }

    vector<vector<vector<vector<T>>>> view() {
        vector<vector<vector<vector<T>>>> res(min(d1, 50));
        for (int i = 0; i < res.size(); ++i) {
            res[i] = (*this)[i].view();
        }
        return res;
    }
};


inline bool isWhitespace(int c) {
    return isspace(c) || c == EOF;
}

class Input {
private:
    bool exhausted = false;
    int bufSize = 4096;
    char* buf = new char[bufSize];
    int bufRead = 0;
    int bufAt = 0;

    inline int get() {
        if (exhausted) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return EOF;
        }
        if (bufRead == bufAt) {
            bufRead = fread(buf, sizeof(char), bufSize, stdin);
            bufAt = 0;
        }
        if (bufRead == bufAt) {
            exhausted = true;
            return EOF;
        }
        return buf[bufAt++];
    }

    template <typename T>
    inline T readInteger() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        T res = 0;
        do {
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c));
        return res * sgn;
    }

    void initArrays(int) {}

    template <typename T, class...Vs>
    void initArrays(int n, arr<T>& array, Vs& ...vs) {
        array = arr<T>(n);
        initArrays(n, vs...);
    }

    template <typename T, class...Vs>
    void initArrays(int n, vec<T>&, Vs& ...vs) {
        initArrays(n, vs...);
    }

    void readImpl(int) {}

    template <typename T, class...Vs>
    void readImpl(int i, arr<T>& arr, Vs& ...vs) {
        arr[i] = readType<T>();
        readImpl(i, vs...);
    }

    template <typename T, class...Vs>
    void readImpl(int i, vec<T>& arr, Vs& ...vs) {
        arr.push_back(readType<T>());
        readImpl(i, vs...);
    }

public:
    inline int skipWhitespace() {
        int c;
        while (isWhitespace(c = get()) && c != EOF);
        if (c == EOF) {
            exhausted = true;
        }
        return c;
    }

    inline int readInt() {
        return readInteger<int>();
    }

    ll readLong() {
        return readInteger<ll>();
    }

    string readString() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
        } while (!isWhitespace(c = get()));
        return string(all(res));
    }

    arri readIntArray(int size) {
        return readArray<int>(size);
    }

    arr<ll> readLongArray(int size) {
        return readArray<ll>(size);
    }

    arr<double> readDoubleArray(int size) {
        return readArray<double>(size);
    }

    arr<string> readStringArray(int size) {
        return readArray<string>(size);
    }

    arr<char> readCharArray(int size) {
        return readArray<char>(size);
    }

    template <typename T>
    T readType() {
        throw ""Operation not supported"";
    }

    template <typename U, typename V>
    pair<U, V> readType() {
        U first = readType<U>();
        V second = readType<V>();
        return make_pair(first, second);
    }

    template <typename T>
    arr<T> readArray(int n) {
        arr<T> res(n, T());
        for (int i = 0; i < n; i++) {
            res[i] = readType<T>();
        }
        return res;
    }


    template <class...Vs>
    void readArrays(int n, Vs& ...vs) {
        initArrays(n, vs...);
        for (int i = 0; i < n; i++) {
            readImpl(i, vs...);
        }
    }

    template <typename U, typename V>
    arr<pair<U, V>> readArray(int n) {
        arr<pair<U, V>> res(n);
        for (int i = 0; i < n; i++) {
            res[i] = readType<U, V>();
        }
        return res;
    }

    template <typename T>
    arr2d<T> readTable(int rows, int cols) {
        arr2d<T> result(rows, cols);
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                result(i, j) = readType<T>();
            }
        }
        return result;
    }

    arr2d<int> readIntTable(int rows, int cols) {
        return readTable<int>(rows, cols);
    }

    arr2d<char> readCharTable(int rows, int cols) {
        return readTable<char>(rows, cols);
    }

    string readLine() {
        int c = get();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return """";
        }
        vec<char> res;
        do {
            res.push_back(c);
            c = get();
        } while (c != '\n' && c != '\r' && c != EOF);
        return string(all(res));
    }

    double readDouble() {
        int c = skipWhitespace();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = get();
        }
        double res = 0;
        do {
            if (tolower(c) == 'e') {
                return sgn * res * dPower(double(10), readInt());
            }
            if (!isdigit(c)) {
#ifdef LOCAL
                throw ""Number format error"";
#endif
                return sgn * res;
            }
            res *= 10;
            res += c - '0';
            c = get();
        } while (!isWhitespace(c) && c != '.');
        if (c == '.') {
            double add = 0;
            int length = 0;
            c = get();
            do {
                if (tolower(c) == 'e') {
                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());
                }
                if (!isdigit(c)) {
#ifdef LOCAL
                    throw ""Number format error"";
#endif
                    res += add * dPower(10, -length);
                    return res * sgn;
                }
                add *= 10;
                add += c - '0';
                length++;
                c = get();
            } while (!isWhitespace(c));
            res += add * dPower(double(10), -length);
        }
        return res * sgn;
    }

    char readChar() {
        int c = skipWhitespace();
        if (c == EOF) {
#ifdef LOCAL
            throw ""Input exhausted"";
#endif
            return 0;
        }
        return c;
    }

    bool isExhausted() { return exhausted; }

    void setBufSize(int newBufSize) {
        if (newBufSize > bufSize) {
            char* newBuf = new char[newBufSize];
            memcpy(newBuf, buf, bufSize);
            buf = newBuf;
        }
        bufSize = newBufSize;
    }
};

template <>
double Input::readType() {
    return readDouble();
}

template <>
int Input::readType() {
    return readInt();
}

template <>
ll Input::readType() {
    return readLong();
}

template <>
char Input::readType() {
    return readChar();
}

template <>
string Input::readType() {
    return readString();
}

Input in;


class Output {
private:
    ostream& out = cout;

    template <typename T>
    void printSingle(const T& value) {
        out << value;
    }

    template <typename T>
    void printSingle(const vec<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr<T>& array) {
        size_t n = array.size();
        for (int i = 0; i < n; ++i) {
            out << array[i];
            if (i + 1 != n) {
                out << ' ';
            }
        }
    }

    template <typename T>
    void printSingle(const arr2d<T>& array) {
        size_t n = array.dim1();
        size_t m = array.dim2();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                out << array(i, j);
                if (j + 1 != m) {
                    out << ' ';
                }
            }
            if (i + 1 != n) {
                out << '\n';
            }
        }
    }

    template <typename T, typename U>
    void printSingle(const pair<T, U>& value) {
        out << value.first << ' ' << value.second;
    }

public:
    Output() {//ostream& out) : out(out) {
        out << fixed << setprecision(20);
    }

    void print() {}

    template <typename T, typename...Targs>
    void print(const T& first, const Targs... args) {
        printSingle(first);
        if (sizeof...(args) != 0) {
            out << ' ';
            print(args...);
        }
    }

    template <typename...Targs>
    void printLine(const Targs... args) {
        print(args...);
        out << '\n';
    }

    void flush() {
        out.flush();
    }
};

Output out;


int id = 1;

class Vestigium {
public:
    void solve() {
        int n = in.readInt();
        auto m = in.readIntTable(n, n);

        int trace = 0;
        int rows = 0;
        int cols = 0;
        for (int i : range(n)) {
            trace += m(i, i);
            unordered_set<int> present;
            for (int j : range(n)) {
                if (present.count(m(i, j))) {
                    rows++;
                    break;
                }
                present.insert(m(i, j));
            }
            present.clear();
            for (int j : range(n)) {
                if (present.count(m(j, i))) {
                    cols++;
                    break;
                }
                present.insert(m(j, i));
            }
        }
        out.printLine(""Case #"" + to_string(id++) + "":"", trace, rows, cols);
    }
};


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    Vestigium solver;


    int n;
    scanf(""%d"", &n);
    for (int i = 0; i < n; ++i) {
        solver.solve();
    }

    fflush(stdout);
    return 0;
}
",0000000000213f77.CPP,000000000019fd27,0000000000213f77,000000000020993c,Egor,2020
52,000000000021b6db,"#include <bits/stdc++.h>
using namespace std;

int b,x,y,z,i,same,diff,t,tes;
int a[1007];
char ans[1007];

void rev() {
	for (int i=1 ; i<=b/2 ; i++) swap(a[i],a[b+1-i]);
}

void flip() {
	for (int i=1 ; i<=b ; i++) a[i] = 1-a[i];
}

int main() {
    scanf(""%d%d"",&t,&b);
    for (tes=1 ; tes<=t ; tes++) {
		same = 0;
		diff = 0;
		x = 0;
		
		for (i=1 ; i<=b/2 ; i++) {
			if (x == 10) {
				if (diff == 0) {
					printf(""%d\n"",same);
					fflush(stdout);
					scanf(""%d"",&y);
					printf(""%d\n"",same);
					fflush(stdout);
					scanf(""%d"",&y);
					
					if (y != a[same]) {
						flip();
					}
					
					x = 2;
				} else if (same == 0) {
					printf(""%d\n"",diff);
					fflush(stdout);
					scanf(""%d"",&y);
					printf(""%d\n"",diff);
					fflush(stdout);
					scanf(""%d"",&y);
					
					if (y != a[diff]) {
						rev();
					}
					
					x = 2;
				} else {
					printf(""%d\n"",same);
					fflush(stdout);
					scanf(""%d"",&y);
					printf(""%d\n"",diff);
					fflush(stdout);
					scanf(""%d"",&z);
					
					if (y == a[same] && z == a[diff]) {
						// nothing
					}
					if (y == a[same] && z != a[diff]) {
						rev();
					}
					if (y != a[same] && z == a[diff]) {
						flip();
						rev();
					}
					if (y != a[same] && z != a[diff]) {
						flip();
					}
					
					x = 2;
				}
			}
			
			printf(""%d\n"",i);
			fflush(stdout);
			scanf(""%d"",&a[i]);
			
			printf(""%d\n"",b+1-i);
			fflush(stdout);
			scanf(""%d"",&a[b+1-i]);
			
			if (a[i] == a[b+1-i]) same = i; else diff = i;
			
			x += 2;
		}
		
		for (i=1 ; i<=b ; i++) printf(""%d"",a[i]);
		printf(""\n"");
		fflush(stdout);
		
		scanf(""%s"",&ans);
		if (ans[0] != 'Y') break;
    }
}",000000000021b6db.CPP,000000000019fd27,000000000021b6db,0000000000209a9e,athin,2020
53,000000000021ae48,"#include <bits/stdc++.h>
using namespace std;

int b,x,y,z,i,same,diff,t,tes;
int a[1007];
char ans[1007];

void rev() {
	for (int i=1 ; i<=b/2 ; i++) swap(a[i],a[b+1-i]);
}

void flip() {
	for (int i=1 ; i<=b ; i++) a[i] = 1-a[i];
}

int main() {
    scanf(""%d%d"",&t,&b);
    for (tes=1 ; tes<=t ; tes++) {
		
		same = 0;
		diff = 0;
		x = 0;
		
		for (i=1 ; i<=b/2 ; i++) {
			if (x == 10) {
				if (diff == 0) {
					printf(""%d\n"",same);
					fflush(stdout);
					scanf(""%d"",&y);
					printf(""%d\n"",same);
					fflush(stdout);
					scanf(""%d"",&y);
					
					if (y != a[same]) {
						flip();
					}
					
					x = 2;
				} else if (same == 0) {
					printf(""%d\n"",diff);
					fflush(stdout);
					scanf(""%d"",&y);
					printf(""%d\n"",diff);
					fflush(stdout);
					scanf(""%d"",&y);
					
					if (y != a[diff]) {
						rev();
					}
					
					x = 2;
				} else {
					printf(""%d\n"",same);
					fflush(stdout);
					scanf(""%d"",&y);
					printf(""%d\n"",diff);
					fflush(stdout);
					scanf(""%d"",&z);
					
					if (x == a[same] && y == a[diff]) {
						// nothing
					}
					if (x == a[same] && y != a[diff]) {
						rev();
					}
					if (x != a[same] && y == a[diff]) {
						flip();
						rev();
					}
					if (x != a[same] && y != a[diff]) {
						flip();
					}
					
					x = 2;
				}
			}
			
			printf(""%d\n"",i);
			fflush(stdout);
			scanf(""%d"",&a[i]);
			
			printf(""%d\n"",b+1-i);
			fflush(stdout);
			scanf(""%d"",&a[b+1-i]);
			
			if (a[i] == a[b+1-i]) same = i; else diff = i;
			
			x += 2;
		}
		
		for (i=1 ; i<=b ; i++) printf(""%d"",a[i]);
		printf(""\n"");
		fflush(stdout);
		
		scanf(""%s"",&ans);
		assert(ans[0] == 'Y');
    }
}",000000000021ae48.CPP,000000000019fd27,000000000021ae48,0000000000209a9e,athin,2020
54,000000000021abe7,"#include <bits/stdc++.h>
using namespace std;

int b,x,y,z,i,same,diff,t,tes;
int a[1007];
char ans[1007];

void rev() {
	for (int i=1 ; i<=b/2 ; i++) swap(a[i],a[b+1-i]);
}

void flip() {
	for (int i=1 ; i<=b ; i++) a[i] = 1-a[i];
}

int main() {
    scanf(""%d%d"",&t,&b);
    for (tes=1 ; tes<=t ; tes++) {
		
		same = 0;
		diff = 0;
		x = 0;
		
		for (i=1 ; i<=b/2 ; i++) {
			if (x == 10) {
				if (diff == 0) {
					printf(""%d\n"",same);
					fflush(stdout);
					scanf(""%d"",&y);
					
					if (y != a[same]) {
						flip();
					}
					
					x = 1;
				} else if (same == 0) {
					printf(""%d\n"",diff);
					fflush(stdout);
					scanf(""%d"",&y);
					
					if (y != a[diff]) {
						rev();
					}
					
					x = 1;
				} else {
					printf(""%d\n"",same);
					fflush(stdout);
					scanf(""%d"",&y);
					printf(""%d\n"",diff);
					fflush(stdout);
					scanf(""%d"",&z);
					
					if (x == a[same] && y == a[diff]) {
						// nothing
					}
					if (x == a[same] && y != a[diff]) {
						rev();
					}
					if (x != a[same] && y == a[diff]) {
						flip();
						rev();
					}
					if (x != a[same] && y != a[diff]) {
						flip();
					}
					
					x = 2;
				}
			}
			
			printf(""%d\n"",i);
			fflush(stdout);
			scanf(""%d"",&a[i]);
			
			printf(""%d\n"",b+1-i);
			fflush(stdout);
			scanf(""%d"",&a[b+1-i]);
			
			if (a[i] == a[b+1-i]) same = i; else diff = i;
			
			x += 2;
		}
		
		for (i=1 ; i<=b ; i++) printf(""%d"",a[i]);
		printf(""\n"");
		fflush(stdout);
		
		scanf(""%s"",&ans);
		assert(ans[0] == 'Y');
    }
}",000000000021abe7.CPP,000000000019fd27,000000000021abe7,0000000000209a9e,athin,2020
55,0000000000217ed3,"#include <bits/stdc++.h>
using namespace std;

int i,j,x,a,b,c,t,tes,n,k;
vector<int> sisa;
bool udah;

int main() {
    scanf(""%d"",&t);
    for (tes=1 ; tes<=t ; tes++) {
		scanf(""%d%d"",&n,&k);
		printf(""Case #%d: "",tes);
		
		udah = false;
		
		if (n == 2) {
			if (k == 2) {
				printf(""POSSIBLE\n"");
				printf(""1 2\n"");
				printf(""2 1\n"");
			} else if (k == 4) {
				printf(""POSSIBLE\n"");
				printf(""2 1\n"");
				printf(""1 2\n"");
			} else {
				printf(""IMPOSSIBLE\n"");
			}
		} else {
			for (a=1 ; a<=n ; a++) {
				for (b=1 ; b<=n ; b++) {
					c = k-a-(n-2)*b;
					
					if (1 <= c && c <= n) {
						if (a == b && b != c) continue;
						if (a != b && b == c) continue;
						if (a == b && b == c) {
							printf(""POSSIBLE\n"");
							
							for (i=0 ; i<n ; i++) {
								for (j=0 ; j<n ; j++) {
									x = (j-i+n) % n + 1;
									if (x == 1) printf(""%d"",a);
									else if (x == a) printf(""%d"",1);
									else printf(""%d"",x);
									
									if (j == n-1) printf(""\n""); else printf("" "");
								}
							}
							
							udah = true;
							a = n;
							b = n;
						} else if (a == c && n >= 4) {
							printf(""POSSIBLE\n"");
							
							sisa.clear();
							for (i=1 ; i<=n ; i++) if (i != a && i != b && i != c) sisa.push_back(i);
							
							printf(""%d %d"",a,sisa[0]);
							x = -1;
							for (i=0 ; i<n-3 ; i++) {
								if (i % 2 == 0) x += 3; else x -= 1;
								x = min(x,(int)sisa.size()-1);
								printf("" %d"",sisa[x]);
							}
							printf("" %d\n"",b);
							
							for (i=1 ; i<n-2 ; i++) {
								for (j=0 ; j<n ; j++) {
									x = (j-i+n) % n;
									if (x == 0) printf(""%d"",b);
									if (x == 1) printf(""%d"",a);
									if (x >= 2) printf(""%d"",sisa[x-2]);
									if (j == n-1) printf(""\n""); else printf("" "");
								}
							}
							
							printf(""%d %d"",sisa[0],a);
							for (i=1; i<(int)sisa.size()-1 ; i++) printf("" %d"",sisa[i]);
							printf("" %d %d\n"",b,sisa[(int)sisa.size()-1]);
							
							printf(""%d %d"",b,sisa[1]);
							x = 1;
							for (i=0 ; i<n-3 ; i++) {
								if (i % 2 == 0) x -= 1; else x += 3;
								x = min(x,(int)sisa.size()-1);
								printf("" %d"",sisa[x]);
							}
							printf("" %d\n"",a);
							
							udah = true;
							a = n;
							b = n;
						} else if (a != c) {
							printf(""POSSIBLE\n"");
							
							sisa.clear();
							for (i=1 ; i<=n ; i++) if (i != a && i != b && i != c) sisa.push_back(i);
							
							printf(""%d"",a);
							for (i=0 ; i<sisa.size() ; i++) printf("" %d"",sisa[i]);
							printf("" %d %d\n"",c,b);
							
							for (i=0 ; i<n-2 ; i++) {
								for (j=0 ; j<n ; j++) {
									x = (j-i+n) % n;
									if (x == 0) printf(""%d"",c);
									if (x == 1) printf(""%d"",b);
									if (x == 2) printf(""%d"",a);
									if (x >= 3) printf(""%d"",sisa[x-3]);
									if (j == n-1) printf(""\n""); else printf("" "");
								}
							}
							
							printf(""%d %d"",b,a);
							for (i=0 ; i<sisa.size() ; i++) printf("" %d"",sisa[i]);
							printf("" %d\n"",c);
							
							udah = true;
							a = n;
							b = n;
						}
					}
				}
			}
			
			if (!udah) printf(""IMPOSSIBLE\n"");
		}
    }
}",0000000000217ed3.CPP,000000000019fd27,0000000000217ed3,0000000000209aa0,athin,2020
56,0000000000217d6a,"#include <bits/stdc++.h>
using namespace std;

int i,j,x,a,b,c,t,tes,n,k;
vector<int> sisa;
bool udah;

int main() {
    scanf(""%d"",&t);
    for (tes=1 ; tes<=t ; tes++) {
		scanf(""%d%d"",&n,&k);
		printf(""Case #%d: "",tes);
		
		udah = false;
		
		if (n == 2) {
			if (k == 2) {
				printf(""POSSIBLE\n"");
				printf(""1 2\n"");
				printf(""2 1\n"");
			} else if (k == 4) {
				printf(""POSSIBLE\n"");
				printf(""2 1\n"");
				printf(""1 2\n"");
			} else {
				printf(""IMPOSSIBLE\n"");
			}
		} else {
			for (a=1 ; a<=n ; a++) {
				for (b=1 ; b<=n ; b++) {
					c = k-a-(n-2)*b;
					
					if (1 <= c && c <= n) {
						if (a == b && b != c) continue;
						if (a != b && b == c) continue;
						if (a == b && b == c) {
							printf(""POSSIBLE\n"");
							
							for (i=0 ; i<n ; i++) {
								for (j=0 ; j<n ; j++) {
									x = (j-i+n) % n + 1;
									if (x == 1) printf(""%d"",a);
									else if (x == a) printf(""%d"",1);
									else printf(""%d"",x);
									
									if (j == n-1) printf(""\n""); else printf("" "");
								}
							}
							
							udah = true;
							a = n;
							b = n;
						} else if (a == c) {
							printf(""POSSIBLE\n"");
							
							sisa.clear();
							for (i=1 ; i<=n ; i++) if (i != a && i != b && i != c) sisa.push_back(i);
							
							printf(""%d %d"",a,sisa[0]);
							x = -1;
							for (i=0 ; i<n-3 ; i++) {
								if (i % 2 == 0) x += 3; else x -= 1;
								x = min(x,(int)sisa.size()-1);
								printf("" %d"",sisa[x]);
							}
							printf("" %d\n"",b);
							
							for (i=1 ; i<n-2 ; i++) {
								for (j=0 ; j<n ; j++) {
									x = (j-i+n) % n;
									if (x == 0) printf(""%d"",b);
									if (x == 1) printf(""%d"",a);
									if (x >= 2) printf(""%d"",sisa[x-2]);
									if (j == n-1) printf(""\n""); else printf("" "");
								}
							}
							
							printf(""%d %d"",sisa[0],a);
							for (i=1; i<(int)sisa.size()-1 ; i++) printf("" %d"",sisa[i]);
							printf("" %d %d\n"",b,sisa[(int)sisa.size()-1]);
							
							printf(""%d %d"",b,sisa[1]);
							x = 1;
							for (i=0 ; i<n-3 ; i++) {
								if (i % 2 == 0) x -= 1; else x += 3;
								x = min(x,(int)sisa.size()-1);
								printf("" %d"",sisa[x]);
							}
							printf("" %d\n"",a);
							
							udah = true;
							a = n;
							b = n;
						} else {
							printf(""POSSIBLE\n"");
							
							sisa.clear();
							for (i=1 ; i<=n ; i++) if (i != a && i != b && i != c) sisa.push_back(i);
							
							printf(""%d"",a);
							for (i=0 ; i<sisa.size() ; i++) printf("" %d"",sisa[i]);
							printf("" %d %d\n"",c,b);
							
							for (i=0 ; i<n-2 ; i++) {
								for (j=0 ; j<n ; j++) {
									x = (j-i+n) % n;
									if (x == 0) printf(""%d"",c);
									if (x == 1) printf(""%d"",b);
									if (x == 2) printf(""%d"",a);
									if (x >= 3) printf(""%d"",sisa[x-3]);
									if (j == n-1) printf(""\n""); else printf("" "");
								}
							}
							
							printf(""%d %d"",b,a);
							for (i=0 ; i<sisa.size() ; i++) printf("" %d"",sisa[i]);
							printf("" %d\n"",c);
							
							udah = true;
							a = n;
							b = n;
						}
					}
				}
			}
			
			if (!udah) printf(""IMPOSSIBLE\n"");
		}
    }
}",0000000000217d6a.CPP,000000000019fd27,0000000000217d6a,0000000000209aa0,athin,2020
57,000000000021196e,"#include <bits/stdc++.h>
using namespace std;

typedef pair<int,int> PII;
typedef pair<PII,int> PIII;

int t,tes,i,j,c,n,ans;
char s[1007];
PIII a[1007];
bool can;

int main() {
    scanf(""%d"",&t);
    for (tes=1 ; tes<=t ; tes++) {
        scanf(""%d"",&n);
		for (i=0 ; i<n ; i++) {
			scanf(""%d%d"",&a[i].first.first,&a[i].first.second);
			a[i].second = i;
		}
		sort(a,a+n);
		printf(""Case #%d: "",tes);
		
		c = -1;
		j = -1;
		can = true;
		for (i=0 ; i<n ; i++) {
			if (a[i].first.first >= c) {
				c = a[i].first.second;
				s[a[i].second] = 'C';
			} else if (a[i].first.first >= j) {
				j = a[i].first.second;
				s[a[i].second] = 'J';
			} else {
				can = false;
			}
		}
		
		if (!can) printf(""IMPOSSIBLE\n""); else {
			for (i=0 ; i<n ; i++) printf(""%c"",s[i]);
			printf(""\n"");
		}
    }
}",000000000021196e.CPP,000000000019fd27,000000000021196e,000000000020bdf9,athin,2020
58,000000000021118c,"#include <bits/stdc++.h>
using namespace std;

int t,tes,i,x,y,n;
char s[1007];

int main() {
    scanf(""%d"",&t);
    for (tes=1 ; tes<=t ; tes++) {
        scanf(""%s"",&s);
		n = strlen(s);
		
		printf(""Case #%d: "",tes);
		x = 0;
		for (i=0 ; i<n ; i++) {
			y = s[i] - '0';
			while (y > x) {
				printf(""("");
				x++;
			}
			while (y < x) {
				printf("")"");
				x--;
			}
			printf(""%d"",y);
		}
		while (x > 0) {
			printf("")"");
			x--;
		}
		printf(""\n"");
    }
}",000000000021118c.CPP,000000000019fd27,000000000021118c,0000000000209a9f,athin,2020
59,0000000000210bf9,"#include <bits/stdc++.h>
using namespace std;

int t,i,j,tes,n,x,y,sum;
int a[1007][1007];
map<int,bool> udah;

int main() {
    scanf(""%d"",&t);
    for (tes=1 ; tes<=t ; tes++) {
        scanf(""%d"",&n);
        for (i=1 ; i<=n ; i++) {
            for (j=1 ; j<=n ; j++) {
                scanf(""%d"",&a[i][j]);
            }
        }
        
        sum = 0;
        x = 0;
        y = 0;
        for (i=1 ; i<=n ; i++) {
            udah.clear();
            for (j=1 ; j<=n ; j++) {
                if (udah[a[i][j]]) x++, j = n;
                udah[a[i][j]] = true;
            }
        }
        for (j=1 ; j<=n ; j++) {
            udah.clear();
            for (i=1 ; i<=n ; i++) {
                if (udah[a[i][j]]) y++, i = n;
                udah[a[i][j]] = true;
            }
        }
        for (i=1 ; i<=n ; i++) sum += a[i][i];
        
        printf(""Case #%d: %d %d %d\n"",tes,sum,x,y);
    }
}",0000000000210bf9.CPP,000000000019fd27,0000000000210bf9,000000000020993c,athin,2020
60,000000000021c2bb,"//~ while (clock()<=69*CLOCKS_PER_SEC)
//~ #pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O3"")
//~ #pragma GCC target (""avx2"")
//~ #pragma GCC optimize(""Ofast"")
//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")
//~ #pragma GCC optimize(""unroll-loops"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;

template <typename T>
using ordered_set =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug {
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
  *this << ""["";
  for (auto it = d.b; it != d.e; ++it)
    *this << "", "" + 2 * (it == d.b) << *it;
  ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""

#define shandom_ruffle random_shuffle

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using vi=vector<int>;
using vll=vector<ll>;
const int nax=1007;

int n;
int s;
int tab[nax][nax];

void test()
{
	scanf(""%d"", &n);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
			scanf(""%d"", &tab[i][j]);
	s=0;
	for (int i=1; i<=n; i++)
		s+=tab[i][i];
	int a=0, b=0;
	for (int i=1; i<=n; i++)
	{
		int x=0;
		for (int j=1; j<=n; j++)
			for (int l=1; l<j; l++)
				x|=(tab[i][j]==tab[i][l]);
		a+=x;
	}
	for (int i=1; i<=n; i++)
	{
		int x=0;
		for (int j=1; j<=n; j++)
			for (int l=1; l<j; l++)
				x|=(tab[j][i]==tab[l][i]);
		b+=x;
	}
	printf(""%d %d %d\n"", s, a, b);
}

int main()
{
	int t;
	scanf(""%d"", &t);
	for (int i=1; i<=t; i++)
	{
		printf(""Case #%d: "", i);
		test();
	}
	return 0;
}
",000000000021c2bb.CPP,000000000019fd27,000000000021c2bb,000000000020993c,Radewoosh,2020
61,000000000021ba84,"//~ while (clock()<=69*CLOCKS_PER_SEC)
//~ #pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O3"")
//~ #pragma GCC target (""avx2"")
//~ #pragma GCC optimize(""Ofast"")
//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")
//~ #pragma GCC optimize(""unroll-loops"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;

template <typename T>
using ordered_set =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug {
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
  *this << ""["";
  for (auto it = d.b; it != d.e; ++it)
    *this << "", "" + 2 * (it == d.b) << *it;
  ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""

#define shandom_ruffle random_shuffle

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using vi=vector<int>;
using vll=vector<ll>;
const int nax=1000*1007;

void test()
{
	string s, w;
	cin >> s;
	int b=0;
	for (char i : s)
	{
		int c=i-'0';
		while(b<c)
		{
			w.push_back('(');
			b++;
		}
		while(b>c)
		{
			w.push_back(')');
			b--;
		}
		w.push_back(i);
	}
	while(b--)
		w.push_back(')');
	cout << w << endl;
}

int main()
{
	int t;
	scanf(""%d"", &t);
	for (int i=1; i<=t; i++)
	{
		printf(""Case #%d: "", i);
		test();
	}
	return 0;
}
",000000000021ba84.CPP,000000000019fd27,000000000021ba84,0000000000209a9f,Radewoosh,2020
62,000000000021ba44,"//~ while (clock()<=69*CLOCKS_PER_SEC)
//~ #pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O3"")
//~ #pragma GCC target (""avx2"")
//~ #pragma GCC optimize(""Ofast"")
//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")
//~ #pragma GCC optimize(""unroll-loops"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;

template <typename T>
using ordered_set =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug {
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
  *this << ""["";
  for (auto it = d.b; it != d.e; ++it)
    *this << "", "" + 2 * (it == d.b) << *it;
  ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""

#define shandom_ruffle random_shuffle

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using vi=vector<int>;
using vll=vector<ll>;
const int nax=1000*1007;

void test()
{
	string s, w;
	cin >> s;
	int b=0;
	for (char i : s)
	{
		int c=i-'0';
		while(b<c)
		{
			w.push_back('(');
			b++;
		}
		while(b>c)
		{
			w.push_back(')');
			b--;
		}
		w.push_back(i);
	}
	while(b--)
		w.push_back(')');
	cout << w << endl;
}

int main()
{
	int t;
	scanf(""%d"", &t);
	for (int i=1; i<=t; i++)
	{
		printf(""Case #%d: "", i);
		test();
	}
	return 0;
}
",000000000021ba44.CPP,000000000019fd27,000000000021ba44,0000000000209a9f,Radewoosh,2020
63,000000000021b764,"//~ while (clock()<=69*CLOCKS_PER_SEC)
//~ #pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O3"")
//~ #pragma GCC target (""avx2"")
//~ #pragma GCC optimize(""Ofast"")
//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")
//~ #pragma GCC optimize(""unroll-loops"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;

template <typename T>
using ordered_set =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug {
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
  *this << ""["";
  for (auto it = d.b; it != d.e; ++it)
    *this << "", "" + 2 * (it == d.b) << *it;
  ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""

#define shandom_ruffle random_shuffle

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using vi=vector<int>;
using vll=vector<ll>;
const int nax=1000*1007;

int n;
pii tab[nax];

string ans;

pii dos[nax];

int nope()
{
	printf(""IMPOSSIBLE\n"");
}

void test()
{
	scanf(""%d"", &n);
	ans.resize(n);
	for (int i=0; i<n; i++)
	{
		scanf(""%d%d"", &tab[i].first, &tab[i].second);
		dos[i]={tab[i].second, i};
	}
	sort(dos, dos+n);
	int o1=0;
	int o2=0;
	for (int i=0; i<n; i++)
	{
		int v=dos[i].second;
		debug() << v;
		if ((o1>=o2 || tab[v].first<o2) && tab[v].first>=o1)
		{
			o1=tab[v].second;
			ans[v]='C';
			debug() << ""C"";
		}
		else
		{
			if (tab[v].first>=o2)
			{
				o2=tab[v].second;
				ans[v]='J';
				debug() << ""J"";
			}
			else
			{
				nope();
				return;
			}
		}
	}
	cout << ans << endl;
}

int main()
{
	int t;
	scanf(""%d"", &t);
	for (int i=1; i<=t; i++)
	{
		printf(""Case #%d: "", i);
		test();
	}
	return 0;
}
",000000000021b764.CPP,000000000019fd27,000000000021b764,000000000020bdf9,Radewoosh,2020
64,000000000021ac6e,"//~ while (clock()<=69*CLOCKS_PER_SEC)
//~ #pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O3"")
//~ #pragma GCC target (""avx2"")
//~ #pragma GCC optimize(""Ofast"")
//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")
//~ #pragma GCC optimize(""unroll-loops"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;

template <typename T>
using ordered_set =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug {
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
  *this << ""["";
  for (auto it = d.b; it != d.e; ++it)
    *this << "", "" + 2 * (it == d.b) << *it;
  ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""

#define shandom_ruffle random_shuffle

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using vi=vector<int>;
using vll=vector<ll>;
const int nax=1007;

int n;
int k;
vi kto[nax];
vector<vi> stany[nax];

void ff()
{
	fflush(stdout);
}

int pyt(int v)
{
	printf(""%d\n"", v);
	ff();
	int x;
	scanf(""%d"", &x);
	return x;
}

void mnoz_stany(vector<vi> &wek)
{
	wek.resize(1);
	
	for (int i=1; i<4; i++)
	{
		vi wez=wek[0];
		if (i&1)
			reverse(wez.begin(), wez.end());
		if (i&2)
			for (int &j : wez)
				j^=1;
		wek.push_back(wez);
	}
	
	
	sort(wek.begin(), wek.end());
	wek.resize(unique(wek.begin(), wek.end())-wek.begin());
}

void przepisz(int v)
{
	for (int i=0; i<10; i++)
	{
		if (i<5)
		{
			kto[0].insert(kto[0].begin()+i, kto[v][i]);
			stany[0][0].insert(stany[0][0].begin()+i, stany[v][0][i]);
		}
		else
		{
			kto[0].push_back(kto[v][i]);
			stany[0][0].push_back(stany[v][0][i]);
		}
	}
	mnoz_stany(stany[0]);
}

void odpowiedz(vi wek)
{
	for (int i : wek)
		printf(""%d"", i);
	printf(""\n"");
	ff();
}

void ustaw_stan(int v)
{
	int r=kto[v].size();
	for (int i=0; i<r; i++)
	{
		for (int j=i+1; j<r; j++)
		{
			vector<pii> outy;
			for (int l=0; l<(int)stany[v].size(); l++)
				outy.push_back({stany[v][l][i], stany[v][l][j]});
			int czy=1;
			for (int l=0; l<(int)outy.size(); l++)
				for (int p=0; p<l; p++)
					if (outy[l]==outy[p])
						czy=0;
			if (!czy)
				continue;
			int x=pyt(kto[v][i]);
			int y=pyt(kto[v][j]);
			pii w={x, y};
			for (int l=0; l<(int)outy.size(); l++)
			{
				if (outy[l]==w)
				{
					swap(stany[v][0], stany[v][l]);
					return;
				}
			}
		}
	}
	assert(0);
}

void test()
{
	k=n/10;
	for (int i=0; i<k; i++)
	{
		kto[i].clear();
		int a=n/2-i*5-4;
		int b=n/2+i*5+1;
		for (int j=0; j<5; j++)
			kto[i].push_back(a+j);
		for (int j=0; j<5; j++)
			kto[i].push_back(b+j);
		stany[i].clear();
		stany[i].push_back(vi(0));
		for (int j : kto[i])
			stany[i][0].push_back(pyt(j));
		mnoz_stany(stany[i]);
	}
	for (int i=1; i<k; i++)
	{
		ustaw_stan(0);
		ustaw_stan(i);
		pyt(1);
		przepisz(i);
	}
	ustaw_stan(0);
	odpowiedz(stany[0][0]);
}

int main()
{
	int t;
	scanf(""%d%d"", &t, &n);
	for (int i=1; i<=t; i++)
	{
		test();
		char c;
		scanf("" %c"", &c);
		assert(c=='Y');
	}
	return 0;
}
",000000000021ac6e.CPP,000000000019fd27,000000000021ac6e,0000000000209a9e,Radewoosh,2020
65,0000000000217831,"//~ while (clock()<=69*CLOCKS_PER_SEC)
//~ #pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O3"")
//~ #pragma GCC target (""avx2"")
//~ #pragma GCC optimize(""Ofast"")
//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")
//~ #pragma GCC optimize(""unroll-loops"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;

template <typename T>
using ordered_set =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug {
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
  *this << ""["";
  for (auto it = d.b; it != d.e; ++it)
    *this << "", "" + 2 * (it == d.b) << *it;
  ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""

#define shandom_ruffle random_shuffle

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using vi=vector<int>;
using vll=vector<ll>;
const int nax=1007;

int n, k;

void nie()
{
	printf(""IMPOSSIBLE\n"");
}

void tak()
{
	printf(""POSSIBLE\n"");
}

using T = int;
struct Flow {
  struct E {
    int dest;
    T orig, *lim, *rev;
  };
  int zr, uj, n = 0;
  vector<unique_ptr<T>> ts;
  vector<vector<E>> graf;
  vector<int> ptr, odl;
  void vert(int v) {
    n = max(n, v + 1);
    graf.resize(n);
    ptr.resize(n);
    odl.resize(n);
  }
  bool iszero(T v) {
    return !v; // Zmieni dla doubli.
  }
  void bfs() {
    fill(odl.begin(), odl.end(), 0);
    vector<int> kol = {zr};
    odl[zr] = 1;
    for (int i = 0; i < (int) kol.size(); i++) {
      for (E& e : graf[kol[i]]) {
        if (!odl[e.dest] and !iszero(*e.lim)) {
          odl[e.dest] = odl[kol[i]] + 1;
          kol.push_back(e.dest);
        }
      }
    }
  }
  T dfs(int v, T lim) {
    if (v == uj) return lim;
    T ret = 0, wez;
    for (int& i = ptr[v]; i < (int) graf[v].size(); i++) {
      E& e = graf[v][i];
      if (odl[e.dest] == odl[v] + 1 and !iszero(*e.lim) and
          !iszero(wez = dfs(e.dest, min(*e.lim, lim)))) {
        ret += wez;
        *e.lim -= wez;
        *e.rev += wez;
        lim -= wez;
        if (iszero(lim)) break;
      }
    }
    return ret;
  }
  void add_edge(int u, int v, T lim, bool bi = false /* bidirectional? */) {
    vert(max(u, v));
    T *a = new T(lim), *b = new T(lim * bi);
    ts.emplace_back(a);
    ts.emplace_back(b);
    graf[u].push_back(E{v, lim,      a, b});
    graf[v].push_back(E{u, lim * bi, b, a});
  }
  T dinic(int zr_, int uj_) {
    zr = zr_; uj = uj_;
    vert(max(zr, uj));
    T ret = 0;
    while (true) {
      bfs();
      fill(ptr.begin(), ptr.end(), 0);
      const T sta = dfs(zr, numeric_limits<T>::max());  // Dla doubli mona da
      if (iszero(sta)) break;                           // infinity() zamiast
      ret += sta;                                       // max().
    }
    return ret;
  }
  vector<int> cut() {
    vector<int> ret;
    bfs();
    for (int i = 0; i < n; i++)
      if (odl[i])
        ret.push_back(i);
    return ret;
  }
  map<pair<int, int>, T> get_flowing() {  // Tam gdzie plynie 0 moe nie by
    map<pair<int, int>, T> ret;           // krawdzi.
    for (int i = 0; i < n; i++)
      for (E& e : graf[i])
        if (*e.lim < e.orig)
          ret[make_pair(i, e.dest)] += e.orig - *e.lim;
    for (auto& i : ret) {
      const pair<int, int> rev{i.first.second, i.first.first};
      const T x = min(i.second, ret[rev]);
      i.second -= x;
      ret[rev] -= x;
    }
    return ret;
  }
};


int prze[nax];

int ile[nax];

int wyn[nax][nax];

vector<pii> skojarzenie(vector<pii> kra, int moc=1)
{
	Flow janusz;
	for (int i=1; i<=n; i++)
	{
		janusz.add_edge(0, i, moc);
		janusz.add_edge(n+i, 2*n+1, moc);
	}
	for (pii i : kra)
		janusz.add_edge(i.first, n+i.second, 1);
	janusz.dinic(0, 2*n+1);
	vector<pii> ret;
	auto wez=janusz.get_flowing();
	for (auto i : wez)
		if (i.first.first<=n && i.first.second>n && i.second)
			ret.push_back({i.first.first, i.first.second-n});
	return ret;
}

void wyjmij(vector<pii> &z, vector<pii> co)
{
	set<pii> setel;
	for (pii i : co)
		setel.insert(i);
	for (int i=0; i<(int)z.size(); i++)
	{
		if (setel.count(z[i]))
		{
			swap(z[i], z.back());
			z.pop_back();
			i--;
		}
	}
}

void pokryj(vi kol, vector<pii> kra)
{
	int r=kol.size();
	if (!r)
		return;
	if (r&1)
	{
		auto wez=skojarzenie(kra);
		for (pii i : wez)
			wyn[i.first][i.second]=kol.back();
		kol.pop_back();
		wyjmij(kra, wez);
		pokryj(kol, kra);
		return;
	}
	auto wez=skojarzenie(kra, r/2);
	vi nowe[2];
	for (int i=0; i<(int)kol.size(); i++)
		nowe[i&1].push_back(kol[i]);
	wyjmij(kra, wez);
	pokryj(nowe[0], kra);
	pokryj(nowe[1], wez);
}

void test()
{
	scanf(""%d%d"", &n, &k);
	if (n==2 && k==3)
	{
		nie();
		return;
	}
	if (n==3 && (k==4 || k==5 || k==7 || k==8))
	{
		nie();
		return;
	}
	if (k==n+1 || k==n*n-1)
	{
		nie();
		return;
	}
	tak();
	map<int,int> chce;
	if (!(k%n))
	{
		chce[k/n]=n;
	}
	else
	{
		int p=k/n;
		int dod=k%n;
		if (dod!=1 && dod!=n-1)
		{
			chce[p]=n-dod;
			chce[p+1]=dod;
		}
		else
		{
			if (dod==1)
			{
				chce[p-1]=1;
				chce[p]=n-dod-2;
				chce[p+1]=dod+1;
				assert(p!=1);
			}
			else
			{
				chce[p]=n-dod+1;
				chce[p+1]=dod-2;
				chce[p+2]=1;
				assert(p!=n-1);
			}
		}
	}
	while(1)
	{
		for (int i=1; i<=n; i++)
			for (int j=1; j<=n; j++)
				wyn[i][j]=0;
		int juz=0;
		for (auto i : chce)
		{
			for (int j=1; j<=i.second; j++)
			{
				juz++;
				wyn[juz][juz]=i.first;
			}
		}
		assert(juz==n);
		juz=0;
		for (auto i : chce)
		{
			int a=juz+1;
			juz+=i.second;
			int b=juz;
			vector<pii> wek;
			for (int j=1; j<=n; j++)
				for (int l=1; l<=n; l++)
					if ((j<a || j>b) && (l<a || l>b) && !wyn[j][l])
						wek.push_back({j, l});
			shandom_ruffle(wek.begin(), wek.end());
			pokryj({i.first}, wek);
		}
		int ile=0;
		for (int i=1; i<=n; i++)
			for (int j=1; j<=n; j++)
				ile+=(wyn[i][j]>0);
		if (ile<((int)chce.size())*n)
			continue;
		vi kol;
		for (int i=1; i<=n; i++)
			if (!chce.count(i))
				kol.push_back(i);
		vector<pii> kra;
		for (int i=1; i<=n; i++)
			for (int j=1; j<=n; j++)
				if (!wyn[i][j])
					kra.push_back({i, j});
		pokryj(kol, kra);
		for (int i=1; i<=n; i++)
		{
			for (int j=1; j<=n; j++)
			{
				assert(wyn[i][j]);
				printf(""%d "", wyn[i][j]);
			}
			printf(""\n"");
		}
		break;
	}
}

int main()
{
	int t;
	scanf(""%d"", &t);
	for (int i=1; i<=t; i++)
	{
		printf(""Case #%d: "", i);
		test();
	}
	return 0;
}
",0000000000217831.CPP,000000000019fd27,0000000000217831,0000000000209aa0,Radewoosh,2020
66,00000000002174d1,"//~ while (clock()<=69*CLOCKS_PER_SEC)
//~ #pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O3"")
//~ #pragma GCC target (""avx2"")
//~ #pragma GCC optimize(""Ofast"")
//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")
//~ #pragma GCC optimize(""unroll-loops"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;

template <typename T>
using ordered_set =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug {
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
  *this << ""["";
  for (auto it = d.b; it != d.e; ++it)
    *this << "", "" + 2 * (it == d.b) << *it;
  ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""

#define shandom_ruffle random_shuffle

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using vi=vector<int>;
using vll=vector<ll>;
const int nax=1007;

int n, k;

void nie()
{
	printf(""IMPOSSIBLE\n"");
}

void tak()
{
	printf(""POSSIBLE\n"");
}

using T = int;
struct Flow {
  struct E {
    int dest;
    T orig, *lim, *rev;
  };
  int zr, uj, n = 0;
  vector<unique_ptr<T>> ts;
  vector<vector<E>> graf;
  vector<int> ptr, odl;
  void vert(int v) {
    n = max(n, v + 1);
    graf.resize(n);
    ptr.resize(n);
    odl.resize(n);
  }
  bool iszero(T v) {
    return !v; // Zmieni dla doubli.
  }
  void bfs() {
    fill(odl.begin(), odl.end(), 0);
    vector<int> kol = {zr};
    odl[zr] = 1;
    for (int i = 0; i < (int) kol.size(); i++) {
      for (E& e : graf[kol[i]]) {
        if (!odl[e.dest] and !iszero(*e.lim)) {
          odl[e.dest] = odl[kol[i]] + 1;
          kol.push_back(e.dest);
        }
      }
    }
  }
  T dfs(int v, T lim) {
    if (v == uj) return lim;
    T ret = 0, wez;
    for (int& i = ptr[v]; i < (int) graf[v].size(); i++) {
      E& e = graf[v][i];
      if (odl[e.dest] == odl[v] + 1 and !iszero(*e.lim) and
          !iszero(wez = dfs(e.dest, min(*e.lim, lim)))) {
        ret += wez;
        *e.lim -= wez;
        *e.rev += wez;
        lim -= wez;
        if (iszero(lim)) break;
      }
    }
    return ret;
  }
  void add_edge(int u, int v, T lim, bool bi = false /* bidirectional? */) {
    vert(max(u, v));
    T *a = new T(lim), *b = new T(lim * bi);
    ts.emplace_back(a);
    ts.emplace_back(b);
    graf[u].push_back(E{v, lim,      a, b});
    graf[v].push_back(E{u, lim * bi, b, a});
  }
  T dinic(int zr_, int uj_) {
    zr = zr_; uj = uj_;
    vert(max(zr, uj));
    T ret = 0;
    while (true) {
      bfs();
      fill(ptr.begin(), ptr.end(), 0);
      const T sta = dfs(zr, numeric_limits<T>::max());  // Dla doubli mona da
      if (iszero(sta)) break;                           // infinity() zamiast
      ret += sta;                                       // max().
    }
    return ret;
  }
  vector<int> cut() {
    vector<int> ret;
    bfs();
    for (int i = 0; i < n; i++)
      if (odl[i])
        ret.push_back(i);
    return ret;
  }
  map<pair<int, int>, T> get_flowing() {  // Tam gdzie plynie 0 moe nie by
    map<pair<int, int>, T> ret;           // krawdzi.
    for (int i = 0; i < n; i++)
      for (E& e : graf[i])
        if (*e.lim < e.orig)
          ret[make_pair(i, e.dest)] += e.orig - *e.lim;
    for (auto& i : ret) {
      const pair<int, int> rev{i.first.second, i.first.first};
      const T x = min(i.second, ret[rev]);
      i.second -= x;
      ret[rev] -= x;
    }
    return ret;
  }
};


int prze[nax];

int ile[nax];

int wyn[nax][nax];

vector<pii> skojarzenie(vector<pii> kra, int moc=1)
{
	Flow janusz;
	for (int i=1; i<=n; i++)
	{
		janusz.add_edge(0, i, moc);
		janusz.add_edge(n+i, 2*n+1, moc);
	}
	for (pii i : kra)
		janusz.add_edge(i.first, n+i.second, 1);
	janusz.dinic(0, 2*n+1);
	vector<pii> ret;
	auto wez=janusz.get_flowing();
	for (auto i : wez)
		if (i.first.first<=n && i.first.second>n && i.second)
			ret.push_back({i.first.first, i.first.second-n});
	return ret;
}

void wyjmij(vector<pii> &z, vector<pii> co)
{
	set<pii> setel;
	for (pii i : co)
		setel.insert(i);
	for (int i=0; i<(int)z.size(); i++)
	{
		if (setel.count(z[i]))
		{
			swap(z[i], z.back());
			z.pop_back();
			i--;
		}
	}
}

void pokryj(vi kol, vector<pii> kra)
{
	int r=kol.size();
	if (!r)
		return;
	if (r&1)
	{
		auto wez=skojarzenie(kra);
		for (pii i : wez)
			wyn[i.first][i.second]=kol.back();
		kol.pop_back();
		wyjmij(kra, wez);
		pokryj(kol, kra);
		return;
	}
	auto wez=skojarzenie(kra, r/2);
	vi nowe[2];
	for (int i=0; i<(int)kol.size(); i++)
		nowe[i&1].push_back(kol[i]);
	wyjmij(kra, wez);
	pokryj(nowe[0], kra);
	pokryj(nowe[1], wez);
}

void test()
{
	scanf(""%d%d"", &n, &k);
	if (n==2 && k==3)
	{
		nie();
		return;
	}
	if (n==3 && (k==4 || k==5 || k==7 || k==8))
	{
		nie();
		return;
	}
	if (k==n+1 || k==n*n-1)
	{
		nie();
		return;
	}
	tak();
	map<int,int> chce;
	if (!(k%n))
	{
		chce[k/n]=n;
	}
	else
	{
		int p=k/n;
		int dod=k%n;
		if (dod!=1 && dod!=n-1)
		{
			chce[p]=n-dod;
			chce[p+1]=dod;
		}
		else
		{
			if (dod==1)
			{
				chce[p]=n-dod-1;
				chce[p-1]=1;
				chce[p+1]=dod;
				assert(p!=1);
			}
			else
			{
				chce[p]=n-dod;
				chce[p+1]=dod-1;
				chce[p+2]=1;
				assert(p!=n-1);
			}
		}
	}
	while(1)
	{
		for (int i=1; i<=n; i++)
			for (int j=1; j<=n; j++)
				wyn[i][j]=0;
		int juz=0;
		for (auto i : chce)
		{
			for (int j=1; j<=i.second; j++)
			{
				juz++;
				wyn[juz][juz]=i.first;
			}
		}
		assert(juz==n);
		juz=0;
		for (auto i : chce)
		{
			int a=juz+1;
			juz+=i.second;
			int b=juz;
			vector<pii> wek;
			for (int j=1; j<=n; j++)
				for (int l=1; l<=n; l++)
					if ((j<a || j>b) && (l<a || l>b) && !wyn[j][l])
						wek.push_back({j, l});
			shandom_ruffle(wek.begin(), wek.end());
			pokryj({i.first}, wek);
		}
		int ile=0;
		for (int i=1; i<=n; i++)
			for (int j=1; j<=n; j++)
				ile+=(wyn[i][j]>0);
		if (ile<((int)chce.size())*n)
			continue;
		vi kol;
		for (int i=1; i<=n; i++)
			if (!chce.count(i))
				kol.push_back(i);
		vector<pii> kra;
		for (int i=1; i<=n; i++)
			for (int j=1; j<=n; j++)
				if (!wyn[i][j])
					kra.push_back({i, j});
		pokryj(kol, kra);
		for (int i=1; i<=n; i++)
		{
			for (int j=1; j<=n; j++)
			{
				assert(wyn[i][j]);
				printf(""%d "", wyn[i][j]);
			}
			printf(""\n"");
		}
		break;
	}
}

int main()
{
	int t;
	scanf(""%d"", &t);
	for (int i=1; i<=t; i++)
	{
		printf(""Case #%d: "", i);
		test();
	}
	return 0;
}
",00000000002174d1.CPP,000000000019fd27,00000000002174d1,0000000000209aa0,Radewoosh,2020
67,00000000002132ca,"//~ while (clock()<=69*CLOCKS_PER_SEC)
//~ #pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O3"")
//~ #pragma GCC target (""avx2"")
//~ #pragma GCC optimize(""Ofast"")
//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")
//~ #pragma GCC optimize(""unroll-loops"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;

template <typename T>
using ordered_set =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cerr << *x, 0);
sim > char dud(...);
struct debug {
#ifdef LOCAL
~debug() { cerr << endl; }
eni(!=) cerr << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
  ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
  *this << ""["";
  for (auto it = d.b; it != d.e; ++it)
    *this << "", "" + 2 * (it == d.b) << *it;
  ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""

#define shandom_ruffle random_shuffle

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;
using vi=vector<int>;
using vll=vector<ll>;
const int nax=1007;

int n, k;

void nie()
{
	printf(""IMPOSSIBLE\n"");
}

void tak()
{
	printf(""POSSIBLE\n"");
}

int prze[nax];
int wyn[nax][nax];

void test()
{
	scanf(""%d%d"", &n, &k);
	for (int h=0; h<10000; h++)
	{
		for (int i=1; i<=n; i++)
			prze[i]=1;
		int jesz=k-n;
		while(jesz)
		{
			int x=rand()%n+1;
			if (prze[x]<n)
			{
				prze[x]++;
				jesz--;
			}
		}
		//~ debug() << range(prze+1, prze+1+n);
		for (int i=1; i<=n; i++)
			for (int j=1; j<=n; j++)
				wyn[i][j]=0;
		int ok=1;
		for (int i=1; i<=n && ok; i++)
		{
			wyn[i][i]=prze[i];
			vi war, gdz;
			for (int j=1; j<=n; j++)
			{
				if (j!=prze[i])
					war.push_back(j);
				if (j!=i)
					gdz.push_back(j);
			}
			shandom_ruffle(war.begin(), war.end());
			//~ shandom_ruffle(gdz.begin(), gdz.end());
			sort(gdz.begin(), gdz.end());
			reverse(gdz.begin(), gdz.end());
			for (int k : gdz)
			{
				int suczy=0;
				for (int j=0; j<(int)war.size(); j++)
				{
					int czy=1;
					if (k>i && prze[k]==war[j])
						czy=0;
					for (int l=1; l<i && czy; l++)
						if (wyn[l][k]==war[j])
							czy=0;
					if (czy)
					{
						wyn[i][k]=war[j];
						//~ swap(war[j], war.back());
						//~ war.pop_back();
						war.erase(war.begin()+j);
						suczy=1;
						break;
					}
				}
				if (!suczy)
				{
					ok=0;
					break;
				}
			}
		}
		if (ok)
		{
			tak();
			for (int i=1; i<=n; i++)
			{
				for (int j=1; j<=n; j++)
					printf(""%d "", wyn[i][j]);
				printf(""\n"");
			}
			return;
		}
	}
	nie();
}

int main()
{
	int t;
	scanf(""%d"", &t);
	for (int i=1; i<=t; i++)
	{
		printf(""Case #%d: "", i);
		test();
	}
	return 0;
}
",00000000002132ca.CPP,000000000019fd27,00000000002132ca,0000000000209aa0,Radewoosh,2020
68,000000000021cde5,"//{{{
#pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O2"")
#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")

#include <bits/stdc++.h>
using namespace std;

#define putchar(x) cout << (x)
#define repeat(x) int _ = 0; _ < (x); ++_

template<typename T> constexpr auto range(T start, T stop, T step) {
    struct iterator {
        using difference_type = T;
        using value_type = T;
        using pointer = T*;
        using reference = T&;
        using iterator_category = random_access_iterator_tag;

        T i, step;
        T operator-(const iterator& other) const { return i - other.i; };
        bool operator!=(const iterator& other) const { return i != other.i; }
        auto& operator+=(const int& n) { i += step * n; return *this; }
        auto& operator++() { i += step; return *this; }
        auto& operator*() { return i; }
    };
    struct iterable_wrapper {
        T start, stop, step;
        auto begin() const { return iterator{ start, step }; }
        auto end() const { return iterator{ stop, step }; }
        size_t size() const { return (stop - start) / step; }

        iterable_wrapper(T start_, T stop_, T step_): start(start_), stop(stop_), step(step_) {
            stop = step > 0 ? max(start, stop) : min(start, stop);
            stop += (step - (stop - start) % step) % step;
        }
    };
    return iterable_wrapper(start, stop, step);
};
template<typename T> constexpr auto range(T start, T stop) { return range(start, stop, T(1)); }
template<typename T> constexpr auto range(T stop) { return range(T(0), stop, T(1)); }

template<typename T, typename Iter = decltype(rbegin(declval<T>()))>
constexpr auto reversed(T&& iterable) {
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return std::rbegin(iterable); }
        auto end() const { return std::rend(iterable); }
        auto size() const { return iterable.size(); }
    };
    return iterable_wrapper{ forward<T>(iterable) };
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto printer(T&& iterable) {
    struct iterator {
        Iter iter, ed;
        auto operator!=(const iterator& other) const {
            auto ret = (iter != other.iter);
            if(not ret) cout << '\n';
            return ret;
        }
        auto& operator++() { ++iter; if(iter != ed) cout << ' '; return *this; }
        auto& operator*() { return *iter; }
    };
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return iterator{ std::begin(iterable), std::end(iterable) }; }
        auto end() const { return iterator{ std::end(iterable), std::end(iterable) }; }
    };
    return iterable_wrapper{ forward<T>(iterable) };
};

template<class ...T> void absorb(T&& ...) {}
template<size_t L, size_t I, class T>
bool zip_it_ne(const T& it1, const T& it2) {
    if(not (get<I>(it1) != get<I>(it2))) return false;
    if(I + 1 == L) return true;
    return zip_it_ne<L, (I + 1) % L, T>(it1, it2);
}
template<size_t ...Is, class T, class ...Cs,
    class Iter = tuple<decltype(begin(declval<Cs>()))...>,
    class Ref = tuple<decltype(*begin(declval<Cs>()))&...>
    >
constexpr auto zip(index_sequence<Is...>, T&& iterables, Cs&&...) {
    struct iterator {
        Iter iter;
        unique_ptr<Ref> tref = nullptr;
        bool operator!=(const iterator& other) const {
            return zip_it_ne<sizeof...(Is), 0, Iter>(iter, other.iter);
        }
        auto& operator++() { absorb(++get<Is>(iter)...); return *this; }
        auto& operator*() { tref.reset(new Ref(tie(*get<Is>(iter)...))); return *tref; }
    };
    struct iterable_wrapper {
        T iterables;
        auto begin() const { return iterator { Iter{ std::begin(get<Is>(iterables))... } }; }
        auto end() const { return iterator { Iter{ std::end(get<Is>(iterables))... } }; }
        auto size() const { return min({ get<Is>(iterables).size()... }); }
    };
    return iterable_wrapper{ forward<T>(iterables) };
}
template<class ...Cs, class = tuple<decltype(begin(declval<Cs>()))...>>
constexpr auto zip(Cs&& ...cs) {
    return zip(index_sequence_for<Cs...>{}, tuple<Cs...>(forward<Cs>(cs)...), forward<Cs>(cs)...);
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto enumerate(T&& iterable) {
    return zip(range(iterable.size()), forward<T>(iterable));
}

template<size_t ...Is, typename T> auto getis(const T& t) { return tie(get<Is>(t)...); }
template<class T> void setmax(T& a, const T& b) { a = max(a, b); }
template<class T> void setmin(T& a, const T& b) { a = min(a, b); }

template<typename T> struct is_const_char_arr_ref : false_type {};
template<size_t N> struct is_const_char_arr_ref<char const (&)[N]> : true_type {};
template<typename T, typename = void> struct is_container : false_type {};
template<typename T>
struct is_container<T, conditional_t<false, decltype(begin(declval<T>())), void>> : true_type {};
template<class T> using IsC = typename enable_if<is_container<T>::value and
    not is_same<T, string>::value>::type;
template<class T> using NotC = typename enable_if<not is_container<T>::value or
    is_same<T, string>::value>::type;
template<class T> inline IsC<T> print_1(const T& v);
template<class T> inline NotC<T> print_1(const T& x) { cout << x; }
template<size_t N> void print_1(const array<char, N>& x) { cout << &x[0]; };
inline void print_1(const tuple<>&) { cout << ""()""; };
template<size_t L, size_t I, class T> void print_tuple(const T& t) {
    if(I != 0) cout << "", ""; print_1(get<I>(t));
    if(I + 1 < L) print_tuple<L, (I + 1) % L>(t);
}
template<class ...T> inline void print_1(const tuple<T...>& x) {
    cout << ""(""; print_tuple<sizeof...(T), 0, tuple<T...>>(x); cout << "")""; }
inline void print_n() {}
template<class T, class ...U> inline void print_n(const T& head, const U&... tail);
template<class T, class U> inline void print_1(const pair<T, U>& p) {
    cout << ""(""; print_1(p.first); cout << "", ""; print_1(p.second); cout << "")""; }
template<class T, class ...U> inline void print_n(const T& head, const U&... tail) {
    print_1(head); if(sizeof...(tail)) cout << "" ""; print_n(tail...); }
template<class T> inline IsC<T> print_1(const T& v) {
    cout << ""["";
    for(auto it = v.begin(); it != v.end(); ++it) { if(it != v.begin()) cout << "", ""; print_1(*it); }
    cout << ""]"";
}
template<class ...T> inline void print(const T& ...args) { print_n(args...); putchar('\n'); }
inline void read() {}
template<class T, class ...U> inline void read(T& head, U&... tail) { cin >> head; read(tail...); }

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
//static int fastio = [](){ ios_base::sync_with_stdio(false); cin.tie(0); cout.precision(17); return 0; }();

template<class T> void print_dbg(const string& s, T&& x) {
    if(is_const_char_arr_ref<T>::value) { print_n(x); } else { print_n(s, ""="", x); } }
#define SELECT(_1, _2, _3, _4, _5, _6, _7, _8, NAME,...) NAME
#define dbg1(a) print_dbg(#a, a); cout << endl;
#define dbg2(a, b) print_dbg(#a, a); cout << "", ""; dbg1(b);
#define dbg3(a, b, c) print_dbg(#a, a); cout << "", ""; dbg2(b, c);
#define dbg4(a, b, c, d) print_dbg(#a, a); cout << "", ""; dbg3(b, c, d);
#define dbg5(a, b, c, d, e) print_dbg(#a, a); cout << "", ""; dbg4(b, c, d, e);
#define dbg6(a, b, c, d, e, f) print_dbg(#a, a); cout << "", ""; dbg5(b, c, d, e, f);
#define dbg7(a, b, c, d, e, f, g) print_dbg(#a, a); cout << "", ""; dbg6(b, c, d, e, f, g);
#define dbg8(a, b, c, d, e, f, g, h) print_dbg(#a, a); cout << "", ""; dbg7(b, c, d, e, f, g, h);
#define debug(...) SELECT(__VA_ARGS__, dbg8, dbg7, dbg6, dbg5, dbg4, dbg3, dbg2, dbg1)(__VA_ARGS__)
//}}}
using PII = pair<int, int>;
using LL = long long;

const int MOD = 1e9 + 7;
const int INF = 0x3f3f3f3f;
const LL LLINF = 0x3f3f3f3f3f3f3f3f;
const int MAX_N = 300005;

struct Solution {
    void revr(string& ans, int l, int r, int B) {
        for(int i = l; i < r; ++i) {
            swap(ans[i], ans[B - 1 - i]);
        }
    }

    void flip(string& ans, int l, int r, int B) {
        for(int i = l; i < r; ++i) {
            ans[i] = '1' - ans[i] + '0';
            ans[B - 1 - i] = '1' - ans[B - 1 - i] + '0';
        }
    }

    void solve10(int B) {
        char c;
        string res(10, 'x');
        for(int i : range(B)) {
            cout << i + 1 << endl;
            cout.flush();

            cin >> c;
            res[i] = c;
        }
        cout << res << endl;
        cout.flush();
        cin >> c;
        if(c == 'N') {
            exit(0);
        }
    }

    void solve20(int B) {
        char c;
        string res(B, 'x');
        for(int i : range(B / 2)) {
            cout << i + 1 << endl;
            cout.flush();

            cin >> c;
            res[i] = c;

            cout << B - i << endl;
            cout.flush();

            cin >> c;
            res[B - 1 - i] = c;
        }

        array<int, 2> diff = {-1, -1}, same = {-1, -1};
        for(int i = 0; i < B / 2; ++i) {
            if(res[i] == res[B - 1 - i]) {
                same[i / 5] = i;
            } else {
                diff[i / 5] = i;
            }
        }

        for(int i = 0; i < 2; ++i) {
            if(same[i] == -1) {
                cout << diff[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool x = (c == res[diff[i]]);
                if(not x) {
                    flip(res, i * 5, (i + 1) * 5, B);
                }
            } else if(diff[i] == -1) {
                cout << same[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool x = (c == res[same[i]]);
                if(not x) {
                    flip(res, i * 5, (i + 1) * 5, B);
                }
            } else {
                cout << diff[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool x = (c == res[diff[i]]);
                cout << same[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool y = (c == res[same[i]]);
                if(x and not y) {
                    flip(res, i * 5, (i + 1) * 5, B);
                    revr(res, i * 5, (i + 1) * 5, B);
                } else if(not x and y) {
                    revr(res, i * 5, (i + 1) * 5, B);
                } else if(not x and not y) {
                    flip(res, i * 5, (i + 1) * 5, B);
                }
            }
        }
        cout << res << endl;
        cout.flush();
        cin >> c;
        if(c == 'N') {
            exit(0);
        }
    }

    void solve100(int B) {
        char c;
        string res(100, 'x');
        for(int i : range(50)) {
            cout << i + 1 << endl;
            cout.flush();

            cin >> c;
            res[i] = c;

            cout << B - i << endl;
            cout.flush();

            cin >> c;
            res[B - 1 - i] = c;
        }

        array<int, 20> diff, same;
        diff.fill(-1);
        same.fill(-1);
        for(int i = 0; i < 50; ++i) {
            if(res[i] == res[B - 1 - i]) {
                same[i / 5] = i;
            } else {
                diff[i / 5] = i;
            }
        }

        for(int i = 0; i < 10; ++i) {
            if(same[i] == -1) {
                cout << diff[i] + 1 << endl;
                cin >> c;
                cout.flush();
                cout << diff[i] + 1 << endl;
                cout.flush();
                cin >> c;

                bool x = (c == res[diff[i]]);
                if(not x) {
                    flip(res, i * 5, (i + 1) * 5, B);
                }
            } else if(diff[i] == -1) {
                cout << same[i] + 1 << endl;
                cout.flush();
                cin >> c;
                cout << same[i] + 1 << endl;
                cout.flush();
                cin >> c;

                bool x = (c == res[same[i]]);
                if(not x) {
                    flip(res, i * 5, (i + 1) * 5, B);
                }
            } else {
                cout << diff[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool x = (c == res[diff[i]]);

                cout << same[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool y = (c == res[same[i]]);
                if(x and not y) {
                    flip(res, i * 5, (i + 1) * 5, B);
                    revr(res, i * 5, (i + 1) * 5, B);
                } else if(not x and y) {
                    revr(res, i * 5, (i + 1) * 5, B);
                } else if(not x and not y) {
                    flip(res, i * 5, (i + 1) * 5, B);
                }
            }
        }

        diff.fill(-1);
        same.fill(-1);
        for(int i = 0; i < B / 2; ++i) {
            if(res[i] == res[B - 1 - i]) {
                same[i / 25] = i;
            } else {
                diff[i / 25] = i;
            }
        }

        for(int i = 0; i < 2; ++i) {
            if(same[i] == -1) {
                cout << diff[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool x = (c == res[diff[i]]);
                if(not x) {
                    flip(res, i * 25, (i + 1) * 25, B);
                }
            } else if(diff[i] == -1) {
                cout << same[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool x = (c == res[same[i]]);
                if(not x) {
                    flip(res, i * 25, (i + 1) * 25, B);
                }
            } else {
                cout << diff[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool x = (c == res[diff[i]]);
                cout << same[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool y = (c == res[same[i]]);
                if(x and not y) {
                    flip(res, i * 25, (i + 1) * 25, B);
                    revr(res, i * 25, (i + 1) * 25, B);
                } else if(not x and y) {
                    revr(res, i * 25, (i + 1) * 25, B);
                } else if(not x and not y) {
                    flip(res, i * 25, (i + 1) * 25, B);
                }
            }
        }

        cout << res << endl;
        cout.flush();
        cin >> c;
        if(c == 'N') {
            exit(0);
        }
    }

    Solution(int, int B) {
        if(B == 10) {
            solve10(B);
        } else if(B == 20) {
            solve20(B);
        } else {
            solve100(B);
        }
    }
};

int main() {
    int T, B;
    cin >> T >> B;
    for(int i = 1; i <= T; ++i) {
        ignore = Solution(i, B);
    }
    return 0;
}
",000000000021cde5.CPP,000000000019fd27,000000000021cde5,0000000000209a9e,zzxzxzzxz,2020
69,000000000021bc06,"//{{{
#pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O2"")
#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")

#include <bits/stdc++.h>
using namespace std;

#define putchar(x) cout << (x)
#define repeat(x) int _ = 0; _ < (x); ++_

template<typename T> constexpr auto range(T start, T stop, T step) {
    struct iterator {
        using difference_type = T;
        using value_type = T;
        using pointer = T*;
        using reference = T&;
        using iterator_category = random_access_iterator_tag;

        T i, step;
        T operator-(const iterator& other) const { return i - other.i; };
        bool operator!=(const iterator& other) const { return i != other.i; }
        auto& operator+=(const int& n) { i += step * n; return *this; }
        auto& operator++() { i += step; return *this; }
        auto& operator*() { return i; }
    };
    struct iterable_wrapper {
        T start, stop, step;
        auto begin() const { return iterator{ start, step }; }
        auto end() const { return iterator{ stop, step }; }
        size_t size() const { return (stop - start) / step; }

        iterable_wrapper(T start_, T stop_, T step_): start(start_), stop(stop_), step(step_) {
            stop = step > 0 ? max(start, stop) : min(start, stop);
            stop += (step - (stop - start) % step) % step;
        }
    };
    return iterable_wrapper(start, stop, step);
};
template<typename T> constexpr auto range(T start, T stop) { return range(start, stop, T(1)); }
template<typename T> constexpr auto range(T stop) { return range(T(0), stop, T(1)); }

template<typename T, typename Iter = decltype(rbegin(declval<T>()))>
constexpr auto reversed(T&& iterable) {
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return std::rbegin(iterable); }
        auto end() const { return std::rend(iterable); }
        auto size() const { return iterable.size(); }
    };
    return iterable_wrapper{ forward<T>(iterable) };
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto printer(T&& iterable) {
    struct iterator {
        Iter iter, ed;
        auto operator!=(const iterator& other) const {
            auto ret = (iter != other.iter);
            if(not ret) cout << '\n';
            return ret;
        }
        auto& operator++() { ++iter; if(iter != ed) cout << ' '; return *this; }
        auto& operator*() { return *iter; }
    };
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return iterator{ std::begin(iterable), std::end(iterable) }; }
        auto end() const { return iterator{ std::end(iterable), std::end(iterable) }; }
    };
    return iterable_wrapper{ forward<T>(iterable) };
};

template<class ...T> void absorb(T&& ...) {}
template<size_t L, size_t I, class T>
bool zip_it_ne(const T& it1, const T& it2) {
    if(not (get<I>(it1) != get<I>(it2))) return false;
    if(I + 1 == L) return true;
    return zip_it_ne<L, (I + 1) % L, T>(it1, it2);
}
template<size_t ...Is, class T, class ...Cs,
    class Iter = tuple<decltype(begin(declval<Cs>()))...>,
    class Ref = tuple<decltype(*begin(declval<Cs>()))&...>
    >
constexpr auto zip(index_sequence<Is...>, T&& iterables, Cs&&...) {
    struct iterator {
        Iter iter;
        unique_ptr<Ref> tref = nullptr;
        bool operator!=(const iterator& other) const {
            return zip_it_ne<sizeof...(Is), 0, Iter>(iter, other.iter);
        }
        auto& operator++() { absorb(++get<Is>(iter)...); return *this; }
        auto& operator*() { tref.reset(new Ref(tie(*get<Is>(iter)...))); return *tref; }
    };
    struct iterable_wrapper {
        T iterables;
        auto begin() const { return iterator { Iter{ std::begin(get<Is>(iterables))... } }; }
        auto end() const { return iterator { Iter{ std::end(get<Is>(iterables))... } }; }
        auto size() const { return min({ get<Is>(iterables).size()... }); }
    };
    return iterable_wrapper{ forward<T>(iterables) };
}
template<class ...Cs, class = tuple<decltype(begin(declval<Cs>()))...>>
constexpr auto zip(Cs&& ...cs) {
    return zip(index_sequence_for<Cs...>{}, tuple<Cs...>(forward<Cs>(cs)...), forward<Cs>(cs)...);
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto enumerate(T&& iterable) {
    return zip(range(iterable.size()), forward<T>(iterable));
}

template<size_t ...Is, typename T> auto getis(const T& t) { return tie(get<Is>(t)...); }
template<class T> void setmax(T& a, const T& b) { a = max(a, b); }
template<class T> void setmin(T& a, const T& b) { a = min(a, b); }

template<typename T> struct is_const_char_arr_ref : false_type {};
template<size_t N> struct is_const_char_arr_ref<char const (&)[N]> : true_type {};
template<typename T, typename = void> struct is_container : false_type {};
template<typename T>
struct is_container<T, conditional_t<false, decltype(begin(declval<T>())), void>> : true_type {};
template<class T> using IsC = typename enable_if<is_container<T>::value and
    not is_same<T, string>::value>::type;
template<class T> using NotC = typename enable_if<not is_container<T>::value or
    is_same<T, string>::value>::type;
template<class T> inline IsC<T> print_1(const T& v);
template<class T> inline NotC<T> print_1(const T& x) { cout << x; }
template<size_t N> void print_1(const array<char, N>& x) { cout << &x[0]; };
inline void print_1(const tuple<>&) { cout << ""()""; };
template<size_t L, size_t I, class T> void print_tuple(const T& t) {
    if(I != 0) cout << "", ""; print_1(get<I>(t));
    if(I + 1 < L) print_tuple<L, (I + 1) % L>(t);
}
template<class ...T> inline void print_1(const tuple<T...>& x) {
    cout << ""(""; print_tuple<sizeof...(T), 0, tuple<T...>>(x); cout << "")""; }
inline void print_n() {}
template<class T, class ...U> inline void print_n(const T& head, const U&... tail);
template<class T, class U> inline void print_1(const pair<T, U>& p) {
    cout << ""(""; print_1(p.first); cout << "", ""; print_1(p.second); cout << "")""; }
template<class T, class ...U> inline void print_n(const T& head, const U&... tail) {
    print_1(head); if(sizeof...(tail)) cout << "" ""; print_n(tail...); }
template<class T> inline IsC<T> print_1(const T& v) {
    cout << ""["";
    for(auto it = v.begin(); it != v.end(); ++it) { if(it != v.begin()) cout << "", ""; print_1(*it); }
    cout << ""]"";
}
template<class ...T> inline void print(const T& ...args) { print_n(args...); putchar('\n'); }
inline void read() {}
template<class T, class ...U> inline void read(T& head, U&... tail) { cin >> head; read(tail...); }

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
//static int fastio = [](){ ios_base::sync_with_stdio(false); cin.tie(0); cout.precision(17); return 0; }();

template<class T> void print_dbg(const string& s, T&& x) {
    if(is_const_char_arr_ref<T>::value) { print_n(x); } else { print_n(s, ""="", x); } }
#define SELECT(_1, _2, _3, _4, _5, _6, _7, _8, NAME,...) NAME
#define dbg1(a) print_dbg(#a, a); cout << endl;
#define dbg2(a, b) print_dbg(#a, a); cout << "", ""; dbg1(b);
#define dbg3(a, b, c) print_dbg(#a, a); cout << "", ""; dbg2(b, c);
#define dbg4(a, b, c, d) print_dbg(#a, a); cout << "", ""; dbg3(b, c, d);
#define dbg5(a, b, c, d, e) print_dbg(#a, a); cout << "", ""; dbg4(b, c, d, e);
#define dbg6(a, b, c, d, e, f) print_dbg(#a, a); cout << "", ""; dbg5(b, c, d, e, f);
#define dbg7(a, b, c, d, e, f, g) print_dbg(#a, a); cout << "", ""; dbg6(b, c, d, e, f, g);
#define dbg8(a, b, c, d, e, f, g, h) print_dbg(#a, a); cout << "", ""; dbg7(b, c, d, e, f, g, h);
#define debug(...) SELECT(__VA_ARGS__, dbg8, dbg7, dbg6, dbg5, dbg4, dbg3, dbg2, dbg1)(__VA_ARGS__)
//}}}
using PII = pair<int, int>;
using LL = long long;

const int MOD = 1e9 + 7;
const int INF = 0x3f3f3f3f;
const LL LLINF = 0x3f3f3f3f3f3f3f3f;
const int MAX_N = 300005;

struct Solution {
    void revr(string& ans, int l, int r, int B) {
        for(int i = l; i < r; ++i) {
            swap(ans[i], ans[B - 1 - i]);
        }
    }

    void flip(string& ans, int l, int r, int B) {
        for(int i = l; i < r; ++i) {
            ans[i] = '1' - ans[i] + '0';
            ans[B - 1 - i] = '1' - ans[B - 1 - i] + '0';
        }
    }

    void solve10(int B) {
        char c;
        string res(10, 'x');
        for(int i : range(B)) {
            cout << i + 1 << endl;
            cout.flush();

            cin >> c;
            res[i] = c;
        }
        cout << res << endl;
        cout.flush();
        cin >> c;
        if(c == 'N') {
            exit(0);
        }
    }

    void solve20(int B) {
        char c;
        string res(20, 'x');
        for(int i : range(10)) {
            cout << i + 1 << endl;
            cout.flush();

            cin >> c;
            res[i] = c;

            cout << 20 - i << endl;
            cout.flush();

            cin >> c;
            res[19 - i] = c;
        }

        array<int, 2> diff = {-1, -1}, same = {-1, -1};
        for(int i = 0; i < 10; ++i) {
            if(res[i] == res[19 - i]) {
                same[i / 5] = i;
            } else {
                diff[i / 5] = i;
            }
        }
        cerr << ""0: "" << same[0] << "" "" << diff[0] << endl;
        cerr << ""1: "" << same[1] << "" "" << diff[1] << endl;
        cerr.flush();

        for(int i = 0; i < 2; ++i) {
            if(same[i] == -1) {
                cout << diff[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool x = (c == res[diff[i]]);
                if(not x) {
                    cerr << ""case1.1"" << endl;
                    cerr.flush();
                    flip(res, i * 5, (i + 1) * 5, B);
                } else {
                    cerr << ""case1.2"" << endl;
                    cerr.flush();
                }
            } else if(diff[i] == -1) {
                cout << same[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool x = (c == res[same[i]]);
                if(not x) {
                    cerr << ""case2.1"" << endl;
                    cerr.flush();
                    flip(res, i * 5, (i + 1) * 5, B);
                } else {
                    cerr << ""case2.2"" << endl;
                    cerr.flush();
                }
            } else {
                cout << diff[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool x = (c == res[diff[i]]);
                cout << same[i] + 1 << endl;
                cout.flush();
                cin >> c;
                bool y = (c == res[same[i]]);
                if(x and not y) {
                    cerr << ""case3.1"" << endl;
                    cerr.flush();

                    flip(res, i * 5, (i + 1) * 5, B);
                    revr(res, i * 5, (i + 1) * 5, B);
                } else if(not x and y) {
                    cerr << ""case3.2"" << endl;
                    cerr.flush();

                    revr(res, i * 5, (i + 1) * 5, B);
                } else if(not x and not y) {
                    cerr << ""case3.3"" << endl;
                    cerr.flush();

                    flip(res, i * 5, (i + 1) * 5, B);
                } else {
                    cerr << ""case3.4"" << endl;
                }
            }
        }
        cout << res << endl;
        cout.flush();
        cin >> c;
        if(c == 'N') {
            exit(0);
        }
    }

    void solve100(int) {
    }

    Solution(int, int B) {
        if(B == 10) {
            solve10(B);
        } else if(B == 20) {
            solve20(B);
        } else {
            solve100(B);
        }
    }
};

int main() {
    int T, B;
    cin >> T >> B;
    for(int i = 1; i <= T; ++i) {
        ignore = Solution(i, B);
    }
    return 0;
}
",000000000021bc06.CPP,000000000019fd27,000000000021bc06,0000000000209a9e,zzxzxzzxz,2020
70,00000000002191c6,"//{{{
#pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O2"")
#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")

#include <bits/stdc++.h>
using namespace std;

#define putchar(x) cout << (x)
#define repeat(x) int _ = 0; _ < (x); ++_

template<typename T> constexpr auto range(T start, T stop, T step) {
    struct iterator {
        using difference_type = T;
        using value_type = T;
        using pointer = T*;
        using reference = T&;
        using iterator_category = random_access_iterator_tag;

        T i, step;
        T operator-(const iterator& other) const { return i - other.i; };
        bool operator!=(const iterator& other) const { return i != other.i; }
        auto& operator+=(const int& n) { i += step * n; return *this; }
        auto& operator++() { i += step; return *this; }
        auto& operator*() { return i; }
    };
    struct iterable_wrapper {
        T start, stop, step;
        auto begin() const { return iterator{ start, step }; }
        auto end() const { return iterator{ stop, step }; }
        size_t size() const { return (stop - start) / step; }

        iterable_wrapper(T start_, T stop_, T step_): start(start_), stop(stop_), step(step_) {
            stop = step > 0 ? max(start, stop) : min(start, stop);
            stop += (step - (stop - start) % step) % step;
        }
    };
    return iterable_wrapper(start, stop, step);
};
template<typename T> constexpr auto range(T start, T stop) { return range(start, stop, T(1)); }
template<typename T> constexpr auto range(T stop) { return range(T(0), stop, T(1)); }

template<typename T, typename Iter = decltype(rbegin(declval<T>()))>
constexpr auto reversed(T&& iterable) {
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return std::rbegin(iterable); }
        auto end() const { return std::rend(iterable); }
        auto size() const { return iterable.size(); }
    };
    return iterable_wrapper{ forward<T>(iterable) };
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto printer(T&& iterable) {
    struct iterator {
        Iter iter, ed;
        auto operator!=(const iterator& other) const {
            auto ret = (iter != other.iter);
            if(not ret) cout << '\n';
            return ret;
        }
        auto& operator++() { ++iter; if(iter != ed) cout << ' '; return *this; }
        auto& operator*() { return *iter; }
    };
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return iterator{ std::begin(iterable), std::end(iterable) }; }
        auto end() const { return iterator{ std::end(iterable), std::end(iterable) }; }
    };
    return iterable_wrapper{ forward<T>(iterable) };
};

template<class ...T> void absorb(T&& ...) {}
template<size_t L, size_t I, class T>
bool zip_it_ne(const T& it1, const T& it2) {
    if(not (get<I>(it1) != get<I>(it2))) return false;
    if(I + 1 == L) return true;
    return zip_it_ne<L, (I + 1) % L, T>(it1, it2);
}
template<size_t ...Is, class T, class ...Cs,
    class Iter = tuple<decltype(begin(declval<Cs>()))...>,
    class Ref = tuple<decltype(*begin(declval<Cs>()))&...>
    >
constexpr auto zip(index_sequence<Is...>, T&& iterables, Cs&&...) {
    struct iterator {
        Iter iter;
        unique_ptr<Ref> tref = nullptr;
        bool operator!=(const iterator& other) const {
            return zip_it_ne<sizeof...(Is), 0, Iter>(iter, other.iter);
        }
        auto& operator++() { absorb(++get<Is>(iter)...); return *this; }
        auto& operator*() { tref.reset(new Ref(tie(*get<Is>(iter)...))); return *tref; }
    };
    struct iterable_wrapper {
        T iterables;
        auto begin() const { return iterator { Iter{ std::begin(get<Is>(iterables))... } }; }
        auto end() const { return iterator { Iter{ std::end(get<Is>(iterables))... } }; }
        auto size() const { return min({ get<Is>(iterables).size()... }); }
    };
    return iterable_wrapper{ forward<T>(iterables) };
}
template<class ...Cs, class = tuple<decltype(begin(declval<Cs>()))...>>
constexpr auto zip(Cs&& ...cs) {
    return zip(index_sequence_for<Cs...>{}, tuple<Cs...>(forward<Cs>(cs)...), forward<Cs>(cs)...);
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto enumerate(T&& iterable) {
    return zip(range(iterable.size()), forward<T>(iterable));
}

template<size_t ...Is, typename T> auto getis(const T& t) { return tie(get<Is>(t)...); }
template<class T> void setmax(T& a, const T& b) { a = max(a, b); }
template<class T> void setmin(T& a, const T& b) { a = min(a, b); }

template<typename T> struct is_const_char_arr_ref : false_type {};
template<size_t N> struct is_const_char_arr_ref<char const (&)[N]> : true_type {};
template<typename T, typename = void> struct is_container : false_type {};
template<typename T>
struct is_container<T, conditional_t<false, decltype(begin(declval<T>())), void>> : true_type {};
template<class T> using IsC = typename enable_if<is_container<T>::value and
    not is_same<T, string>::value>::type;
template<class T> using NotC = typename enable_if<not is_container<T>::value or
    is_same<T, string>::value>::type;
template<class T> inline IsC<T> print_1(const T& v);
template<class T> inline NotC<T> print_1(const T& x) { cout << x; }
template<size_t N> void print_1(const array<char, N>& x) { cout << &x[0]; };
inline void print_1(const tuple<>&) { cout << ""()""; };
template<size_t L, size_t I, class T> void print_tuple(const T& t) {
    if(I != 0) cout << "", ""; print_1(get<I>(t));
    if(I + 1 < L) print_tuple<L, (I + 1) % L>(t);
}
template<class ...T> inline void print_1(const tuple<T...>& x) {
    cout << ""(""; print_tuple<sizeof...(T), 0, tuple<T...>>(x); cout << "")""; }
inline void print_n() {}
template<class T, class ...U> inline void print_n(const T& head, const U&... tail);
template<class T, class U> inline void print_1(const pair<T, U>& p) {
    cout << ""(""; print_1(p.first); cout << "", ""; print_1(p.second); cout << "")""; }
template<class T, class ...U> inline void print_n(const T& head, const U&... tail) {
    print_1(head); if(sizeof...(tail)) cout << "" ""; print_n(tail...); }
template<class T> inline IsC<T> print_1(const T& v) {
    cout << ""["";
    for(auto it = v.begin(); it != v.end(); ++it) { if(it != v.begin()) cout << "", ""; print_1(*it); }
    cout << ""]"";
}
template<class ...T> inline void print(const T& ...args) { print_n(args...); putchar('\n'); }
inline void read() {}
template<class T, class ...U> inline void read(T& head, U&... tail) { cin >> head; read(tail...); }

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
//static int fastio = [](){ ios_base::sync_with_stdio(false); cin.tie(0); cout.precision(17); return 0; }();

template<class T> void print_dbg(const string& s, T&& x) {
    if(is_const_char_arr_ref<T>::value) { print_n(x); } else { print_n(s, ""="", x); } }
#define SELECT(_1, _2, _3, _4, _5, _6, _7, _8, NAME,...) NAME
#define dbg1(a) print_dbg(#a, a); cout << endl;
#define dbg2(a, b) print_dbg(#a, a); cout << "", ""; dbg1(b);
#define dbg3(a, b, c) print_dbg(#a, a); cout << "", ""; dbg2(b, c);
#define dbg4(a, b, c, d) print_dbg(#a, a); cout << "", ""; dbg3(b, c, d);
#define dbg5(a, b, c, d, e) print_dbg(#a, a); cout << "", ""; dbg4(b, c, d, e);
#define dbg6(a, b, c, d, e, f) print_dbg(#a, a); cout << "", ""; dbg5(b, c, d, e, f);
#define dbg7(a, b, c, d, e, f, g) print_dbg(#a, a); cout << "", ""; dbg6(b, c, d, e, f, g);
#define dbg8(a, b, c, d, e, f, g, h) print_dbg(#a, a); cout << "", ""; dbg7(b, c, d, e, f, g, h);
#define debug(...) SELECT(__VA_ARGS__, dbg8, dbg7, dbg6, dbg5, dbg4, dbg3, dbg2, dbg1)(__VA_ARGS__)
//}}}
using PII = pair<int, int>;
using LL = long long;

const int MOD = 1e9 + 7;
const int INF = 0x3f3f3f3f;
const LL LLINF = 0x3f3f3f3f3f3f3f3f;
const int MAX_N = 300005;

struct Solution {
    Solution(int, int B) {
        char c;
        string res(150, 'x');
        for(int i : range(B)) {
            cout << (i % B) + 1 << endl;
            cout.flush();

            cin >> c;
            res[i] = c;
        }
        cout << res.substr(0, B) << endl;
        cout.flush();
        cin >> c;
        if(c == 'N') {
            exit(0);
        }
    }
};

int main() {
    int T, B;
    cin >> T >> B;
    for(int i = 1; i <= T; ++i) {
        ignore = Solution(i, B);
    }
    return 0;
}
",00000000002191c6.CPP,000000000019fd27,00000000002191c6,0000000000209a9e,zzxzxzzxz,2020
71,000000000021722f,"//{{{
#pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O2"")
#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")

#include <bits/stdc++.h>
using namespace std;

#define putchar(x) cout << (x)
#define repeat(x) int _ = 0; _ < (x); ++_

template<typename T> constexpr auto range(T start, T stop, T step) {
    struct iterator {
        using difference_type = T;
        using value_type = T;
        using pointer = T*;
        using reference = T&;
        using iterator_category = random_access_iterator_tag;

        T i, step;
        T operator-(const iterator& other) const { return i - other.i; };
        bool operator!=(const iterator& other) const { return i != other.i; }
        auto& operator+=(const int& n) { i += step * n; return *this; }
        auto& operator++() { i += step; return *this; }
        auto& operator*() { return i; }
    };
    struct iterable_wrapper {
        T start, stop, step;
        auto begin() const { return iterator{ start, step }; }
        auto end() const { return iterator{ stop, step }; }
        size_t size() const { return (stop - start) / step; }

        iterable_wrapper(T start_, T stop_, T step_): start(start_), stop(stop_), step(step_) {
            stop = step > 0 ? max(start, stop) : min(start, stop);
            stop += (step - (stop - start) % step) % step;
        }
    };
    return iterable_wrapper(start, stop, step);
};
template<typename T> constexpr auto range(T start, T stop) { return range(start, stop, T(1)); }
template<typename T> constexpr auto range(T stop) { return range(T(0), stop, T(1)); }

template<typename T, typename Iter = decltype(rbegin(declval<T>()))>
constexpr auto reversed(T&& iterable) {
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return std::rbegin(iterable); }
        auto end() const { return std::rend(iterable); }
        auto size() const { return iterable.size(); }
    };
    return iterable_wrapper{ forward<T>(iterable) };
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto printer(T&& iterable) {
    struct iterator {
        Iter iter, ed;
        auto operator!=(const iterator& other) const {
            auto ret = (iter != other.iter);
            if(not ret) cout << '\n';
            return ret;
        }
        auto& operator++() { ++iter; if(iter != ed) cout << ' '; return *this; }
        auto& operator*() { return *iter; }
    };
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return iterator{ std::begin(iterable), std::end(iterable) }; }
        auto end() const { return iterator{ std::end(iterable), std::end(iterable) }; }
    };
    return iterable_wrapper{ forward<T>(iterable) };
};

template<class ...T> void absorb(T&& ...) {}
template<size_t L, size_t I, class T>
bool zip_it_ne(const T& it1, const T& it2) {
    if(not (get<I>(it1) != get<I>(it2))) return false;
    if(I + 1 == L) return true;
    return zip_it_ne<L, (I + 1) % L, T>(it1, it2);
}
template<size_t ...Is, class T, class ...Cs,
    class Iter = tuple<decltype(begin(declval<Cs>()))...>,
    class Ref = tuple<decltype(*begin(declval<Cs>()))&...>
    >
constexpr auto zip(index_sequence<Is...>, T&& iterables, Cs&&...) {
    struct iterator {
        Iter iter;
        unique_ptr<Ref> tref = nullptr;
        bool operator!=(const iterator& other) const {
            return zip_it_ne<sizeof...(Is), 0, Iter>(iter, other.iter);
        }
        auto& operator++() { absorb(++get<Is>(iter)...); return *this; }
        auto& operator*() { tref.reset(new Ref(tie(*get<Is>(iter)...))); return *tref; }
    };
    struct iterable_wrapper {
        T iterables;
        auto begin() const { return iterator { Iter{ std::begin(get<Is>(iterables))... } }; }
        auto end() const { return iterator { Iter{ std::end(get<Is>(iterables))... } }; }
        auto size() const { return min({ get<Is>(iterables).size()... }); }
    };
    return iterable_wrapper{ forward<T>(iterables) };
}
template<class ...Cs, class = tuple<decltype(begin(declval<Cs>()))...>>
constexpr auto zip(Cs&& ...cs) {
    return zip(index_sequence_for<Cs...>{}, tuple<Cs...>(forward<Cs>(cs)...), forward<Cs>(cs)...);
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto enumerate(T&& iterable) {
    return zip(range(iterable.size()), forward<T>(iterable));
}

template<size_t ...Is, typename T> auto getis(const T& t) { return tie(get<Is>(t)...); }
template<class T> void setmax(T& a, const T& b) { a = max(a, b); }
template<class T> void setmin(T& a, const T& b) { a = min(a, b); }

template<typename T> struct is_const_char_arr_ref : false_type {};
template<size_t N> struct is_const_char_arr_ref<char const (&)[N]> : true_type {};
template<typename T, typename = void> struct is_container : false_type {};
template<typename T>
struct is_container<T, conditional_t<false, decltype(begin(declval<T>())), void>> : true_type {};
template<class T> using IsC = typename enable_if<is_container<T>::value and
    not is_same<T, string>::value>::type;
template<class T> using NotC = typename enable_if<not is_container<T>::value or
    is_same<T, string>::value>::type;
template<class T> inline IsC<T> print_1(const T& v);
template<class T> inline NotC<T> print_1(const T& x) { cout << x; }
template<size_t N> void print_1(const array<char, N>& x) { cout << &x[0]; };
inline void print_1(const tuple<>&) { cout << ""()""; };
template<size_t L, size_t I, class T> void print_tuple(const T& t) {
    if(I != 0) cout << "", ""; print_1(get<I>(t));
    if(I + 1 < L) print_tuple<L, (I + 1) % L>(t);
}
template<class ...T> inline void print_1(const tuple<T...>& x) {
    cout << ""(""; print_tuple<sizeof...(T), 0, tuple<T...>>(x); cout << "")""; }
inline void print_n() {}
template<class T, class ...U> inline void print_n(const T& head, const U&... tail);
template<class T, class U> inline void print_1(const pair<T, U>& p) {
    cout << ""(""; print_1(p.first); cout << "", ""; print_1(p.second); cout << "")""; }
template<class T, class ...U> inline void print_n(const T& head, const U&... tail) {
    print_1(head); if(sizeof...(tail)) cout << "" ""; print_n(tail...); }
template<class T> inline IsC<T> print_1(const T& v) {
    cout << ""["";
    for(auto it = v.begin(); it != v.end(); ++it) { if(it != v.begin()) cout << "", ""; print_1(*it); }
    cout << ""]"";
}
template<class ...T> inline void print(const T& ...args) { print_n(args...); putchar('\n'); }
inline void read() {}
template<class T, class ...U> inline void read(T& head, U&... tail) { cin >> head; read(tail...); }

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
static int fastio = [](){ ios_base::sync_with_stdio(false); cin.tie(0); cout.precision(17); return 0; }();

template<class T> void print_dbg(const string& s, T&& x) {
    if(is_const_char_arr_ref<T>::value) { print_n(x); } else { print_n(s, ""="", x); } }
#define SELECT(_1, _2, _3, _4, _5, _6, _7, _8, NAME,...) NAME
#define dbg1(a) print_dbg(#a, a); cout << endl;
#define dbg2(a, b) print_dbg(#a, a); cout << "", ""; dbg1(b);
#define dbg3(a, b, c) print_dbg(#a, a); cout << "", ""; dbg2(b, c);
#define dbg4(a, b, c, d) print_dbg(#a, a); cout << "", ""; dbg3(b, c, d);
#define dbg5(a, b, c, d, e) print_dbg(#a, a); cout << "", ""; dbg4(b, c, d, e);
#define dbg6(a, b, c, d, e, f) print_dbg(#a, a); cout << "", ""; dbg5(b, c, d, e, f);
#define dbg7(a, b, c, d, e, f, g) print_dbg(#a, a); cout << "", ""; dbg6(b, c, d, e, f, g);
#define dbg8(a, b, c, d, e, f, g, h) print_dbg(#a, a); cout << "", ""; dbg7(b, c, d, e, f, g, h);
#define debug(...) SELECT(__VA_ARGS__, dbg8, dbg7, dbg6, dbg5, dbg4, dbg3, dbg2, dbg1)(__VA_ARGS__)
//}}}
using PII = pair<int, int>;
using LL = long long;

const int MAX_N = 55;

struct MaxMatch {//{{{
    vector<vector<int>> G;
    vector<int> match;
    vector<char> used;

    MaxMatch(int V) {
        G.resize(V + 1);
        match.resize(V + 1);
        used.resize(V + 1);
    }

    void clear() {
        for(auto& es : G) {
            es.clear();
        }
    }

    void add(int u, int v) {
        G[u].push_back(v);
        G[v].push_back(u);
    }

    bool dfs(int v) {
        used[v] = true;
        for(int i = 0; i < (int)G[v].size(); i++) {
            int u = G[v][i], w = match[u];
            if(w < 0 or (not used[w] and dfs(w))) {
                match[v] = u;
                match[u] = v;
                return true;
            }
        }
        return false;
    }

    int solve() {
        int res = 0;
        fill(match.begin(), match.end(), -1);
        for(int v = 0; v < int(G.size()); v++) {
            if(match[v] < 0) {
                fill(used.begin(), used.end(), false);
                if(dfs(v)) {
                    ++res;
                }
            }
        }
        return res;
    }
};//}}}

auto mm = MaxMatch(MAX_N * 2);
int ans[MAX_N][MAX_N];

struct Solution {
    int N, K;
    void solve(int i) {
        mm.clear();
        for(int r = 0; r < N; ++r) {
            if(ans[r][r] == i) continue;
            for(int c = 0; c < N; ++c) {
                if(ans[c][c] == i or ans[r][c] != 0) continue;
                mm.add(r, N + c);
            }
        }
        mm.solve();
        for(int r = 0; r < N; ++r) {
            if(ans[r][r] != i) {
                int c = mm.match[r] - N;
                ans[r][c] = i;
            }
        }
    }

    Solution(int) {
        read(N, K);
        //int _K = K;
        vector<int> diag(N, 1);
        if(N == 2) {
            if(K == 3) {
                print(""IMPOSSIBLE"");
                return;
            }
            diag = { K / 2, K / 2};
        } else if(N == 3) {
            if(K == 4 or K == 5 or K == 7 or K == 8) {
                print(""IMPOSSIBLE"");
                return;
            }
            diag = { K / 3, K / 3, K / 3 };
        } else {
            if(K == N + 1 or K == N * N - 1) {
                print(""IMPOSSIBLE"");
                return;
            }
            if(K <= N * 2 + (N - 2)) {
                K -= N;
                while(K > 0) {
                    diag[K & 1] += 1;
                    --K;
                }
            } else {
                K -= N * 2 + (N - 2);
                diag[N - 2] = diag[N - 1] = N;
                while(K > 0) {
                    diag[K % (N - 2)] += 1;
                    --K;
                }
            }
        }

        memset(ans, 0, sizeof(ans));
        for(int i : range(N)) {
            ans[i][i] = diag[i];
        }

        vector<bool> done(N, false);
        for(int i : range(N)) {
            if(not done[diag[i]]) {
                solve(diag[i]);
                done[diag[i]] = true;
            }
        }
        for(int i : range(1, N + 1)) {
            if(not done[i]) solve(i);
        }

        print(""POSSIBLE"");
        for(int i : range(N)) {
            for(int j : printer(range(N))) {
                print_n(ans[i][j]);
            }
        }
    }
};

int main() {
    int T;
    cin >> T;
    for(int i = 1; i <= T; ++i) {
        cout << ""Case #"" << i << "": "";
        ignore = Solution(i);
    }
    return 0;
}
",000000000021722f.CPP,000000000019fd27,000000000021722f,0000000000209aa0,zzxzxzzxz,2020
72,000000000021217e,"//{{{
#pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O2"")
#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")

#include <bits/stdc++.h>
using namespace std;

#define putchar(x) cout << (x)
#define repeat(x) int _ = 0; _ < (x); ++_

template<typename T> constexpr auto range(T start, T stop, T step) {
    struct iterator {
        using difference_type = T;
        using value_type = T;
        using pointer = T*;
        using reference = T&;
        using iterator_category = random_access_iterator_tag;

        T i, step;
        T operator-(const iterator& other) const { return i - other.i; };
        bool operator!=(const iterator& other) const { return i != other.i; }
        auto& operator+=(const int& n) { i += step * n; return *this; }
        auto& operator++() { i += step; return *this; }
        auto& operator*() { return i; }
    };
    struct iterable_wrapper {
        T start, stop, step;
        auto begin() const { return iterator{ start, step }; }
        auto end() const { return iterator{ stop, step }; }
        size_t size() const { return (stop - start) / step; }

        iterable_wrapper(T start_, T stop_, T step_): start(start_), stop(stop_), step(step_) {
            stop = step > 0 ? max(start, stop) : min(start, stop);
            stop += (step - (stop - start) % step) % step;
        }
    };
    return iterable_wrapper(start, stop, step);
};
template<typename T> constexpr auto range(T start, T stop) { return range(start, stop, T(1)); }
template<typename T> constexpr auto range(T stop) { return range(T(0), stop, T(1)); }

template<typename T, typename Iter = decltype(rbegin(declval<T>()))>
constexpr auto reversed(T&& iterable) {
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return std::rbegin(iterable); }
        auto end() const { return std::rend(iterable); }
        auto size() const { return iterable.size(); }
    };
    return iterable_wrapper{ forward<T>(iterable) };
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto printer(T&& iterable) {
    struct iterator {
        Iter iter, ed;
        auto operator!=(const iterator& other) const {
            auto ret = (iter != other.iter);
            if(not ret) cout << '\n';
            return ret;
        }
        auto& operator++() { ++iter; if(iter != ed) cout << ' '; return *this; }
        auto& operator*() { return *iter; }
    };
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return iterator{ std::begin(iterable), std::end(iterable) }; }
        auto end() const { return iterator{ std::end(iterable), std::end(iterable) }; }
    };
    return iterable_wrapper{ forward<T>(iterable) };
};

template<class ...T> void absorb(T&& ...) {}
template<size_t L, size_t I, class T>
bool zip_it_ne(const T& it1, const T& it2) {
    if(not (get<I>(it1) != get<I>(it2))) return false;
    if(I + 1 == L) return true;
    return zip_it_ne<L, (I + 1) % L, T>(it1, it2);
}
template<size_t ...Is, class T, class ...Cs,
    class Iter = tuple<decltype(begin(declval<Cs>()))...>,
    class Ref = tuple<decltype(*begin(declval<Cs>()))&...>
    >
constexpr auto zip(index_sequence<Is...>, T&& iterables, Cs&&...) {
    struct iterator {
        Iter iter;
        unique_ptr<Ref> tref = nullptr;
        bool operator!=(const iterator& other) const {
            return zip_it_ne<sizeof...(Is), 0, Iter>(iter, other.iter);
        }
        auto& operator++() { absorb(++get<Is>(iter)...); return *this; }
        auto& operator*() { tref.reset(new Ref(tie(*get<Is>(iter)...))); return *tref; }
    };
    struct iterable_wrapper {
        T iterables;
        auto begin() const { return iterator { Iter{ std::begin(get<Is>(iterables))... } }; }
        auto end() const { return iterator { Iter{ std::end(get<Is>(iterables))... } }; }
        auto size() const { return min({ get<Is>(iterables).size()... }); }
    };
    return iterable_wrapper{ forward<T>(iterables) };
}
template<class ...Cs, class = tuple<decltype(begin(declval<Cs>()))...>>
constexpr auto zip(Cs&& ...cs) {
    return zip(index_sequence_for<Cs...>{}, tuple<Cs...>(forward<Cs>(cs)...), forward<Cs>(cs)...);
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto enumerate(T&& iterable) {
    return zip(range(iterable.size()), forward<T>(iterable));
}

template<size_t ...Is, typename T> auto getis(const T& t) { return tie(get<Is>(t)...); }
template<class T> void setmax(T& a, const T& b) { a = max(a, b); }
template<class T> void setmin(T& a, const T& b) { a = min(a, b); }

template<typename T> struct is_const_char_arr_ref : false_type {};
template<size_t N> struct is_const_char_arr_ref<char const (&)[N]> : true_type {};
template<typename T, typename = void> struct is_container : false_type {};
template<typename T>
struct is_container<T, conditional_t<false, decltype(begin(declval<T>())), void>> : true_type {};
template<class T> using IsC = typename enable_if<is_container<T>::value and
    not is_same<T, string>::value>::type;
template<class T> using NotC = typename enable_if<not is_container<T>::value or
    is_same<T, string>::value>::type;
template<class T> inline IsC<T> print_1(const T& v);
template<class T> inline NotC<T> print_1(const T& x) { cout << x; }
template<size_t N> void print_1(const array<char, N>& x) { cout << &x[0]; };
inline void print_1(const tuple<>&) { cout << ""()""; };
template<size_t L, size_t I, class T> void print_tuple(const T& t) {
    if(I != 0) cout << "", ""; print_1(get<I>(t));
    if(I + 1 < L) print_tuple<L, (I + 1) % L>(t);
}
template<class ...T> inline void print_1(const tuple<T...>& x) {
    cout << ""(""; print_tuple<sizeof...(T), 0, tuple<T...>>(x); cout << "")""; }
inline void print_n() {}
template<class T, class ...U> inline void print_n(const T& head, const U&... tail);
template<class T, class U> inline void print_1(const pair<T, U>& p) {
    cout << ""(""; print_1(p.first); cout << "", ""; print_1(p.second); cout << "")""; }
template<class T, class ...U> inline void print_n(const T& head, const U&... tail) {
    print_1(head); if(sizeof...(tail)) cout << "" ""; print_n(tail...); }
template<class T> inline IsC<T> print_1(const T& v) {
    cout << ""["";
    for(auto it = v.begin(); it != v.end(); ++it) { if(it != v.begin()) cout << "", ""; print_1(*it); }
    cout << ""]"";
}
template<class ...T> inline void print(const T& ...args) { print_n(args...); putchar('\n'); }
inline void read() {}
template<class T, class ...U> inline void read(T& head, U&... tail) { cin >> head; read(tail...); }

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
static int fastio = [](){ ios_base::sync_with_stdio(false); cin.tie(0); cout.precision(17); return 0; }();

template<class T> void print_dbg(const string& s, T&& x) {
    if(is_const_char_arr_ref<T>::value) { print_n(x); } else { print_n(s, ""="", x); } }
#define SELECT(_1, _2, _3, _4, _5, _6, _7, _8, NAME,...) NAME
#define dbg1(a) print_dbg(#a, a); cout << endl;
#define dbg2(a, b) print_dbg(#a, a); cout << "", ""; dbg1(b);
#define dbg3(a, b, c) print_dbg(#a, a); cout << "", ""; dbg2(b, c);
#define dbg4(a, b, c, d) print_dbg(#a, a); cout << "", ""; dbg3(b, c, d);
#define dbg5(a, b, c, d, e) print_dbg(#a, a); cout << "", ""; dbg4(b, c, d, e);
#define dbg6(a, b, c, d, e, f) print_dbg(#a, a); cout << "", ""; dbg5(b, c, d, e, f);
#define dbg7(a, b, c, d, e, f, g) print_dbg(#a, a); cout << "", ""; dbg6(b, c, d, e, f, g);
#define dbg8(a, b, c, d, e, f, g, h) print_dbg(#a, a); cout << "", ""; dbg7(b, c, d, e, f, g, h);
#define debug(...) SELECT(__VA_ARGS__, dbg8, dbg7, dbg6, dbg5, dbg4, dbg3, dbg2, dbg1)(__VA_ARGS__)
//}}}
using PII = pair<int, int>;
using LL = long long;

const int MOD = 1e9 + 7;
const int INF = 0x3f3f3f3f;
const LL LLINF = 0x3f3f3f3f3f3f3f3f;
const int MAX_N = 300005;

struct Solution {
    Solution(int) {
        int N;
        read(N);
        vector<pair<int, int>> act(N);
        for(int i : range(N)) {
            int s, e;
            read(s, e);
            act[i] = {s, e};
        }
        vector<int> idx(N);
        iota(idx.begin(), idx.end(), 0);
        sort(idx.begin(), idx.end(), [&](int i, int j) { return act[i] < act[j]; });

        vector<int> C, J;
        for(int i : range(N)) {
            if(C.empty() or act[idx[i]].first >= act[C.back()].second) {
                C.push_back(idx[i]);
            } else {
                J.push_back(idx[i]);
            }
        }

        for(int i : range(1, int(J.size()))) {
            if(act[J[i]].first < act[J[i - 1]].second) {
                print(""IMPOSSIBLE"");
                return;
            }
        }
        sort(C.begin(), C.end());
        sort(J.begin(), J.end());

        string ans;
        size_t c = 0, j = 0;
        for(int i = 0; i < N; ++i) {
            if(c < C.size() and C[c] == i) {
                ans.push_back('C');
                ++c;
            } else {
                ans.push_back('J');
                ++j;
            }
        }
        print(ans);
    }
};

int main() {
    int T;
    cin >> T;
    for(int i = 1; i <= T; ++i) {
        cout << ""Case #"" << i << "": "";
        ignore = Solution(i);
    }
    return 0;
}
",000000000021217e.CPP,000000000019fd27,000000000021217e,000000000020bdf9,zzxzxzzxz,2020
73,0000000000211159,"//{{{
#pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O2"")
#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")

#include <bits/stdc++.h>
using namespace std;

#define putchar(x) cout << (x)
#define repeat(x) int _ = 0; _ < (x); ++_

template<typename T> constexpr auto range(T start, T stop, T step) {
    struct iterator {
        using difference_type = T;
        using value_type = T;
        using pointer = T*;
        using reference = T&;
        using iterator_category = random_access_iterator_tag;

        T i, step;
        T operator-(const iterator& other) const { return i - other.i; };
        bool operator!=(const iterator& other) const { return i != other.i; }
        auto& operator+=(const int& n) { i += step * n; return *this; }
        auto& operator++() { i += step; return *this; }
        auto& operator*() { return i; }
    };
    struct iterable_wrapper {
        T start, stop, step;
        auto begin() const { return iterator{ start, step }; }
        auto end() const { return iterator{ stop, step }; }
        size_t size() const { return (stop - start) / step; }

        iterable_wrapper(T start_, T stop_, T step_): start(start_), stop(stop_), step(step_) {
            stop = step > 0 ? max(start, stop) : min(start, stop);
            stop += (step - (stop - start) % step) % step;
        }
    };
    return iterable_wrapper(start, stop, step);
};
template<typename T> constexpr auto range(T start, T stop) { return range(start, stop, T(1)); }
template<typename T> constexpr auto range(T stop) { return range(T(0), stop, T(1)); }

template<typename T, typename Iter = decltype(rbegin(declval<T>()))>
constexpr auto reversed(T&& iterable) {
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return std::rbegin(iterable); }
        auto end() const { return std::rend(iterable); }
        auto size() const { return iterable.size(); }
    };
    return iterable_wrapper{ forward<T>(iterable) };
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto printer(T&& iterable) {
    struct iterator {
        Iter iter, ed;
        auto operator!=(const iterator& other) const {
            auto ret = (iter != other.iter);
            if(not ret) cout << '\n';
            return ret;
        }
        auto& operator++() { ++iter; if(iter != ed) cout << ' '; return *this; }
        auto& operator*() { return *iter; }
    };
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return iterator{ std::begin(iterable), std::end(iterable) }; }
        auto end() const { return iterator{ std::end(iterable), std::end(iterable) }; }
    };
    return iterable_wrapper{ forward<T>(iterable) };
};

template<class ...T> void absorb(T&& ...) {}
template<size_t L, size_t I, class T>
bool zip_it_ne(const T& it1, const T& it2) {
    if(not (get<I>(it1) != get<I>(it2))) return false;
    if(I + 1 == L) return true;
    return zip_it_ne<L, (I + 1) % L, T>(it1, it2);
}
template<size_t ...Is, class T, class ...Cs,
    class Iter = tuple<decltype(begin(declval<Cs>()))...>,
    class Ref = tuple<decltype(*begin(declval<Cs>()))&...>
    >
constexpr auto zip(index_sequence<Is...>, T&& iterables, Cs&&...) {
    struct iterator {
        Iter iter;
        unique_ptr<Ref> tref = nullptr;
        bool operator!=(const iterator& other) const {
            return zip_it_ne<sizeof...(Is), 0, Iter>(iter, other.iter);
        }
        auto& operator++() { absorb(++get<Is>(iter)...); return *this; }
        auto& operator*() { tref.reset(new Ref(tie(*get<Is>(iter)...))); return *tref; }
    };
    struct iterable_wrapper {
        T iterables;
        auto begin() const { return iterator { Iter{ std::begin(get<Is>(iterables))... } }; }
        auto end() const { return iterator { Iter{ std::end(get<Is>(iterables))... } }; }
        auto size() const { return min({ get<Is>(iterables).size()... }); }
    };
    return iterable_wrapper{ forward<T>(iterables) };
}
template<class ...Cs, class = tuple<decltype(begin(declval<Cs>()))...>>
constexpr auto zip(Cs&& ...cs) {
    return zip(index_sequence_for<Cs...>{}, tuple<Cs...>(forward<Cs>(cs)...), forward<Cs>(cs)...);
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto enumerate(T&& iterable) {
    return zip(range(iterable.size()), forward<T>(iterable));
}

template<size_t ...Is, typename T> auto getis(const T& t) { return tie(get<Is>(t)...); }
template<class T> void setmax(T& a, const T& b) { a = max(a, b); }
template<class T> void setmin(T& a, const T& b) { a = min(a, b); }

template<typename T> struct is_const_char_arr_ref : false_type {};
template<size_t N> struct is_const_char_arr_ref<char const (&)[N]> : true_type {};
template<typename T, typename = void> struct is_container : false_type {};
template<typename T>
struct is_container<T, conditional_t<false, decltype(begin(declval<T>())), void>> : true_type {};
template<class T> using IsC = typename enable_if<is_container<T>::value and
    not is_same<T, string>::value>::type;
template<class T> using NotC = typename enable_if<not is_container<T>::value or
    is_same<T, string>::value>::type;
template<class T> inline IsC<T> print_1(const T& v);
template<class T> inline NotC<T> print_1(const T& x) { cout << x; }
template<size_t N> void print_1(const array<char, N>& x) { cout << &x[0]; };
inline void print_1(const tuple<>&) { cout << ""()""; };
template<size_t L, size_t I, class T> void print_tuple(const T& t) {
    if(I != 0) cout << "", ""; print_1(get<I>(t));
    if(I + 1 < L) print_tuple<L, (I + 1) % L>(t);
}
template<class ...T> inline void print_1(const tuple<T...>& x) {
    cout << ""(""; print_tuple<sizeof...(T), 0, tuple<T...>>(x); cout << "")""; }
inline void print_n() {}
template<class T, class ...U> inline void print_n(const T& head, const U&... tail);
template<class T, class U> inline void print_1(const pair<T, U>& p) {
    cout << ""(""; print_1(p.first); cout << "", ""; print_1(p.second); cout << "")""; }
template<class T, class ...U> inline void print_n(const T& head, const U&... tail) {
    print_1(head); if(sizeof...(tail)) cout << "" ""; print_n(tail...); }
template<class T> inline IsC<T> print_1(const T& v) {
    cout << ""["";
    for(auto it = v.begin(); it != v.end(); ++it) { if(it != v.begin()) cout << "", ""; print_1(*it); }
    cout << ""]"";
}
template<class ...T> inline void print(const T& ...args) { print_n(args...); putchar('\n'); }
inline void read() {}
template<class T, class ...U> inline void read(T& head, U&... tail) { cin >> head; read(tail...); }

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
static int fastio = [](){ ios_base::sync_with_stdio(false); cin.tie(0); cout.precision(17); return 0; }();

template<class T> void print_dbg(const string& s, T&& x) {
    if(is_const_char_arr_ref<T>::value) { print_n(x); } else { print_n(s, ""="", x); } }
#define SELECT(_1, _2, _3, _4, _5, _6, _7, _8, NAME,...) NAME
#define dbg1(a) print_dbg(#a, a); cout << endl;
#define dbg2(a, b) print_dbg(#a, a); cout << "", ""; dbg1(b);
#define dbg3(a, b, c) print_dbg(#a, a); cout << "", ""; dbg2(b, c);
#define dbg4(a, b, c, d) print_dbg(#a, a); cout << "", ""; dbg3(b, c, d);
#define dbg5(a, b, c, d, e) print_dbg(#a, a); cout << "", ""; dbg4(b, c, d, e);
#define dbg6(a, b, c, d, e, f) print_dbg(#a, a); cout << "", ""; dbg5(b, c, d, e, f);
#define dbg7(a, b, c, d, e, f, g) print_dbg(#a, a); cout << "", ""; dbg6(b, c, d, e, f, g);
#define dbg8(a, b, c, d, e, f, g, h) print_dbg(#a, a); cout << "", ""; dbg7(b, c, d, e, f, g, h);
#define debug(...) SELECT(__VA_ARGS__, dbg8, dbg7, dbg6, dbg5, dbg4, dbg3, dbg2, dbg1)(__VA_ARGS__)
//}}}
using PII = pair<int, int>;
using LL = long long;

const int MOD = 1e9 + 7;
const int INF = 0x3f3f3f3f;
const LL LLINF = 0x3f3f3f3f3f3f3f3f;
const int MAX_N = 300005;

struct Solution {
    Solution(int) {
        string s;
        read(s);
        int n = s.size();
        int cur = 0;
        string ans;
        for(int i : range(n)) {
            while(cur < s[i] - '0') {
                ans.push_back('(');
                ++cur;
            }
            while(cur > s[i] - '0') {
                ans.push_back(')');
                --cur;
            }
            ans.push_back(s[i]);
        }
        while(cur > 0) {
            ans.push_back(')');
            --cur;
        }
        print(ans);
    }
};

int main() {
    int T;
    cin >> T;
    for(int i = 1; i <= T; ++i) {
        cout << ""Case #"" << i << "": "";
        ignore = Solution(i);
    }
    return 0;
}
",0000000000211159.CPP,000000000019fd27,0000000000211159,0000000000209a9f,zzxzxzzxz,2020
74,0000000000210d1c,"//{{{
#pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O2"")
#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")

#include <bits/stdc++.h>
using namespace std;

#define putchar(x) cout << (x)
#define repeat(x) int _ = 0; _ < (x); ++_

template<typename T> constexpr auto range(T start, T stop, T step) {
    struct iterator {
        using difference_type = T;
        using value_type = T;
        using pointer = T*;
        using reference = T&;
        using iterator_category = random_access_iterator_tag;

        T i, step;
        T operator-(const iterator& other) const { return i - other.i; };
        bool operator!=(const iterator& other) const { return i != other.i; }
        auto& operator+=(const int& n) { i += step * n; return *this; }
        auto& operator++() { i += step; return *this; }
        auto& operator*() { return i; }
    };
    struct iterable_wrapper {
        T start, stop, step;
        auto begin() const { return iterator{ start, step }; }
        auto end() const { return iterator{ stop, step }; }
        size_t size() const { return (stop - start) / step; }

        iterable_wrapper(T start_, T stop_, T step_): start(start_), stop(stop_), step(step_) {
            stop = step > 0 ? max(start, stop) : min(start, stop);
            stop += (step - (stop - start) % step) % step;
        }
    };
    return iterable_wrapper(start, stop, step);
};
template<typename T> constexpr auto range(T start, T stop) { return range(start, stop, T(1)); }
template<typename T> constexpr auto range(T stop) { return range(T(0), stop, T(1)); }

template<typename T, typename Iter = decltype(rbegin(declval<T>()))>
constexpr auto reversed(T&& iterable) {
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return std::rbegin(iterable); }
        auto end() const { return std::rend(iterable); }
        auto size() const { return iterable.size(); }
    };
    return iterable_wrapper{ forward<T>(iterable) };
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto printer(T&& iterable) {
    struct iterator {
        Iter iter, ed;
        auto operator!=(const iterator& other) const {
            auto ret = (iter != other.iter);
            if(not ret) cout << '\n';
            return ret;
        }
        auto& operator++() { ++iter; if(iter != ed) cout << ' '; return *this; }
        auto& operator*() { return *iter; }
    };
    struct iterable_wrapper {
        T iterable;
        auto begin() const { return iterator{ std::begin(iterable), std::end(iterable) }; }
        auto end() const { return iterator{ std::end(iterable), std::end(iterable) }; }
    };
    return iterable_wrapper{ forward<T>(iterable) };
};

template<class ...T> void absorb(T&& ...) {}
template<size_t L, size_t I, class T>
bool zip_it_ne(const T& it1, const T& it2) {
    if(not (get<I>(it1) != get<I>(it2))) return false;
    if(I + 1 == L) return true;
    return zip_it_ne<L, (I + 1) % L, T>(it1, it2);
}
template<size_t ...Is, class T, class ...Cs,
    class Iter = tuple<decltype(begin(declval<Cs>()))...>,
    class Ref = tuple<decltype(*begin(declval<Cs>()))&...>
    >
constexpr auto zip(index_sequence<Is...>, T&& iterables, Cs&&...) {
    struct iterator {
        Iter iter;
        unique_ptr<Ref> tref = nullptr;
        bool operator!=(const iterator& other) const {
            return zip_it_ne<sizeof...(Is), 0, Iter>(iter, other.iter);
        }
        auto& operator++() { absorb(++get<Is>(iter)...); return *this; }
        auto& operator*() { tref.reset(new Ref(tie(*get<Is>(iter)...))); return *tref; }
    };
    struct iterable_wrapper {
        T iterables;
        auto begin() const { return iterator { Iter{ std::begin(get<Is>(iterables))... } }; }
        auto end() const { return iterator { Iter{ std::end(get<Is>(iterables))... } }; }
        auto size() const { return min({ get<Is>(iterables).size()... }); }
    };
    return iterable_wrapper{ forward<T>(iterables) };
}
template<class ...Cs, class = tuple<decltype(begin(declval<Cs>()))...>>
constexpr auto zip(Cs&& ...cs) {
    return zip(index_sequence_for<Cs...>{}, tuple<Cs...>(forward<Cs>(cs)...), forward<Cs>(cs)...);
}

template<typename T, typename Iter = decltype(begin(declval<T>()))>
constexpr auto enumerate(T&& iterable) {
    return zip(range(iterable.size()), forward<T>(iterable));
}

template<size_t ...Is, typename T> auto getis(const T& t) { return tie(get<Is>(t)...); }
template<class T> void setmax(T& a, const T& b) { a = max(a, b); }
template<class T> void setmin(T& a, const T& b) { a = min(a, b); }

template<typename T> struct is_const_char_arr_ref : false_type {};
template<size_t N> struct is_const_char_arr_ref<char const (&)[N]> : true_type {};
template<typename T, typename = void> struct is_container : false_type {};
template<typename T>
struct is_container<T, conditional_t<false, decltype(begin(declval<T>())), void>> : true_type {};
template<class T> using IsC = typename enable_if<is_container<T>::value and
    not is_same<T, string>::value>::type;
template<class T> using NotC = typename enable_if<not is_container<T>::value or
    is_same<T, string>::value>::type;
template<class T> inline IsC<T> print_1(const T& v);
template<class T> inline NotC<T> print_1(const T& x) { cout << x; }
template<size_t N> void print_1(const array<char, N>& x) { cout << &x[0]; };
inline void print_1(const tuple<>&) { cout << ""()""; };
template<size_t L, size_t I, class T> void print_tuple(const T& t) {
    if(I != 0) cout << "", ""; print_1(get<I>(t));
    if(I + 1 < L) print_tuple<L, (I + 1) % L>(t);
}
template<class ...T> inline void print_1(const tuple<T...>& x) {
    cout << ""(""; print_tuple<sizeof...(T), 0, tuple<T...>>(x); cout << "")""; }
inline void print_n() {}
template<class T, class ...U> inline void print_n(const T& head, const U&... tail);
template<class T, class U> inline void print_1(const pair<T, U>& p) {
    cout << ""(""; print_1(p.first); cout << "", ""; print_1(p.second); cout << "")""; }
template<class T, class ...U> inline void print_n(const T& head, const U&... tail) {
    print_1(head); if(sizeof...(tail)) cout << "" ""; print_n(tail...); }
template<class T> inline IsC<T> print_1(const T& v) {
    cout << ""["";
    for(auto it = v.begin(); it != v.end(); ++it) { if(it != v.begin()) cout << "", ""; print_1(*it); }
    cout << ""]"";
}
template<class ...T> inline void print(const T& ...args) { print_n(args...); putchar('\n'); }
inline void read() {}
template<class T, class ...U> inline void read(T& head, U&... tail) { cin >> head; read(tail...); }

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
static int fastio = [](){ ios_base::sync_with_stdio(false); cin.tie(0); cout.precision(17); return 0; }();

template<class T> void print_dbg(const string& s, T&& x) {
    if(is_const_char_arr_ref<T>::value) { print_n(x); } else { print_n(s, ""="", x); } }
#define SELECT(_1, _2, _3, _4, _5, _6, _7, _8, NAME,...) NAME
#define dbg1(a) print_dbg(#a, a); cout << endl;
#define dbg2(a, b) print_dbg(#a, a); cout << "", ""; dbg1(b);
#define dbg3(a, b, c) print_dbg(#a, a); cout << "", ""; dbg2(b, c);
#define dbg4(a, b, c, d) print_dbg(#a, a); cout << "", ""; dbg3(b, c, d);
#define dbg5(a, b, c, d, e) print_dbg(#a, a); cout << "", ""; dbg4(b, c, d, e);
#define dbg6(a, b, c, d, e, f) print_dbg(#a, a); cout << "", ""; dbg5(b, c, d, e, f);
#define dbg7(a, b, c, d, e, f, g) print_dbg(#a, a); cout << "", ""; dbg6(b, c, d, e, f, g);
#define dbg8(a, b, c, d, e, f, g, h) print_dbg(#a, a); cout << "", ""; dbg7(b, c, d, e, f, g, h);
#define debug(...) SELECT(__VA_ARGS__, dbg8, dbg7, dbg6, dbg5, dbg4, dbg3, dbg2, dbg1)(__VA_ARGS__)
//}}}
using PII = pair<int, int>;
using LL = long long;

const int MAX_N = 105;

struct Solution {
    Solution(int) {
        int N;
        read(N);
        int trace = 0;
        vector<vector<int>> row(N, vector<int>(N, 0)), col(N, vector<int>(N, 0));
        for(int i : range(N)) {
            for(int j : range(N)) {
                int a = 0;
                read(a);
                if(i == j) trace += a;
                ++row[i][a - 1];
                ++col[j][a - 1];
            }
        }
        int rr = 0, rc = 0;
        for(int i : range(N)) {
            for(int k : range(N)) {
                if(row[i][k] >= 2) {
                    ++rr;
                    break;
                }
            }
        }
        for(int i : range(N)) {
            for(int k : range(N)) {
                if(col[i][k] >= 2) {
                    ++rc;
                    break;
                }
            }
        }
        print(trace, rr, rc);
    }
};

int main() {
    int T;
    cin >> T;
    for(int i = 1; i <= T; ++i) {
        cout << ""Case #"" << i << "": "";
        ignore = Solution(i);
    }
    return 0;
}
",0000000000210d1c.CPP,000000000019fd27,0000000000210d1c,000000000020993c,zzxzxzzxz,2020
75,000000000021dcde,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define oset(T) tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>
using namespace std;
using namespace __gnu_pbds;
typedef long long ll;
typedef vector<int> vi;
typedef pair<ll,ll> pl;
typedef pair<pl,ll> tl;
typedef vector<ll> vl;
typedef vector<vi> vvi;
const int MN = 55;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int ok[MN][MN];
bitset<MN> bs;
vi ord;
int oofs[3] = {7,11,13};
int pre[3][4][4] = {
	{
		{1,2,3,4},
		{3,1,4,2},
		{4,3,2,1},
		{2,4,1,3}
	},
	{
		{2,3,4,1},
		{4,2,1,3},
		{1,4,3,2},
		{3,1,2,4}
	},
	{
		{3,1,4,2},
		{2,4,1,3},
		{4,3,2,1},
		{1,2,3,4}
	}
};
class PR {
	private:
		const int INF = 1e9;
		int n;
		vi ex,h;
		vvi cap,fl;
		void push(int u, int v) {
			int d = min(ex[u],cap[u][v]-fl[u][v]);
			fl[u][v] += d;
			fl[v][u] -= d;
			ex[u] -= d;
			ex[v] += d;
		}
		void relabel(int u) {
			int d = INF;
			for(int i=0;i<n;i++) {
				if(cap[u][i]-fl[u][i] > 0) {
					d = min(d,h[i]);
				}
				if(d < INF) {
					h[u] = d+1;
				}
			}
		}
		vi max_h(int s, int t) {
			vi mh;
			for(int i=0;i<n;i++) {
				if(i != s && i != t && ex[i] > 0) {
					if(!mh.empty() && h[i] > h[mh[0]]) {
						mh.clear();
					}
					if(mh.empty() || h[i] == h[mh[0]]) {
						mh.push_back(i);
					}
				}
			}
			return mh;
		}
	public:
		PR(int _n) {
			n = _n;
			ex.assign(n,0);
			h.assign(n,0);
			cap.assign(n,vi(n,0));
		}
		void add(int u, int v, int ca) {
			cap[u][v] = ca;
		}
		int maxflow(int s, int t) {
			h.assign(n,0);
			h[s] = n;
			fl.assign(n,vi(n,0));
			ex.assign(n,0);
			ex[s] = INF;
			for(int i=0;i<n;i++) {
				if(i != s) {push(s,i);}
			}
			vi cur;
			while(!(cur = max_h(s,t)).empty()) {
				for(int i: cur) {
					bool psh = false;
					for(int j=0;j<n && ex[i];j++) {
						if(cap[i][j]-fl[i][j] > 0 && h[i] == h[j]+1) {
							push(i,j);
							psh = true;
						}
					}
					if(!psh) {relabel(i);break;}
				}
			}
			int mf = 0;
			for(int i=0;i<n;i++) {
				//mf += fl[0][i];
				mf += fl[i][t];
			}
			return mf;
		}
		int getf(int u, int v) {
			return fl[u][v];
		}
};

int main() {
	ios::sync_with_stdio(0);cin.tie(0);
	int N;
	cin >> N;
	int C = 0;
	while(N--) {
		memset(ok,-1,sizeof(ok));
		C++;
		int a,n;
		cin >> n >> a;
		bool poss =  true;
		if(n == 2) {
			if(a != 2 && a != 4) {
				poss = false;
			}
		} else if(n == 3) {
			if(a != 3 && a != 6 && a != 9) {
				poss = false;
			}
		} else {
			if(a-1 == n || a+1 == n*n) {poss = false;}
		}
		int prid = -1;
		if(n == 4) {
			for(int i=0;i<3;i++) {
				if(a == oofs[i]) {
					prid = i;break;
				}
			}
		}
		ord.clear();
		for(int i=0;i<n;i++) {
			ord.push_back(i);
		}
		cout << ""Case #"" << C << "": "";
		if(!poss) {
			cout << ""IMPOSSIBLE\n"";
			continue;
		}
		a -= n;
		set<int> oof;
		vi mg;
		if(a%n == 0) {
			for(int i=0;i<n;i++) {
				ok[i][i] = a/n;
			}
			oof.insert(a/n);
		} else {
			vi ot;
			for(int i=0;i<n;i++) {
				int ad = min(a,n-1);
				oof.insert(ad);
				a -= ad;
				ot.push_back(ad);
			}
			ot[0]--;
			ot.back()++;
			for(int i=0;i<n;i++) {
				ok[i][i] = ot[i];

			}
		}
		for(int i=0;i<n;i++) {
			mg.push_back(ok[i][i]);
		}
		int mf = n;
		while(1) {
			if(prid != -1) {break;}
			for(auto& it: oof) {
				PR lol(2*n+2);
				int s = 2*n,t = 2*n+1;
				for(int j=0;j<n;j++) {
					for(int id=0;id<n;id++) {
						int k = ord[id];
						if(ok[j][k] == -1) {
							lol.add(j,k+n,1);
						}
						if(ok[j][j] != it) {
							lol.add(s,j,1);
							lol.add(j+n,t,1);
						}
					}
				}
				mf += lol.maxflow(s,t);
				for(int j=0;j<n;j++) {
					for(int k=0;k<n;k++) {
						if(lol.getf(j,k+n) == 1) {
							ok[j][k] = it;
						}
					}
				}
			}
			for(int i=0;i<n;i++) {
				if(oof.count(i)) {continue;}
				PR lol(2*n+2);
				int s = 2*n,t = 2*n+1;
				for(int j=0;j<n;j++) {
					for(int id=0;id<n;id++) {
						int k = ord[id];
						if(ok[j][k] == -1) {
							lol.add(j,k+n,1);
						}
						if(ok[j][j] != i) {
							lol.add(s,j,1);
							lol.add(j+n,t,1);
						}
					}
				}
				mf += lol.maxflow(s,t);
				for(int j=0;j<n;j++) {
					for(int k=0;k<n;k++) {
						if(lol.getf(j,k+n) == 1) {
							ok[j][k] = i;
						}
					}
				}
			}
			if(mf == n*n) {break;}
			mf = n;
			shuffle(ord.begin(),ord.end(),rng);
			shuffle(mg.begin(),mg.end(),rng);
			memset(ok,-1,sizeof(ok));
			for(int i=0;i<mg.size();i++) {
				ok[i][i] = mg[i];
			}
		}
		if(prid != -1) {
			for(int i=0;i<4;i++) {
				for(int j=0;j<4;j++) {
					ok[i][j] = pre[prid][i][j]-1;
				}
			}
		}
		cout << ""POSSIBLE\n"";
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
				if(j > 0) {cout << "" "";}
				cout << ok[i][j]+1;
			}
			cout << '\n';
		}
	}
}
",000000000021dcde.CPP,000000000019fd27,000000000021dcde,0000000000209aa0,wwdd,2020
76,000000000021d9c4,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define oset(T) tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>
using namespace std;
using namespace __gnu_pbds;
typedef long long ll;
typedef vector<int> vi;
typedef pair<ll,ll> pl;
typedef pair<pl,ll> tl;
typedef vector<ll> vl;
typedef vector<vi> vvi;
const int MN = 55;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int ok[MN][MN];
bitset<MN> bs;
vi ord;
int oofs[3] = {7,11,13};
int pre[3][4][4] = {
	{
		{1,2,3,4},
		{3,1,4,2},
		{4,3,2,1},
		{2,4,1,3}
	},
	{
		{2,3,4,1},
		{4,2,1,3},
		{1,4,3,2},
		{3,1,2,4}
	},
	{
		{2,3,4,1},
		{4,2,1,3},
		{1,4,3,2},
		{3,1,2,4}
	}
};
class PR {
	private:
		const int INF = 1e9;
		int n;
		vi ex,h;
		vvi cap,fl;
		void push(int u, int v) {
			int d = min(ex[u],cap[u][v]-fl[u][v]);
			fl[u][v] += d;
			fl[v][u] -= d;
			ex[u] -= d;
			ex[v] += d;
		}
		void relabel(int u) {
			int d = INF;
			for(int i=0;i<n;i++) {
				if(cap[u][i]-fl[u][i] > 0) {
					d = min(d,h[i]);
				}
				if(d < INF) {
					h[u] = d+1;
				}
			}
		}
		vi max_h(int s, int t) {
			vi mh;
			for(int i=0;i<n;i++) {
				if(i != s && i != t && ex[i] > 0) {
					if(!mh.empty() && h[i] > h[mh[0]]) {
						mh.clear();
					}
					if(mh.empty() || h[i] == h[mh[0]]) {
						mh.push_back(i);
					}
				}
			}
			return mh;
		}
	public:
		PR(int _n) {
			n = _n;
			ex.assign(n,0);
			h.assign(n,0);
			cap.assign(n,vi(n,0));
		}
		void add(int u, int v, int ca) {
			cap[u][v] = ca;
		}
		int maxflow(int s, int t) {
			h.assign(n,0);
			h[s] = n;
			fl.assign(n,vi(n,0));
			ex.assign(n,0);
			ex[s] = INF;
			for(int i=0;i<n;i++) {
				if(i != s) {push(s,i);}
			}
			vi cur;
			while(!(cur = max_h(s,t)).empty()) {
				for(int i: cur) {
					bool psh = false;
					for(int j=0;j<n && ex[i];j++) {
						if(cap[i][j]-fl[i][j] > 0 && h[i] == h[j]+1) {
							push(i,j);
							psh = true;
						}
					}
					if(!psh) {relabel(i);break;}
				}
			}
			int mf = 0;
			for(int i=0;i<n;i++) {
				//mf += fl[0][i];
				mf += fl[i][t];
			}
			return mf;
		}
		int getf(int u, int v) {
			return fl[u][v];
		}
};

int main() {
	ios::sync_with_stdio(0);cin.tie(0);
	int N;
	cin >> N;
	int C = 0;
	while(N--) {
		memset(ok,-1,sizeof(ok));
		C++;
		int a,n;
		cin >> n >> a;
		bool poss =  true;
		if(n == 2) {
			if(a != 2 && a != 4) {
				poss = false;
			}
		} else if(n == 3) {
			if(a != 3 && a != 6 && a != 9) {
				poss = false;
			}
		} else {
			if(a-1 == n || a+1 == n*n) {poss = false;}
		}
		int prid = -1;
		if(n == 4) {
			for(int i=0;i<3;i++) {
				if(a == oofs[i]) {
					prid = i;break;
				}
			}
		}
		ord.clear();
		for(int i=0;i<n;i++) {
			ord.push_back(i);
		}
		cout << ""Case #"" << C << "": "";
		if(!poss) {
			cout << ""IMPOSSIBLE\n"";
			continue;
		}
		a -= n;
		set<int> oof;
		vi mg;
		if(a%n == 0) {
			for(int i=0;i<n;i++) {
				ok[i][i] = a/n;
			}
			oof.insert(a/n);
		} else {
			vi ot;
			for(int i=0;i<n;i++) {
				int ad = min(a,n-1);
				oof.insert(ad);
				a -= ad;
				ot.push_back(ad);
			}
			ot[0]--;
			ot.back()++;
			for(int i=0;i<n;i++) {
				ok[i][i] = ot[i];

			}
		}
		for(int i=0;i<n;i++) {
			mg.push_back(ok[i][i]);
		}
		int mf = n;
		while(1) {
			if(prid != -1) {break;}
			for(auto& it: oof) {
				PR lol(2*n+2);
				int s = 2*n,t = 2*n+1;
				for(int j=0;j<n;j++) {
					for(int id=0;id<n;id++) {
						int k = ord[id];
						if(ok[j][k] == -1) {
							lol.add(j,k+n,1);
						}
						if(ok[j][j] != it) {
							lol.add(s,j,1);
							lol.add(j+n,t,1);
						}
					}
				}
				mf += lol.maxflow(s,t);
				for(int j=0;j<n;j++) {
					for(int k=0;k<n;k++) {
						if(lol.getf(j,k+n) == 1) {
							ok[j][k] = it;
						}
					}
				}
			}
			for(int i=0;i<n;i++) {
				if(oof.count(i)) {continue;}
				PR lol(2*n+2);
				int s = 2*n,t = 2*n+1;
				for(int j=0;j<n;j++) {
					for(int id=0;id<n;id++) {
						int k = ord[id];
						if(ok[j][k] == -1) {
							lol.add(j,k+n,1);
						}
						if(ok[j][j] != i) {
							lol.add(s,j,1);
							lol.add(j+n,t,1);
						}
					}
				}
				mf += lol.maxflow(s,t);
				for(int j=0;j<n;j++) {
					for(int k=0;k<n;k++) {
						if(lol.getf(j,k+n) == 1) {
							ok[j][k] = i;
						}
					}
				}
			}
			if(mf == n*n) {break;}
			mf = n;
			shuffle(ord.begin(),ord.end(),rng);
			shuffle(mg.begin(),mg.end(),rng);
			memset(ok,-1,sizeof(ok));
			for(int i=0;i<mg.size();i++) {
				ok[i][i] = mg[i];
			}
		}
		if(prid != -1) {
			for(int i=0;i<4;i++) {
				for(int j=0;j<4;j++) {
					ok[i][j] = pre[prid][i][j]-1;
				}
			}
		}
		cout << ""POSSIBLE\n"";
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
				if(j > 0) {cout << "" "";}
				cout << ok[i][j]+1;
			}
			cout << '\n';
		}
	}
}
",000000000021d9c4.CPP,000000000019fd27,000000000021d9c4,0000000000209aa0,wwdd,2020
77,0000000000215edc,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> pl;
typedef pair<pl,ll> tl;
typedef vector<ll> vl;
int qu(int idx) {
	idx++;
	cout << idx << '\n';
	cout.flush();
	int res;
	cin >> res;
	return res;
}
bool ans(vl& w) {
	for(int i=0;i<w.size();i++) {
		cout << w[i];
	}
	cout << '\n';
	cout.flush();
	char res;
	cin >> res;
	return (res == 'Y');
}
int main() {
	int N;
	cin >> N;
	int n;
	cin >> n;
	while(N--) {
		vl w(n,-1);
		int sen = 0;
		int sid[2];
		int qc = 0;
		int mr = 0;
		bool lol = false;
		while(1) {
			if(qc%10 == 0) {
				int ri = 0;
				if(sen&1) {
					int a = qu(sid[0]);
					if(a != w[sid[0]]) {
						ri |= 1;
					}
					qc++;
				}
				if(sen&2) {
					int a = qu(sid[1]);
					if(a != w[sid[1]]) {
						if(!(ri&1)) {
							ri |= 2;
						}
					} else {
						if(ri&1) {
							ri |= 2;
						}
					}
					qc++;
				}
				if(ri&2) {
					reverse(w.begin(),w.end());
				}
				if(ri&1) {
					for(int i=0;i<n;i++) {
						w[i] = 1-w[i];
					}
				}
			}
			if((qc%10)+2 <= 10) {
				w[mr] = qu(mr);
				w[n-mr-1] = qu(n-mr-1);
				if(w[mr] == w[n-mr-1]) {
					sen |= 1;
					sid[0] = mr;
				} else {
					sen |= 2;
					sid[1] = mr;
				}
				mr++;
				qc += 2;
			} else {
				qu(0);
				qc++;
			}
			//cout << ""MR "" << mr << '\n';
			if(mr*2 >= w.size()) {
				lol = ans(w);
				break;
			}
		}
		if(!lol) {break;}
	}
}
",0000000000215edc.CPP,000000000019fd27,0000000000215edc,0000000000209a9e,wwdd,2020
78,0000000000211c14,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> pl;
typedef pair<pl,ll> tl;
typedef vector<ll> vl;
int main() {
	ios::sync_with_stdio(0);cin.tie(0);
	int N;
	cin >> N;
	int C = 0;
	while(N--) {
		int n;
		cin >> n;
		vector<tl> w;
		for(int i=0;i<n;i++) {
			int a,b;
			cin >> a >> b;
			w.push_back({{a,b},i});
		}
		sort(w.begin(),w.end());
		vl res(n,0);
		int rs[2] = {-1,-1};
		bool poss = true;
		for(int i=0;i<n;i++) {
			int en = w[i].first.first;
			int ex = w[i].first.second;
			int idx = w[i].second;
			if(rs[0] <= en) {
				rs[0] = ex;
				res[idx] = 0;
			} else if(rs[1] <= en) {
				rs[1] = ex;
				res[idx] = 1;
			} else {
				poss = false;
			}
		}
		C++;
		cout << ""Case #"" << C << "": "";
		if(poss) {
			for(int i=0;i<n;i++) {
				cout << (res[i]?""C"":""J"");
			}
		} else{
			cout << ""IMPOSSIBLE"";
		}
		cout << '\n';
	}
}
",0000000000211c14.CPP,000000000019fd27,0000000000211c14,000000000020bdf9,wwdd,2020
79,00000000002113b1,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int main() {
	ios::sync_with_stdio(0);cin.tie(0);
	int N;
	cin >> N;
	int C = 0;
	while(N--) {
		string s;
		cin >> s;
		int nl = 0;
		C++;
		cout << ""Case #"" << C << "": "";
		for(int i=0;i<s.size();i++) {
			int id = s[i]-'0';
			while(nl > id) {
				nl--;
				cout << ')';
			}
			while(nl < id) {
				nl++;
				cout << '(';
			}
			cout << s[i];
		}
		while(nl) {
			nl--;
			cout << ')';
		}
		cout << '\n';
	}
}
",00000000002113b1.CPP,000000000019fd27,00000000002113b1,0000000000209a9f,wwdd,2020
80,0000000000210dc1,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MN = 110;
int w[MN][MN];
int main() {
	ios::sync_with_stdio(0);cin.tie(0);
	int N;
	cin >> N;
	int C = 0;
	while(N--) {
		int n;
		cin >> n;
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
				cin >> w[i][j];
			}
		}
		int res = 0;
		for(int i=0;i<n;i++) {
			res += w[i][i];
		}
		int rr = 0;
		int rc = 0;
		for(int i=0;i<n;i++) {
			set<int> bs,bc;
			int rer = 0,rec = 0;

			for(int j=0;j<n;j++) {
				if(bs.count(w[i][j])) {
					rer = 1;
				}
				bs.insert(w[i][j]);
			}
			for(int j=0;j<n;j++) {
				if(bc.count(w[j][i])) {
					rec = 1;
				}
				bc.insert(w[j][i]);
			}
			rr += rer;
			rc += rec;
		}
		C++;
		cout << ""Case #"" << C << "": "" << res << "" "" << rr << "" "" << rc << '\n';
	}
}
",0000000000210dc1.CPP,000000000019fd27,0000000000210dc1,000000000020993c,wwdd,2020
81,000000000021dbef,"/* My Template for the Google Code Jam.
 *
 * From 2018 onwards.
 *
 * Compile: g++ -std=c++11 -lgmp -lgmpxx [-fopenmp]
 *  - I'm probably using some C++11 features.
 *
 * This code is ugly but it works - otherwise you wouldn't be reading
 * it, right?
 */

#include <bits/stdc++.h>
#include <cassert>
//#define NDEBUG

using namespace std;
typedef size_t szt;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> PLL;

template<typename T>
void read_to_vector(size_t N, std::vector<T> &v) {
  for(size_t i=0; i<N; i++) {
    T tmp;
    std::cin >> tmp;
    v.push_back(tmp);
  }
}
template<typename T>
void print_vector(const std::vector<T> &v) {
  for(auto it = v.begin(); it<v.end(); it++) {
    if(it!=v.begin())
      std::cout << "" "";
    std::cout << (*it);
  }
}

//Copy functions from TCR here.


int query(int i) {
  if (i==-1) { i = 0;}
  cout << (i+1) << endl;
  int res;
  cin >> res;
  //  cerr << ""Query "" << (i+1) << "" ans "" << res << ""\n"";
  return res;
}

int B;

//Solution:
void solve() {
  int n_prefix = 0;

  //prefixes[xy]
  // y changes if REV is done
  bitset<100> prefixes[2];

  int ask_not = -1;
  int ask_rev = -1;

  while (n_prefix*2 < B) {

    int val_not = query(ask_not); //Has this bitflipped?
    int val_rev = query(ask_rev); //Has this reversed?

    //Check current state
    if (ask_not > -1 && val_not != prefixes[0][ask_not]) {
      //Has flipped
      prefixes[0] = ~prefixes[0];
      prefixes[1] = ~prefixes[1];
    }
    if (ask_rev > -1 && val_rev != prefixes[0][ask_rev]) {
      //Has reversed
      swap(prefixes[0], prefixes[1]);
    }

    for (int xx=0; xx<4; ++xx) {

      int vala = query(n_prefix);
      int valb = query(B-n_prefix-1);

      prefixes[0][n_prefix] = vala;
      prefixes[1][n_prefix] = valb;
      
      if (vala == valb) { ask_not = n_prefix; }
      if (vala != valb) { ask_rev = n_prefix; }

      ++n_prefix;      
      
    }

    
  }

  for (int i=0; i<B/2; ++i) {
    cout << prefixes[0][i];
  }
  for (int i=B/2; i<B; ++i) {
    cout << prefixes[1][B-i-1];
  }
  cout << endl;

  char c;
  cin >> c;
  //cerr << ""Result: "" << c << ""\n"";
  if (c == 'N') { exit(0); }

}

//This is executed before any input is read.
void pre_compute() {
  
}

int main() {
  std::cout << std::setprecision(15);
  //std::cin.tie(0);
  pre_compute();
  size_t T;
  std::cin >> T;
  cin >> B;
  for(size_t i=1; i<=T; i++) {
    solve();
    
  }

  return 0;
}
",000000000021dbef.CPP,000000000019fd27,000000000021dbef,0000000000209a9e,JiK,2020
82,000000000021ae12,"/* My Template for the Google Code Jam.
 *
 * From 2018 onwards.
 *
 * Compile: g++ -std=c++11 -lgmp -lgmpxx [-fopenmp]
 *  - I'm probably using some C++11 features.
 *
 * This code is ugly but it works - otherwise you wouldn't be reading
 * it, right?
 */

#include <bits/stdc++.h>
#include <cassert>
//#define NDEBUG

using namespace std;
typedef size_t szt;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> PLL;

template<typename T>
void read_to_vector(size_t N, std::vector<T> &v) {
  for(size_t i=0; i<N; i++) {
    T tmp;
    std::cin >> tmp;
    v.push_back(tmp);
  }
}
template<typename T>
void print_vector(const std::vector<T> &v) {
  for(auto it = v.begin(); it<v.end(); it++) {
    if(it!=v.begin())
      std::cout << "" "";
    std::cout << (*it);
  }
}

//Copy functions from TCR here.


bool recursive(int N, vector<vector<int> > & sq) {
  vector<ll > valid_row (N, (1LL<<(N+1))-2);
  vector<ll > valid_col (N, (1LL<<(N+1))-2);
  for (int i=0; i<N; ++i) {
    for (int j=0; j<N; ++j) {
      valid_row[i] &= ~(1LL<<sq[i][j]);
      valid_col[j] &= ~(1LL<<sq[i][j]);
    }
  }

  int ii=-1;
  int jj=-1;
  int best = N;
  int64_t bestm = 0;
  
  for (int i=0; i<N; ++i) {
    for (int j=0; j<N; ++j) {
      if (sq[i][j]) { continue; }
      ll thism = valid_row[i] & valid_col[j];

      //      cout << i << "" "" << j << "" "" << bitset<51>(thism) << ""\n"";
      
      if (thism==0) { return false; }

      int thisc = __builtin_popcount(thism);
      if (thisc < best) {
	best = thisc;
	bestm = thism;
	ii = i;
	jj = j;
      }
    }
  }

  //  cout << ""Chosen: "" << ii << "" "" << jj << ""\n"";
  
  if (ii==-1) { return true; }
  
  for (int v=1; v<=N; ++v) {
    if (bestm & (1LL<<v)) {
      sq[ii][jj] = v;
      if (recursive(N, sq)) { return true; }
      sq[ii][jj] = 0;
    }
  }

  return false;
  
  
  
}

//Solution:
void solve() {
  int N, K;
  cin >> N >> K;

  if (K==N+1 || K==N*N-1) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }

  if (N==3 && K==5) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }
  if (N==3 && K==7) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }

  if (N==2 && K==2) {
    cout << ""POSSIBLE\n1 2\n2 1\n"";
    return;
  }
  if (N==2 && K==4) {
    cout << ""POSSIBLE\n2 1\n1 2\n"";
    return;
  }

  assert (N>2);
  
  vector<vector<int> > sq (N, vector<int>(N));

  for (int i=0; i<N; ++i) {
    for (int j=0; j<N; ++j) {
      sq[i][j] = (N+i-j)%N + 1;
    }
  }

  vector<int> perm(N+1);
  
  if (K==N) {
    iota(perm.begin(), perm.end(), 0);
  } else if (K%N==0) {
    iota(perm.begin(), perm.end(), 0);
    perm[1] = K/N;
    perm[K/N] = 1;
  } else {
    swap(sq[N-1], sq[N-2]);
    //Diag contains 1 1 ... 1 2 N

    for (int a=1; a<=N; ++a) {
      for (int b=1; b<=N;++b) {
	for (int c=b+1; c<=N; ++c) {
	  if (a==b || a==c) { continue; }
	  if ((N-2)*a + b + c == K) {

	    vector<bool> used(N+1);
	    int v = 1;
	    perm[1] = a;
	    perm[2] = b;
	    perm[N] = c;
	    used[a] = used[b] = used[c] = true;

	    for (int i=3; i<N; ++i) {
	      while (used[v]) { ++v; }
	      used[v] = true;
	      perm[i] = v;
	    }
	    goto done;
	  }
	}
      }
    }

    //Not found elements. Construct another square.

    sq = vector<vector<int> > (N, vector<int>(N, 0));

    sq[0][0] = 2;
    sq[1][1] = 2;
    sq[0][1] = 1;
    sq[1][0] = 1;

    for(int j=2; j<N; ++j) {
      sq[0][j] = j+1;
    }
    if (N%2==1) {
      swap(sq[0][N-1], sq[0][N-2]);
    }
    
    for (int i=2; i<N-1; ++i) {
      for (int j=0; j<N; ++j) {
	sq[i][j] = (N+j-i)%N + 1;
      }
    }
    

    for (int i=2; i<N; ++i) {
      sq[i][i] = 1;
    }

    bool res = recursive(N, sq);

    assert (res);
    
    for (int a=1; a<=N; ++a) {
      for (int b=1; b<=N;++b) {
	if (a==b) { continue; }
	if ((N-2)*a + 2*b == K) {

	  vector<bool> used(N+1);
	  int v = 1;
	  perm[1] = a;
	  perm[2] = b;
	  used[a] = used[b] = true;

	  for (int i=3; i<=N; ++i) {
	    while (used[v]) { ++v; }
	    used[v] = true;
	    perm[i] = v;
	  }
	  goto done;
	}
      }
    }
  }
    
  
done:

  cout << ""POSSIBLE\n"";
  for (int i=0; i<N; ++i) {
    for (int j=0; j<N; ++j) {
      if (j!=0) { cout << "" ""; }
      cout << perm[sq[i][j]];
    }
    cout << ""\n"";
  }
  
}

//This is executed before any input is read.
void pre_compute() {
  
}

int main() {
  std::cout << std::setprecision(15);
  std::cin.tie(0);
  pre_compute();
  size_t T;
  std::cin >> T;
  for(size_t i=1; i<=T; i++) {
    std::cout << ""Case #"" << i << "": "";
    solve();

  }

  return 0;
}
",000000000021ae12.CPP,000000000019fd27,000000000021ae12,0000000000209aa0,JiK,2020
83,0000000000218246,"/* My Template for the Google Code Jam.
 *
 * From 2018 onwards.
 *
 * Compile: g++ -std=c++11 -lgmp -lgmpxx [-fopenmp]
 *  - I'm probably using some C++11 features.
 *
 * This code is ugly but it works - otherwise you wouldn't be reading
 * it, right?
 */

#include <bits/stdc++.h>
#include <cassert>
//#define NDEBUG

using namespace std;
typedef size_t szt;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> PLL;

template<typename T>
void read_to_vector(size_t N, std::vector<T> &v) {
  for(size_t i=0; i<N; i++) {
    T tmp;
    std::cin >> tmp;
    v.push_back(tmp);
  }
}
template<typename T>
void print_vector(const std::vector<T> &v) {
  for(auto it = v.begin(); it<v.end(); it++) {
    if(it!=v.begin())
      std::cout << "" "";
    std::cout << (*it);
  }
}

//Copy functions from TCR here.


bool recursive(int N, vector<vector<int> > & sq,
	       int i, int j,
	       const vector<int> & diag) {
  //  cout << i << "" "" << j << endl;
  if (j>=N) {
    i++;
    j = 0;
  }
  if (i>=N) {
    return true;
  }
  
  if (i==j) {
    sq[i][j] = diag[i];
    return recursive(N, sq, i, j+1, diag);
  }

  vector<bool> valid (N+1, true);
  for (int ii=0; ii<i; ++ii) {
    valid[sq[ii][j]] = false;
  }
  for (int jj=0; jj<j; ++jj) {
    valid[sq[i][jj]] = false;
  }
  valid[diag[i]] = false;
  valid[diag[j]] = false;

  for (int v=1; v<=N; ++v) {
    if (valid[v]) {
      sq[i][j] = v;
      if (recursive(N, sq, i, j+1, diag)) { return true; }
      sq[i][j] = 0;
    }
  }

  return false;
  
  
  
}

//Solution:
void solve() {
  int N, K;
  cin >> N >> K;

  if (K==N+1 || K==N*N-1) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }

  if (N==3 && K==5) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }
  if (N==3 && K==7) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }

  if (N==2 && K==2) {
    cout << ""POSSIBLE\n1 2\n2 1\n"";
    return;
  }
  if (N==2 && K==4) {
    cout << ""POSSIBLE\n2 1\n1 2\n"";
    return;
  }

  assert (N>2);
  
  vector<vector<int> > sq (N, vector<int>(N));

  for (int i=0; i<N; ++i) {
    for (int j=0; j<N; ++j) {
      sq[i][j] = (N+i-j)%N + 1;
    }
  }

  vector<int> perm(N+1);
  
  if (K==N) {
    iota(perm.begin(), perm.end(), 0);
  } else if (K%N==0) {
    iota(perm.begin(), perm.end(), 0);
    perm[1] = K/N;
    perm[K/N] = 1;
  } else {
    swap(sq[N-1], sq[N-2]);
    //Diag contains 1 1 ... 1 2 N

    for (int a=1; a<=N; ++a) {
      for (int b=1; b<=N;++b) {
	for (int c=b+1; c<=N; ++c) {
	  if (a==b || a==c) { continue; }
	  if ((N-2)*a + b + c == K) {

	    vector<bool> used(N+1);
	    int v = 1;
	    perm[1] = a;
	    perm[2] = b;
	    perm[N] = c;
	    used[a] = used[b] = used[c] = true;

	    for (int i=3; i<N; ++i) {
	      while (used[v]) { ++v; }
	      used[v] = true;
	      perm[i] = v;
	    }
	    goto done;
	  }
	}
      }
    }

    //Not found elements. Construct another square.

    vector<int> diag (N, 1);
    diag[N-1] = 2;
    diag[N-2] = 2;
    bool res = recursive(N, sq, 0, 0, diag);

    for (int a=1; a<=N; ++a) {
      for (int b=1; b<=N;++b) {
	if (a==b) { continue; }
	if ((N-2)*a + 2*b == K) {

	  vector<bool> used(N+1);
	  int v = 1;
	  perm[1] = a;
	  perm[2] = b;
	  used[a] = used[b] = true;

	  for (int i=3; i<=N; ++i) {
	    while (used[v]) { ++v; }
	    used[v] = true;
	    perm[i] = v;
	  }
	  goto done;
	}
      }
    }
  }
    
  
done:

  cout << ""POSSIBLE\n"";
  for (int i=0; i<N; ++i) {
    for (int j=0; j<N; ++j) {
      if (j!=0) { cout << "" ""; }
      cout << perm[sq[i][j]];
    }
    cout << ""\n"";
  }
  
}

//This is executed before any input is read.
void pre_compute() {
  
}

int main() {
  std::cout << std::setprecision(15);
  std::cin.tie(0);
  pre_compute();
  size_t T;
  std::cin >> T;
  for(size_t i=1; i<=T; i++) {
    std::cout << ""Case #"" << i << "": "";
    solve();

  }

  return 0;
}
",0000000000218246.CPP,000000000019fd27,0000000000218246,0000000000209aa0,JiK,2020
84,0000000000218069,"/* My Template for the Google Code Jam.
 *
 * From 2018 onwards.
 *
 * Compile: g++ -std=c++11 -lgmp -lgmpxx [-fopenmp]
 *  - I'm probably using some C++11 features.
 *
 * This code is ugly but it works - otherwise you wouldn't be reading
 * it, right?
 */

#include <bits/stdc++.h>
#include <cassert>
//#define NDEBUG

using namespace std;
typedef size_t szt;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> PLL;

template<typename T>
void read_to_vector(size_t N, std::vector<T> &v) {
  for(size_t i=0; i<N; i++) {
    T tmp;
    std::cin >> tmp;
    v.push_back(tmp);
  }
}
template<typename T>
void print_vector(const std::vector<T> &v) {
  for(auto it = v.begin(); it<v.end(); it++) {
    if(it!=v.begin())
      std::cout << "" "";
    std::cout << (*it);
  }
}

//Copy functions from TCR here.


bool recursive(int N, vector<vector<int> > & sq,
	       int i, int j,
	       const vector<int> & diag) {
  //  cout << i << "" "" << j << endl;
  if (j>=N) {
    i++;
    j = 0;
  }
  if (i>=N) {
    return true;
  }
  
  if (i==j) {
    sq[i][j] = diag[i];
    return recursive(N, sq, i, j+1, diag);
  }

  vector<bool> valid (N+1, true);
  for (int ii=0; ii<i; ++ii) {
    valid[sq[ii][j]] = false;
  }
  for (int jj=0; jj<j; ++jj) {
    valid[sq[i][jj]] = false;
  }
  valid[diag[i]] = false;
  valid[diag[j]] = false;

  for (int v=1; v<=N; ++v) {
    if (valid[v]) {
      sq[i][j] = v;
      if (recursive(N, sq, i, j+1, diag)) { return true; }
      sq[i][j] = 0;
    }
  }

  return false;
  
  
  
}

//Solution:
void solve() {
  int N, K;
  cin >> N >> K;

  if (K==N+1 || K==N*N-1) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }

  if (N==3 || K==5) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }
  if (N==3 || K==7) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }

  if (N==2 && K==2) {
    cout << ""POSSIBLE\n1 2\n2 1\n"";
    return;
  }
  if (N==2 && K==4) {
    cout << ""POSSIBLE\n2 1\n1 2\n"";
    return;
  }

  assert (N>2);
  
  vector<vector<int> > sq (N, vector<int>(N));

  for (int i=0; i<N; ++i) {
    for (int j=0; j<N; ++j) {
      sq[i][j] = (N+i-j)%N + 1;
    }
  }

  vector<int> perm(N+1);
  
  if (K==N) {
    iota(perm.begin(), perm.end(), 0);
  } else if (K%N==0) {
    iota(perm.begin(), perm.end(), 0);
    perm[1] = K/N;
    perm[K/N] = 1;
  } else {
    swap(sq[N-1], sq[N-2]);
    //Diag contains 1 1 ... 1 2 N

    for (int a=1; a<=N; ++a) {
      for (int b=1; b<=N;++b) {
	for (int c=b+1; c<=N; ++c) {
	  if (a==b || a==c) { continue; }
	  if ((N-2)*a + b + c == K) {

	    vector<bool> used(N+1);
	    int v = 1;
	    perm[1] = a;
	    perm[2] = b;
	    perm[N] = c;
	    used[a] = used[b] = used[c] = true;

	    for (int i=3; i<N; ++i) {
	      while (used[v]) { ++v; }
	      used[v] = true;
	      perm[i] = v;
	    }
	    goto done;
	  }
	}
      }
    }

    //Not found elements. Construct another square.

    vector<int> diag (N, 1);
    diag[N-1] = 2;
    diag[N-2] = 2;
    bool res = recursive(N, sq, 0, 0, diag);

    for (int a=1; a<=N; ++a) {
      for (int b=1; b<=N;++b) {
	if (a==b) { continue; }
	if ((N-2)*a + 2*b == K) {

	  vector<bool> used(N+1);
	  int v = 1;
	  perm[1] = a;
	  perm[2] = b;
	  used[a] = used[b] = true;

	  for (int i=3; i<=N; ++i) {
	    while (used[v]) { ++v; }
	    used[v] = true;
	    perm[i] = v;
	  }
	  goto done;
	}
      }
    }
  }
    
  
done:

  cout << ""POSSIBLE\n"";
  for (int i=0; i<N; ++i) {
    for (int j=0; j<N; ++j) {
      if (j!=0) { cout << "" ""; }
      cout << perm[sq[i][j]];
    }
    cout << ""\n"";
  }
  
}

//This is executed before any input is read.
void pre_compute() {
  
}

int main() {
  std::cout << std::setprecision(15);
  std::cin.tie(0);
  pre_compute();
  size_t T;
  std::cin >> T;
  for(size_t i=1; i<=T; i++) {
    std::cout << ""Case #"" << i << "": "";
    solve();

  }

  return 0;
}
",0000000000218069.CPP,000000000019fd27,0000000000218069,0000000000209aa0,JiK,2020
85,0000000000217ca1,"/* My Template for the Google Code Jam.
 *
 * From 2018 onwards.
 *
 * Compile: g++ -std=c++11 -lgmp -lgmpxx [-fopenmp]
 *  - I'm probably using some C++11 features.
 *
 * This code is ugly but it works - otherwise you wouldn't be reading
 * it, right?
 */

#include <bits/stdc++.h>
#include <cassert>
//#define NDEBUG

using namespace std;
typedef size_t szt;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> PLL;

template<typename T>
void read_to_vector(size_t N, std::vector<T> &v) {
  for(size_t i=0; i<N; i++) {
    T tmp;
    std::cin >> tmp;
    v.push_back(tmp);
  }
}
template<typename T>
void print_vector(const std::vector<T> &v) {
  for(auto it = v.begin(); it<v.end(); it++) {
    if(it!=v.begin())
      std::cout << "" "";
    std::cout << (*it);
  }
}

//Copy functions from TCR here.


bool recursive(int N, vector<vector<int> > & sq,
	       int i, int j,
	       const vector<int> & diag) {
  //  cout << i << "" "" << j << endl;
  if (j>=N) {
    i++;
    j = 0;
  }
  if (i>=N) {
    return true;
  }
  
  if (i==j) {
    sq[i][j] = diag[i];
    return recursive(N, sq, i, j+1, diag);
  }

  vector<bool> valid (N+1, true);
  for (int ii=0; ii<i; ++ii) {
    valid[sq[ii][j]] = false;
  }
  for (int jj=0; jj<j; ++jj) {
    valid[sq[i][jj]] = false;
  }
  valid[diag[i]] = false;
  valid[diag[j]] = false;

  for (int v=1; v<=N; ++v) {
    if (valid[v]) {
      sq[i][j] = v;
      if (recursive(N, sq, i, j+1, diag)) { return true; }
      sq[i][j] = 0;
    }
  }

  return false;
  
  
  
}

//Solution:
void solve() {
  int N, K;
  cin >> N >> K;

  if (K==N+1 || K==N*N-1) {
    cout << ""IMPOSSIBLE\n"";
    return;
  }

  if (N==2 && K==2) {
    cout << ""POSSIBLE\n1 2\n2 1\n"";
    return;
  }
  if (N==2 && K==4) {
    cout << ""POSSIBLE\n2 1\n1 2\n"";
    return;
  }

  assert (N>2);
  
  vector<vector<int> > sq (N, vector<int>(N));

  for (int i=0; i<N; ++i) {
    for (int j=0; j<N; ++j) {
      sq[i][j] = (N+i-j)%N + 1;
    }
  }

  vector<int> perm(N+1);
  
  if (K==N) {
    iota(perm.begin(), perm.end(), 0);
  } else if (K%N==0) {
    iota(perm.begin(), perm.end(), 0);
    perm[1] = K/N;
    perm[K/N] = 1;
  } else {
    swap(sq[N-1], sq[N-2]);
    //Diag contains 1 1 ... 1 2 N

    for (int a=1; a<=N; ++a) {
      for (int b=1; b<=N;++b) {
	for (int c=b+1; c<=N; ++c) {
	  if (a==b || a==c) { continue; }
	  if ((N-2)*a + b + c == K) {

	    vector<bool> used(N+1);
	    int v = 1;
	    perm[1] = a;
	    perm[2] = b;
	    perm[N] = c;
	    used[a] = used[b] = used[c] = true;

	    for (int i=3; i<N; ++i) {
	      while (used[v]) { ++v; }
	      used[v] = true;
	      perm[i] = v;
	    }
	    goto done;
	  }
	}
      }
    }

    //Not found elements. Construct another square.

    vector<int> diag (N, 1);
    diag[N-1] = 2;
    diag[N-2] = 2;
    bool res = recursive(N, sq, 0, 0, diag);

    for (int a=1; a<=N; ++a) {
      for (int b=1; b<=N;++b) {
	if (a==b) { continue; }
	if ((N-2)*a + 2*b == K) {

	  vector<bool> used(N+1);
	  int v = 1;
	  perm[1] = a;
	  perm[2] = b;
	  used[a] = used[b] = true;

	  for (int i=3; i<=N; ++i) {
	    while (used[v]) { ++v; }
	    used[v] = true;
	    perm[i] = v;
	  }
	  goto done;
	}
      }
    }
  }
    
  
done:

  cout << ""POSSIBLE\n"";
  for (int i=0; i<N; ++i) {
    for (int j=0; j<N; ++j) {
      if (j!=0) { cout << "" ""; }
      cout << perm[sq[i][j]];
    }
    cout << ""\n"";
  }
  
}

//This is executed before any input is read.
void pre_compute() {
  
}

int main() {
  std::cout << std::setprecision(15);
  std::cin.tie(0);
  pre_compute();
  size_t T;
  std::cin >> T;
  for(size_t i=1; i<=T; i++) {
    std::cout << ""Case #"" << i << "": "";
    solve();

  }

  return 0;
}
",0000000000217ca1.CPP,000000000019fd27,0000000000217ca1,0000000000209aa0,JiK,2020
86,00000000002117e0,"/* My Template for the Google Code Jam.
 *
 * From 2018 onwards.
 *
 * Compile: g++ -std=c++11 -lgmp -lgmpxx [-fopenmp]
 *  - I'm probably using some C++11 features.
 *
 * This code is ugly but it works - otherwise you wouldn't be reading
 * it, right?
 */

#include <bits/stdc++.h>
#include <cassert>
//#define NDEBUG

using namespace std;
typedef size_t szt;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> PLL;

template<typename T>
void read_to_vector(size_t N, std::vector<T> &v) {
  for(size_t i=0; i<N; i++) {
    T tmp;
    std::cin >> tmp;
    v.push_back(tmp);
  }
}
template<typename T>
void print_vector(const std::vector<T> &v) {
  for(auto it = v.begin(); it<v.end(); it++) {
    if(it!=v.begin())
      std::cout << "" "";
    std::cout << (*it);
  }
}

//Copy functions from TCR here.



//Solution:
string solve() {
  int N;
  cin >> N;
  
  vector<int> s(N), e(N);
  for (int i=0; i<N; ++i) {
    cin >> s[i] >> e[i];
  }

  int end_j = 0;
  int end_c = 0;

  vector<int> inds(N);
  iota(inds.begin(), inds.end(), 0);

  sort(inds.begin(), inds.end(), [s](int i, int j) { return s[i] < s[j]; } );


  string res(N, '-');
  
  for (int i : inds) {
    if (s[i] >= end_j) {
      res[i] = 'J';
      end_j = e[i];
    } else if (s[i] >= end_c) {
      res[i] = 'C';
      end_c = e[i];
    } else {
      return ""IMPOSSIBLE"";
    }
  }

  return res;
}

//This is executed before any input is read.
void pre_compute() {
  
}

int main() {
  std::cout << std::setprecision(15);
  std::cin.tie(0);
  pre_compute();
  size_t T;
  std::cin >> T;
  for(size_t i=1; i<=T; i++) {
    //CHOOSE A
    auto res = solve();
    std::cout << ""Case #"" << i << "": "" << res << ""\n"";

  }

  return 0;
}
",00000000002117e0.CPP,000000000019fd27,00000000002117e0,000000000020bdf9,JiK,2020
87,00000000002110b8,"/* My Template for the Google Code Jam.
 *
 * From 2018 onwards.
 *
 * Compile: g++ -std=c++11 -lgmp -lgmpxx [-fopenmp]
 *  - I'm probably using some C++11 features.
 *
 * This code is ugly but it works - otherwise you wouldn't be reading
 * it, right?
 */

#include <bits/stdc++.h>
#include <cassert>
//#define NDEBUG

using namespace std;
typedef size_t szt;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> PLL;

template<typename T>
void read_to_vector(size_t N, std::vector<T> &v) {
  for(size_t i=0; i<N; i++) {
    T tmp;
    std::cin >> tmp;
    v.push_back(tmp);
  }
}
template<typename T>
void print_vector(const std::vector<T> &v) {
  for(auto it = v.begin(); it<v.end(); it++) {
    if(it!=v.begin())
      std::cout << "" "";
    std::cout << (*it);
  }
}

//Copy functions from TCR here.



//Solution:
string solve() {
  string s;
  cin >> s;

  string res;
  int level = 0;
  for (auto c : s) {
    int d = c-'0';
    while (d<level) {
      res += ')';
      --level;
    }
    while (d>level) {
      res += '(';
      ++level;
    }
    res += c;
  }
  while (level) {
    res += ')';
    --level;
  }
  return res;
}

//This is executed before any input is read.
void pre_compute() {
  
}

int main() {
  std::cout << std::setprecision(15);
  std::cin.tie(0);
  pre_compute();
  size_t T;
  std::cin >> T;
  for(size_t i=1; i<=T; i++) {
    //CHOOSE A
    auto res = solve();
    std::cout << ""Case #"" << i << "": "" << res << ""\n"";

  }

  return 0;
}
",00000000002110b8.CPP,000000000019fd27,00000000002110b8,0000000000209a9f,JiK,2020
88,0000000000210c89,"/* My Template for the Google Code Jam.
 *
 * From 2018 onwards.
 *
 * Compile: g++ -std=c++11 -lgmp -lgmpxx [-fopenmp]
 *  - I'm probably using some C++11 features.
 *
 * This code is ugly but it works - otherwise you wouldn't be reading
 * it, right?
 */

#include <bits/stdc++.h>
#include <cassert>
//#define NDEBUG

using namespace std;
typedef size_t szt;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll,ll> PLL;

template<typename T>
void read_to_vector(size_t N, std::vector<T> &v) {
  for(size_t i=0; i<N; i++) {
    T tmp;
    std::cin >> tmp;
    v.push_back(tmp);
  }
}
template<typename T>
void print_vector(const std::vector<T> &v) {
  for(auto it = v.begin(); it<v.end(); it++) {
    if(it!=v.begin())
      std::cout << "" "";
    std::cout << (*it);
  }
}

//Copy functions from TCR here.



//Solution:
void solve() {
  int n;

  cin >> n;

  vector<vector<int> > sq(n);

  for (int i=0; i<n; ++i) {
    read_to_vector(n, sq[i]);
  }

  ll trace = 0;
  for (int i=0; i<n; ++i) {
    trace += sq[i][i];
  }

  int count_r = 0;
  int count_c = 0;
  
  //Test rows
  for (int i=0; i<n; ++i) {
    vector<bool> used(n+1);
    bool c_used = 0;
    for (int j=0; j<n; ++j) {
      c_used |= (used[sq[i][j]]);
      used[sq[i][j]] = true;
    }
    count_r += (c_used);
  }

  //Test cols
  for (int j=0; j<n; ++j) {
    vector<bool> used(n+1);
    bool c_used = 0;
    for (int i=0; i<n; ++i) {
      c_used |= (used[sq[i][j]]);
      used[sq[i][j]] = true;
    }
    count_c += (c_used);
  }

  cout << trace << "" "" << count_r << "" "" << count_c;
  
}

//This is executed before any input is read.
void pre_compute() {
  
}

int main() {
  std::cout << std::setprecision(15);
  std::cin.tie(0);
  pre_compute();
  size_t T;
  std::cin >> T;
  for(size_t i=1; i<=T; i++) {
    //CHOOSE A
    std::cout << ""Case #"" << i << "": "";
    solve();
    std::cout << ""\n""; //Either of these should be removed.

  }

  return 0;
}
",0000000000210c89.CPP,000000000019fd27,0000000000210c89,000000000020993c,JiK,2020
89,000000000021e7bd,"#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <string>
#include <tgmath.h>
#include <tuple>
#include <unordered_map>
#include <vector>
using namespace std;

typedef long long int lli;
typedef pair<int, int> pii;
typedef pair<lli, lli> plli;
// typedef unsigned char byte;
#define byte unsigned char
typedef unsigned int uint;
typedef unsigned long long int ulli;

int all_same[100][100], two_same[100][100], two_diff[100][100];
int ans[100][100];
int perm[100];

int main() {
    int t;
    scanf(""%d"", &t);
    for (int tc=1; tc<=t; ++tc) {
        int n, k;
        scanf(""%d%d"", &n, &k);
        if (n == 2) {
            ans[0][0] = ans[1][1] = k / 2;
            ans[0][1] = ans[1][0] = 3 - k / 2;
            if (k == 3) ans[0][0] = -1;
        } else {
            for (int i=0; i<n; ++i) {
                for (int j=0; j<n; ++j) {
                    all_same[i][j] = two_same[i][j] = two_diff[i][j] = (n - i + j) % n + 1;
                }
            }
            if (n % 2) { // last 3 lines
                for (int i=0; i<n; ++i) {
                    two_same[n-3][i] = i + (i % 2 ? 2 : 4);
                }
                two_same[n-3][0] = 2;
                two_same[n-3][1] = 4;
                two_same[n-3][n-3] = 1;
                two_same[n-3][n-2] = n;
                two_same[n-3][n-1] = 3;
                for (int i=0; i<n; ++i) {
                    two_same[n-2][i] = i + 3;
                }
                two_same[n-2][0] = 4;
                two_same[n-2][1] = 3;
                two_same[n-2][n-2] = 2;
                two_same[n-2][n-1] = 1;
                for (int i=0; i<n; ++i) {
                    int s = n * (n + 1) / 2;
                    for (int j=0; j<n-1; ++j) {
                        s -= two_same[j][i];
                    }
                    two_same[n-1][i] = s;
                }
            } else { // swapping
                for (int i=0; i<n; ++i) {
                    swap(two_same[0][i], two_same[n/2][i]);
                }
                const int v = n / 2 + 1;
                for (int i=0; i<n; ++i) {
                    for (int j=0; j<n; ++j) {
                        if (two_same[i][j] == v) two_same[i][j] = 2;
                        else if (two_same[i][j] == 2) two_same[i][j] = v;
                    }
                }
            }
            for (int i=0; i<n; ++i) {
                swap(two_diff[0][i], two_diff[1][i]);
            }
            // all same
            ans[0][0] = -1;
            if (k % n == 0) {
                const int v = k / n;
                for (int i=0; i<n; ++i) {
                    for (int j=0; j<n; ++j) {
                        ans[i][j] = all_same[i][j];
                        if (ans[i][j] == 1) ans[i][j] = v;
                        else if (ans[i][j] == v) ans[i][j] = 1;
                    }
                }
            }
            // two same
            if (ans[0][0] < 0 && n > 3) {
                int a, b = 0;
                for (a=1; a<=n; ++a) {
                    b = k - (n - 2) * a;
                    if (b % 2) continue;
                    b /= 2;
                    if (1 <= b && b <= n && a != b) break;
                }
                if (a <= n) {
                    memset(perm+1, 0, sizeof(int) * n);
                    perm[1] = a;
                    perm[2] = b;
                    int val = 1;
                    while (val == a || val == b) ++val;
                    for (int i=3; i<=n; ++i) {
                        if (!perm[i]) perm[i] = val++;
                        while (val == a || val == b) ++val;
                    }
                    for (int i=0; i<n; ++i) {
                        for (int j=0; j<n; ++j) {
                            ans[i][j] = perm[two_same[i][j]];
                        }
                    }
                }
            }
            // two diff
            if (ans[0][0] < 0) {
                int a, b = 0, c = 0;
                for (a=1; a<=n; ++a) {
                    for (b=1; b<=n; ++b) {
                        if (a == b) continue;
                        c = k - ((n - 2) * a + b);
                        if (1 <= c && c <= n && c != a && c != b) {
                            goto breaking;
                        }
                    }
                }
            breaking:
                if (a <= n) {
                    memset(perm+1, 0, sizeof(int) * n);
                    perm[1] = a;
                    perm[2] = b;
                    perm[n] = c;
                    int val = 1;
                    while (val == a || val == b || val == c) ++val;
                    for (int i=1; i<=n; ++i) {
                        if (!perm[i]) perm[i] = val++;
                        while (val == a || val == b || val == c) ++val;
                    }
                    for (int i=0; i<n; ++i) {
                        for (int j=0; j<n; ++j) {
                            ans[i][j] = perm[two_diff[i][j]];
                        }
                    }
                }
            }
        }
        if (ans[0][0] < 0) {
            printf(""Case #%d: IMPOSSIBLE\n"", tc);
        } else {
            printf(""Case #%d: POSSIBLE\n"", tc);
            for (int i=0; i<n; ++i) {
                for (int j=0; j<n; ++j) {
                    printf(""%d%c"", ans[i][j], j + 1 == n ? '\n' : ' ');
                }
            }
        }
    }
    return 0;
}
",000000000021e7bd.CPP,000000000019fd27,000000000021e7bd,0000000000209aa0,kipa00,2020
90,0000000000214efc,"#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <string>
#include <tgmath.h>
#include <tuple>
#include <unordered_map>
#include <vector>
using namespace std;

typedef long long int lli;
typedef pair<int, int> pii;
typedef pair<lli, lli> plli;
// typedef unsigned char byte;
#define byte unsigned char
typedef unsigned int uint;
typedef unsigned long long int ulli;

int bit_array[500];

int request(int x) {
    printf(""%d\n"", x);
    fflush(stdout);
    int t;
    scanf(""%d"", &t);
    return t;
}

int main() {
    int t, B;
    scanf(""%d%d"", &t, &B);
    for (int tc=1; tc<=t; ++tc) {
        memset(bit_array, -1, sizeof(int) * (B + 1));
        int diffbit = -1, samebit = -1;
        int pos = 1;
        for (int c=1; c<=15; ++c) {
        	if (pos > B / 2) break;
            int k = diffbit >= 0 || samebit >= 0 ? 4 : 5;
            int a = -1, b = -1;
            if (diffbit >= 0 && samebit >= 0) {
                a = request(diffbit);
                b = request(samebit);
            } else if (diffbit >= 0) {
                a = request(diffbit);
                a = request(diffbit);
            } else if (samebit >= 0) {
                b = request(samebit);
                b = request(samebit);
            }
            int todo = 0;
            if (a >= 0 && a != bit_array[diffbit]) { // inverted or reversed
                todo |= 2;
            }
            if (b >= 0 && b != bit_array[samebit]) { // both or inverted
                todo |= 1;
            }
            if (todo == 3 || todo == 1) {
                for (int i=1; i<=B; ++i) {
                    if (bit_array[i] >= 0) {
                        bit_array[i] = !bit_array[i];
                    }
                }
            }
            if (todo == 2 || todo == 1) {
                reverse(bit_array+1, bit_array+B+1);
            }
            while (k--) {
                bit_array[pos] = request(pos);
                bit_array[B - pos + 1] = request(B - pos + 1);
                if (samebit < 0 && bit_array[pos] == bit_array[B - pos + 1]) {
                    samebit = pos;
                }
                if (diffbit < 0 && bit_array[pos] != bit_array[B - pos + 1]) {
                    diffbit = pos;
                }
                ++pos;
            }
        }
        for (int i=1; i<=B; ++i) {
            putchar('0' | bit_array[i]);
        }
        putchar('\n');
        fflush(stdout);
        char s[2];
        scanf(""%s"", s);
        if (s[0] != 'Y') break;
    }
    return 0;
}

",0000000000214efc.CPP,000000000019fd27,0000000000214efc,0000000000209a9e,kipa00,2020
91,0000000000214701,"#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <string>
#include <tgmath.h>
#include <tuple>
#include <unordered_map>
#include <vector>
using namespace std;

typedef long long int lli;
typedef pair<int, int> pii;
typedef pair<lli, lli> plli;
// typedef unsigned char byte;
#define byte unsigned char
typedef unsigned int uint;
typedef unsigned long long int ulli;

int bit_array[500];

int request(int x) {
    printf(""%d\n"", x);
    fflush(stdout);
    int t;
    scanf(""%d"", &t);
    return t;
}

int main() {
    int t, B;
    scanf(""%d%d"", &t, &B);
    for (int tc=1; tc<=t; ++tc) {
        memset(bit_array, -1, sizeof(int) * (B + 1));
        int diffbit = -1, samebit = -1;
        int pos = 1;
        for (int c=1; c<=15; ++c) {
            int k = diffbit >= 0 || samebit >= 0 ? 4 : 5;
            int a = -1, b = -1;
            if (diffbit >= 0 && samebit >= 0) {
                a = request(diffbit);
                b = request(samebit);
            } else if (diffbit >= 0) {
                a = request(diffbit);
                a = request(diffbit);
            } else if (samebit >= 0) {
                b = request(samebit);
                b = request(samebit);
            }
            int todo = 0;
            if (a >= 0 && a != bit_array[diffbit]) { // inverted or reversed
                todo |= 2;
            }
            if (b >= 0 && b != bit_array[samebit]) { // both or inverted
                todo |= 1;
            }
            if (todo == 3 || todo == 1) {
                for (int i=1; i<=b; ++i) {
                    if (bit_array[i] >= 0) {
                        bit_array[i] = !bit_array[i];
                    }
                }
            }
            if (todo == 2 || todo == 1) {
                reverse(bit_array+1, bit_array+B+1);
            }
            while (k--) {
                bit_array[pos] = request(pos);
                bit_array[B - pos + 1] = request(B - pos + 1);
                if (samebit < 0 && bit_array[pos] == bit_array[B - pos + 1]) {
                    samebit = pos;
                }
                if (diffbit < 0 && bit_array[pos] != bit_array[B - pos + 1]) {
                    diffbit = pos;
                }
                ++pos;
            }
        }
        for (int i=1; i<=B; ++i) {
            putchar('0' | bit_array[i]);
        }
        putchar('\n');
        fflush(stdout);
    }
    return 0;
}
",0000000000214701.CPP,000000000019fd27,0000000000214701,0000000000209a9e,kipa00,2020
92,000000000021181a,"#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <string>
#include <tgmath.h>
#include <tuple>
#include <unordered_map>
#include <vector>
using namespace std;

typedef long long int lli;
typedef pair<int, int> pii;
typedef pair<lli, lli> plli;
// typedef unsigned char byte;
#define byte unsigned char
typedef unsigned int uint;
typedef unsigned long long int ulli;

char s[1200];
typedef struct {
    int s, e, i;
} triple;
triple a[1200];

int main() {
    int t;
    scanf(""%d"", &t);
    for (int tc=1; tc<=t; ++tc) {
        int n;
        scanf(""%d"", &n);
        int jj = -1, cc = -1;
        for (int i=0; i<n; ++i) {
            scanf(""%d%d"", &a[i].s, &a[i].e);
            a[i].i = i;
        }
        sort(a, a+n, [] (auto u, auto v) {
            return u.s < v.s;
        });
        s[n] = 0;
        for (int i=0; i<n; ++i) {
            if (jj <= a[i].s) {
                jj = a[i].e;
                s[a[i].i] = 'J';
            } else if (cc <= a[i].s) {
                cc = a[i].e;
                s[a[i].i] = 'C';
            } else {
                strcpy(s, ""IMPOSSIBLE"");
                break;
            }
        }
        printf(""Case #%d: %s\n"", tc, s);
    }
    return 0;
}
",000000000021181a.CPP,000000000019fd27,000000000021181a,000000000020bdf9,kipa00,2020
93,0000000000210e2d,"#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <string>
#include <tgmath.h>
#include <tuple>
#include <unordered_map>
#include <vector>
using namespace std;

typedef long long int lli;
typedef pair<int, int> pii;
typedef pair<lli, lli> plli;
// typedef unsigned char byte;
#define byte unsigned char
typedef unsigned int uint;
typedef unsigned long long int ulli;

char s[200];

int main() {
    int t;
    scanf(""%d"", &t);
    for (int tc=1; tc<=t; ++tc) {
        printf(""Case #%d: "", tc);
        scanf(""%s"", s);
        int c = 0;
        for (int i=0; s[i]; ++i) {
            int obj_c = s[i] & 15;
            if (c > obj_c) {
                for (int j=c-obj_c; j--;) {
                    putchar(')');
                }
            } else if (c < obj_c) {
                for (int j=obj_c-c; j--;) {
                    putchar('(');
                }
            }
            c = obj_c;
            putchar(s[i]);
        }
        while (c--) putchar(')');
        putchar('\n');
    }
    return 0;
}
",0000000000210e2d.CPP,000000000019fd27,0000000000210e2d,0000000000209a9f,kipa00,2020
94,0000000000210ab5,"#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <sstream>
#include <string>
#include <tgmath.h>
#include <tuple>
#include <unordered_map>
#include <vector>
using namespace std;

typedef long long int lli;
typedef pair<int, int> pii;
typedef pair<lli, lli> plli;
// typedef unsigned char byte;
#define byte unsigned char
typedef unsigned int uint;
typedef unsigned long long int ulli;

int arr[200][200];
bitset<200> check;

int main() {
    int t;
    scanf(""%d"", &t);
    for (int tc=1; tc<=t; ++tc) {
        int n, s = 0, r = 0, c = 0;
        scanf(""%d"", &n);
        for (int i=0; i<n; ++i) {
            for (int j=0; j<n; ++j) {
                scanf(""%d"", &arr[i][j]);
            }
            s += arr[i][i];
        }
        for (int i=0; i<n; ++i) {
            int j;
            check.reset();
            for (j=0; j<n; ++j) {
                if (check.test(arr[i][j])) {
                    break;
                }
                check.set(arr[i][j]);
            }
            r += j < n;
        }
        for (int i=0; i<n; ++i) {
            int j;
            check.reset();
            for (j=0; j<n; ++j) {
                if (check.test(arr[j][i])) {
                    break;
                }
                check.set(arr[j][i]);
            }
            c += j < n;
        }
        printf(""Case #%d: %d %d %d\n"", tc, s, r, c);
    }
    return 0;
}
",0000000000210ab5.CPP,000000000019fd27,0000000000210ab5,000000000020993c,kipa00,2020
