@inproceedings{caliskan2015,
  title={De-anonymizing programmers via code stylometry},
  author={Caliskan-Islam, Aylin and Harang, Richard and Liu, Andrew and Narayanan, Arvind and Voss, Clare and Yamaguchi, Fabian and Greenstadt, Rachel},
  booktitle={24th USENIX security symposium (USENIX Security 15)},
  pages={255--270},
  year={2015}
}

@inproceedings{theiling2000,
  title={Extracting safe and precise control flow from binaries},
  author={Theiling, Henrik},
  booktitle={Proceedings seventh international conference on real-time computing systems and applications},
  pages={23--30},
  year={2000},
  organization={IEEE}
}

@inproceedings{rosenblum2011,
author="Rosenblum, Nathan
and Zhu, Xiaojin
and Miller, Barton P.",
editor="Atluri, Vijay
and Diaz, Claudia",
title="Who Wrote This Code? Identifying the Authors of Program Binaries",
booktitle="Computer Security -- ESORICS 2011",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="172--189",
abstract="Program authorship attribution---identifying a programmer based on stylistic characteristics of code---has practical implications for detecting software theft, digital forensics, and malware analysis. Authorship attribution is challenging in these domains where usually only binary code is available; existing source code-based approaches to attribution have left unclear whether and to what extent programmer style survives the compilation process. Casting authorship attribution as a machine learning problem, we present a novel program representation and techniques that automatically detect the stylistic features of binary code. We apply these techniques to two attribution problems: identifying the precise author of a program, and finding stylistic similarities between programs by unknown authors. Our experiments provide strong evidence that programmer style is preserved in program binaries.",
isbn="978-3-642-23822-2"
}

@inproceedings{cavnar1994,
  title={N-gram-based text categorization},
  author={Cavnar, William B and Trenkle, John M and others},
  booktitle={Proceedings of SDAIR-94, 3rd annual symposium on document analysis and information retrieval},
  volume={161175},
  pages={14},
  year={1994},
  organization={Las Vegas, NV}
}

@article{robertson1998,
    author = {Robertson, Alexander M. and Willett, Peter},
    title = {Applications of n‐grams in textual information systems},
    journal = {Journal of Documentation},
    volume = {54},
    number = {1},
    pages = {48-67},
    year = {1998},
    month = {03},
    abstract = {This paper provides an introduction to the use of n‐grams in textual information systems, where an n‐gram is a string of n, usually adjacent, characters extracted from a section of continuous text. Applications that can be implemented efficiently and effectively using sets of n‐grams include spelling error detection and correction, query expansion, information retrieval with serial, inverted and signature files, dictionary look‐up, text compression, and language identification.},
    issn = {0022-0418},
    doi = {10.1108/EUM0000000007161},
    url = {https://doi.org/10.1108/EUM0000000007161},
    eprint = {https://www.emerald.com/jd/article-pdf/54/1/48/1383969/eum0000000007161.pdf},
}


@article{alrabee2014,
title = {OBA2: An Onion approach to Binary code Authorship Attribution},
journal = {Digital Investigation},
volume = {11},
pages = {S94-S103},
year = {2014},
note = {Proceedings of the First Annual DFRWS Europe},
issn = {1742-2876},
doi = {https://doi.org/10.1016/j.diin.2014.03.012},
url = {https://www.sciencedirect.com/science/article/pii/S1742287614000176},
author = {Saed Alrabaee and Noman Saleem and Stere Preda and Lingyu Wang and Mourad Debbabi},
keywords = {Authorship attribution, Reverse engineering, Binary program analysis, Malware forensics, Digital forensics},
abstract = {A critical aspect of malware forensics is authorship analysis. The successful outcome of such analysis is usually determined by the reverse engineer's skills and by the volume and complexity of the code under analysis. To assist reverse engineers in such a tedious and error-prone task, it is desirable to develop reliable and automated tools for supporting the practice of malware authorship attribution. In a recent work, machine learning was used to rank and select syntax-based features such as n-grams and flow graphs. The experimental results showed that the top ranked features were unique for each author, which was regarded as an evidence that those features capture the author's programming styles. In this paper, however, we show that the uniqueness of features does not necessarily correspond to authorship. Specifically, our analysis demonstrates that many “unique” features selected using this method are clearly unrelated to the authors' programming styles, for example, unique IDs or random but unique function names generated by the compiler; furthermore, the overall accuracy is generally unsatisfactory. Motivated by this discovery, we propose a layered Onion Approach for Binary Authorship Attribution called OBA2. The novelty of our approach lies in the three complementary layers: preprocessing, syntax-based attribution, and semantic-based attribution. Experiments show that our method produces results that not only are more accurate but have a meaningful connection to the authors' styles.}
}

@article{kalgutkar2019,
author = {Kalgutkar, Vaibhavi and Kaur, Ratinder and Gonzalez, Hugo and Stakhanova, Natalia and Matyukhina, Alina},
title = {Code Authorship Attribution: Methods and Challenges},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {1},
issn = {0360-0300},
url = {https://doi.org/10.1145/3292577},
doi = {10.1145/3292577},
abstract = {Code authorship attribution is the process of identifying the author of a given code. With increasing numbers of malware and advanced mutation techniques, the authors of malware are creating a large number of malware variants. To better deal with this problem, methods for examining the authorship of malicious code are necessary. Code authorship attribution techniques can thus be utilized to identify and categorize the authors of malware. This information can help predict the types of tools and techniques that the author of a specific malware uses, as well as the manner in which the malware spreads and evolves. In this article, we present the first comprehensive review of research on code authorship attribution. The article summarizes various methods of authorship attribution and highlights challenges in the field.},
journal = {ACM Comput. Surv.},
month = feb,
articleno = {3},
numpages = {36},
keywords = {Authorship analysis, malware attribution, programming style, software forensics}
}

@article{pedregosa2011,
  title={Scikit-learn: Machine learning in Python},
  author={Pedregosa, Fabian and Varoquaux, Ga{\"e}l and Gramfort, Alexandre and Michel, Vincent and Thirion, Bertrand and Grisel, Olivier and Blondel, Mathieu and Prettenhofer, Peter and Weiss, Ron and Dubourg, Vincent and others},
  journal={the Journal of machine Learning research},
  volume={12},
  pages={2825--2830},
  year={2011},
  publisher={JMLR. org}
}

@article{frances1970,
author = {Allen, Frances E.},
title = {Control flow analysis},
year = {1970},
issue_date = {July 1970},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {7},
issn = {0362-1340},
url = {https://doi.org/10.1145/390013.808479},
doi = {10.1145/390013.808479},
abstract = {Any static, global analysis of the expression and data relationships in a program requires a knowledge of the control flow of the program. Since one of the primary reasons for doing such a global analysis in a compiler is to produce optimized programs, control flow analysis has been embedded in many compilers and has been described in several papers. An early paper by Prosser [5] described the use of Boolean matrices (or, more particularly, connectivity matrices) in flow analysis. The use of “dominance” relationships in flow analysis was first introduced by Prosser and much expanded by Lowry and Medlock [6]. References [6,8,9] describe compilers which use various forms of control flow analysis for optimization. Some recent developments in the area are reported in [4] and in [7].The underlying motivation in all the different types of control flow analysis is the need to codify the flow relationships in the program. The codification may be in connectivity matrices, in predecessor-successor tables, in dominance lists, etc. Whatever the form, the purpose is to facilitate determining what the flow relationships are; in other words to facilitate answering such questions as: is this an inner loop?, if an expression is removed from the loop where can it be correctly and profitably placed?, which variable definitions can affect this use?In this paper the basic control flow relationships are expressed in a directed graph. Various graph constructs are then found and shown to codify interesting global relationships.},
journal = {SIGPLAN Not.},
month = jul,
pages = {1–19},
numpages = {19}
}

@article{stein2009,
author = {Cara Stein and Letha Etzkorn and Sampson Gholston and Phillip Farrington and Dawn Utley and Glenn Cox and Julie Fortune},
title = {Semantic metrics: Mettrics based on semantic aspects of software},
journal = {Applied Artificial Intelligence},
volume = {23},
number = {1},
pages = {44--77},
year = {2009},
publisher = {Taylor \& Francis},
doi = {10.1080/08839510802573574},
URL = {    
        https://doi.org/10.1080/08839510802573574
},
eprint = { 
        https://doi.org/10.1080/08839510802573574
}
}

@inproceedings{claudia2023,
  author={Greco, Claudia and Ianni, Michele and Guzzo, Antonella and Fortino, Giancarlo},
  booktitle={2023 IEEE International Conference on Cyber Security and Resilience (CSR)}, 
  title={Explaining Binary Obfuscation}, 
  year={2023},
  volume={},
  number={},
  pages={22-27},
  keywords={Codes;Computer viruses;Feature extraction;Task analysis;Computer crime;Artificial intelligence;Viruses (medical)},
  doi={10.1109/CSR57506.2023.10224825}}

@article{ali2025,
  title={Does Coding Style Really Survive Compilation? Stylometry of Executable Code Revisited},
  author={Ali, Muaz and Bilgis, Tugay and Bozdag, Nimet Beyza and Debray, Saumya and Rahaman, Sazzadur},
  journal={Proceedings on Privacy Enhancing Technologies},
  year={2025}
}

@Inbook{alrabaee2020,
author="Alrabaee, Saed
and Debbabi, Mourad
and Shirani, Paria
and Wang, Lingyu
and Youssef, Amr
and Rahimian, Ashkan
and Nouh, Lina
and Mouheb, Djedjiga
and Huang, He
and Hanna, Aiman",
title="Binary Analysis Overview",
bookTitle="Binary Code Fingerprinting for Cybersecurity: Application to Malicious Code Fingerprinting",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="7--44",
abstract="When the source code is unavailable, it is important for security applications, such as malwareMalwaredetection, software license infringementSoftware infringement, vulnerability analysisVulnerability analysis, and digital forensicsDigital forensicsto be able to efficiently extract meaningful fingerprints from the binary code. Such fingerprints will enhance the effectiveness and efficiency of reverse engineeringReverse engineeringtasks as they can provide a range of insights into the program binaries. However, a great deal of important information will likely be lost during the compilation process, including variable and function names, the original control and data flow structures, comments, and layout. In this chapter, we provide a comprehensive review of existing binary code fingerprinting frameworks. As such, we systematize the study of binary code fingerprints based on the most important dimensions: the applications that motivate it, the approaches used and their implementations, the specific aspects of the fingerprinting framework, and how the results are evaluated.",
isbn="978-3-030-34238-8",
doi="10.1007/978-3-030-34238-8_2",
url="https://doi.org/10.1007/978-3-030-34238-8_2"
}
